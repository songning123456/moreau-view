#### 什么是Redis？简述它的优缺点？
Redis的全称是Remote Dictionary Server，本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。


因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说用他的List来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的memcached来用。Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。


#### Redis持久化机制？
Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。


`RDB`是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。(快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。)


`AOF`持久化，Redis会将每一个收到的写命令都通过write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。


当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。


#### 缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存更新、缓存降级问题？
| 问题 | 定义 | 解决办法 | 
| :----- | :----- | :----- | 
| <div style="width: 65px;">缓存雪崩</div> | <div style="width: 300px">由于原有缓存失效，新缓存未到期间(例如我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</div> | 大多数系统设计者考虑用加锁(最多的解决方案)或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开。 |
| <div style="width: 65px;">缓存穿透</div> | <div style="width: 300px">用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空(相当于进行了两次无用的查询)。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</div> | 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。Bitmap典型的缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间和时间来完成了。 |
| <div style="width: 65px;">缓存击穿</div> | <div style="width: 300px"> 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</div> | 设置热点数据永远不过期；加互斥锁。 |
| <div style="width: 65px;">缓存预热</div> | <div style="width: 300px">系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据。</div> | 直接写个缓存刷新页面，上线时手工操作下；数据量不大，可以在项目启动的时候自动进行加载；定时刷新缓存。 |
| <div style="width: 65px;">缓存更新</div> | <div style="width: 300px">除了缓存服务器自带的缓存失效策略之外(Redis默认的有6种策略可供选择)，我们还可以根据具体的业务需求进行自定义的缓存淘汰。</div> | 定时去清理过期的缓存；当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂。 |
| <div style="width: 65px;">缓存降级</div> | <div style="width: 300px">当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。</div> | 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 |


#### 热点数据和冷数据是什么？
热点数据，缓存才有价值。


对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存。


对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。


数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。


#### Memcache与Redis的区别都有哪些？
| —— | Redis | Memcache | 
| :----- | :----- | :----- | 
| <div style="width: 140px;">存储方式</div> | 部份存在硬盘上，Redis可以持久化其数据。 | 数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 |
| <div style="width: 140px;">数据支持类型</div> | 支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储。 | 所有的值均是简单的字符串。 |
| <div style="width: 140px;">底层模型/通信应用协议</div> | 直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 | —— |
| <div style="width: 140px;">value值大小不同</div> | 最大可以达到512M。 | 只有1MB。 |
| <div style="width: 140px;">速度</div> | 快 | 慢 |
| <div style="width: 140px;">数据备份</div> | 支持master-slave模式的数据备份。| —— |


#### 单线程的Redis为什么这么快？
1. 纯内存操作。
2. 单线程操作，避免了频繁的上下文切换。
3. 采用了非阻塞I/O多路复用机制。


#### Redis的数据类型，以及每种数据类型的使用场景？
👉 [Redis五种数据结构](https://www.cnblogs.com/haoprogrammer/p/11065461.html)


| 名称 | 解释 |
| :----- | :----- |
| <div style="width: 80px;">string</div> | 最常规的set/get操作，value可以是string也可以是数字。一般做一些复杂的计数功能的缓存。 |
| <div style="width: 80px;">hash</div> | 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 |
| <div style="width: 80px;">list</div> | 使用list的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。 |
| <div style="width: 80px;">set</div> | 因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 |
| <div style="width: 80px;">sorted set</div> | sorted set多了一个权重参数score，集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。 |


```
思考：zset是如何排序的？
```


#### Redis有哪些适合的使用场景？
| 使用场景 | 解释 |
| :----- | :----- |
| <div style="width: 150px;">会话缓存(Session Cache)</div> | 最常用的一种使用Redis的情景是会话缓存(session cache)，用Redis缓存会话比其他存储(如Memcached)的优势在于Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着Redis这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 |
| <div style="width: 150px;">全页缓存(FPC)</div> | 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 |
| <div style="width: 150px;">队列</div> | Redis在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列 平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言(如 Python)对list的push/pop操作。如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis 作为broker，你可以从这里去查看。 |
| <div style="width: 150px;">排行榜/计数器</div> | Redis在内存中对数字进行递增或递减的操作实现的非常好。集合(Set)和有序集合(SortedSet)也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行:ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 |
| <div style="width: 150px;">发布/订阅</div> | 最后(但肯定不是最不重要的)是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统。 |


#### Redis的过期策略以及内存淘汰机制？
Redis采用的是`定期删除`+`惰性删除`策略。


**为什么不用定时删除策略？**


定时删除，用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key，因此没有采用这一策略。


**定期删除+惰性删除是如何工作的呢？**


定期删除，Redis默认每个100ms检查，是否有过期的key，有过期key则删除。需要说明的是，Redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms，全部key进行检查，Redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，Redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。


**采用定期删除+惰性删除就没其他问题了么？**


不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。在redis.conf中有一行配置。
```
maxmemory-policy volatile-lru
```


| <div style="width: 190px">maxmemory-policy参数</div> | 解释 |
| :----- | :----- |
| <div style="width: 190px;color:red;">volatile-lru(默认)</div> | 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰。 |
| <div style="width: 190px;">volatile-ttl</div> | 从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰。 |
| <div style="width: 190px;">volatile-random</div> | 从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。 |
| <div style="width: 190px;">allkeys-lru</div> | 从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰。 |
| <div style="width: 190px;">allkeys-random</div> | 从数据集(server.db[i].dict)中任意选择数据淘汰。 |
| <div style="width: 190px;">no-enviction</div> | 禁止驱逐数据，新写入操作会报错。 |


如果没有设置expire的key，不满足先决条件(prerequisites)；那么volatile-lru，volatile-random和volatile-ttl策略的行为和noeviction(不删除)基本上一致。


#### Redis为什么是单线程的？
因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。Redis利用队列技术将并发访问变为串行访问。


1. 绝大部分请求是纯粹的内存操作。
2. 采用单线程,避免了不必要的上下文切换和竞争条件。
3. 非阻塞IO优点:
```
速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
支持丰富数据类型，支持string，list，set，sorted set，hash；
支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行；
丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题；
```
同时有多个子系统去set一个key。这个时候要注意什么呢？不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。
```
如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可；
如果对这个key操作，要求顺序：分布式锁+时间戳。假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推；
利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性；
```
对Redis的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题，Redis内部已经帮你处理好并发的问题了。


#### 有没有尝试进行多机Redis的部署？如何保证数据一致的？
**主从复制，读写分离**


一类是主数据库(master)、一类是从数据库(slave)。主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。


#### Redis对于大量的请求怎么样处理？
Redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求。


Redis是通过IO多路复用(select、epoll、kqueue。依据不同的平台，采取不同的实现)来处理多个客户端请求的。


#### Redis常见性能问题和解决方案？
1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。
2. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次。
3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。
4. 尽量避免在压力很大的主库上增加从库。
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3 ......。


#### 讲解下Redis线程模型？
文件事件处理器包括分别是`套接字`、`I/O多路复用程序`、`文件事件分派器(dispatcher)`、以及`事件处理器`。使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。


I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面，然后通过这个队列，以有序(sequentially)、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后(该套接字为事件所关联的事件处理器执行完毕)，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。


![Redis线程模型](/images/Redis/RedisModel.png)


#### 为什么Redis的操作是原子性的，怎么保证原子性的？
对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。


Redis的操作之所以是原子性的，是因为Redis是单线程的。


Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。


多个命令在并发中也是原子性的吗？不一定，将get和set改成单命令操作，incr。使用Redis的事务，或者使用Redis+Lua==的方式实现。


#### Redis实现分布式锁？
Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。将key的值设为value，当且仅当key不存在。若给定的key已经存在，则SETNX不做任何动作。使用del key命令就能释放锁。


![分布式锁](/images/Redis/RedisLock.png)


**如何解决死锁？**


1. 通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。
2. 使用setnx key "当前系统时间+锁持有的时间" 和 getset key "当前系统时间+锁持有的时间" 组合的命令就可以实现。


#### Redis有哪些架构模式？讲讲各自的特点？


<div class='redis-mode'>
    <img src='/images/Redis/standalone.png' />
    <img src='/images/Redis/masterslave.png' />
    <img src='/images/Redis/sentinel.png' />
    <img src='/images/Redis/clusterproxy.png' />
    <img src='/images/Redis/clusterdirect.png' />
</div>


| 模式 | 解释 | 特点 | 问题 |
| :----- | :----- | :----- | :----- |
| 单机版 | <div style='width: 200px'>————</div> | 1. 简单。|1. 内存容量有限；<br>2. 处理能力有限；<br>3. 无法高可用。|
| 主从复制 |<div style='width: 200px'>Redis的复制(replication)功能允许用户根据一个Redis服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步给从服务器，从而一直保证主从服务器的数据相同。</div>|1. master/slave角色；<br>2. master/slave数据相同；<br>3. 降低master读压力在转交从库。|1. 无法保证高可用；<br>2. 没有解决master写的压力。|
| 哨兵 |<div style='width: 200px'>Redis sentinel是一个分布式系统中监控Redis主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：<br>1. 监控(Monitoring): Sentinel会不断地检查你的主服务器和从服务器是否运作正常；<br>2. 提醒(Notification)：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知；<br>3. 自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作。</div>|1. 保证高可用；<br>2. 监控各个节点；<br>3. 自动故障迁移。|1. 没有解决master写的压力。|
| 集群(proxy型) |<div style='width: 200px'>Twemproxy是一个Twitter开源的一个Redis和Memcache快速/轻量级代理服务器；Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和Redis协议。</div>|1. 多种hash算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins；<br>2. 支持失败节点自动删除；<br>3. 后端Sharding分片逻辑对业务透明，业务方的读写方式和操作单个Redis一致。|1. 增加了新的proxy，需要维护其高可用。<br>2. failover逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预。|
| 集群(直连型) |<div style='width: 200px'>从Redis3.0之后版本支持Redis-Cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</div>|1. 无中心架构(不存在哪个节点影响性能瓶颈)，少了proxy层；<br>2. 数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；<br>3. 可扩展性，可线性扩展到1000个节点，节点可动态添加或删除；<br>4. 高可用性，部分节点不可用时，集群仍可用。通过增加Slave做备份数据副本；<br>5. 实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升。|1. 资源隔离性较差，容易出现相互影响的情况；<br>2. 数据通过异步复制，不保证数据的强一致性。|


#### 什么是一致性哈希算法？
![consisthash](/images/Redis/consisthash.png)


👉 [一致性哈希算法原理](https://www.cnblogs.com/lpfuture/p/5796398.html)


#### 什么是哈希槽？
从Redis3.0之后版本支持Redis-Cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。


![redisslot](/images/Redis/redisslot.jpg)


**结构特点**


1. 所有的Redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。
2. 节点的fail是通过集群中超过半数的节点检测失效时才生效。
3. 客户端与Redis节点直连，不需要中间proxy层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
4. Redis-Cluster把所有的物理节点映射到[0-16383]slot上(不一定是平均分配)，cluster负责维护node<->slot<->value。
5. Redis集群预分好16384个桶，当需要在Redis集群中放置一个key-value时，根据CRC16(key)mod 16384的值，决定将一个key放到哪个桶中。


#### 如何保证缓存与数据库一致性的？
**串行化**


读请求和写请求串行化，串到一个内存队列里去。串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降 低，用比正常情况下多几倍的机器去支撑线上请求。


**Cache Aside Pattern**


读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应；更新的时候，先更新数据库，然后再删除缓存。


为什么是删除缓存，而不是更新缓存？原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？举个栗子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存更新20次、100次；但是这个缓存在1分钟内只被读取了1次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在1分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低，用到缓存才去算缓存。其实删除缓存，而不是更新缓存，就是一个lazy计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像Mybatis、Hibernate都有懒加载思想。查询一个部门，部门带了一个员工的list，没有必要说每次查询部门，都里面的1000个员工的数据也同时查出来啊。80%的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询1000个员工。


#### Redis大key问题？
👉 [Redis大key问题、问题分析、解决方案](https://www.cnblogs.com/xgqfrms/p/13601959.html)