{"./":{"url":"./","title":"面试宝典","keywords":"","body":"面试宝典 Java专题 基础 集合 线程 并发 虚拟机 设计模式 网络 数据库 SSM框架 Redis Elasticsearch Zookeeper Kafka Eureka Dubbo 微服务 算法专题 数据结构 贪心算法 动态规划 二叉搜索树 DFS BFS 滑动窗口 双指针 区间调度 单调栈/队列 阶乘 二分法查找 水塘抽样 位操作 综合 服务部署 自我/项目概述 面试技巧 面试真题 题卷I 题卷II 题卷III 题卷IV 题卷V 题卷VI 题卷VII 实战问题 问题I 其他资源 面试锦集 学习网站 学习博客 后记 "},"pages/Java.html":{"url":"pages/Java.html","title":"Java专题","keywords":"","body":" 基础 集合 线程 并发 虚拟机 "},"pages/java/Base.html":{"url":"pages/java/Base.html","title":"基础","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Java的四个基本特性？ 面向对象和面向过程的区别？ Java创建对象的有几种方式？ 变量命名规范？ JDK常有哪些用的包？ Object中定义了哪些方法？ ==和equals区别？以及hashCode和equals方法的关系？ static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？是否可以在static环境中访问非static变量？ Java支持的数据类型有哪些？什么是自动拆装箱？ String和StringBuffer、StringBuilder的区别？ Java中的方法重写(Override)和方法重载(Overload)是什么意思？ 访问控制符public、protected、private以及默认(default)的区别？ 接口和抽象类的区别是什么？ Java中Exception和Error有什么区别？ Java中的两种异常类型是什么？他们有什么区别？ final关键字、finally代码块和finalize()方法有什么区别？ 泛型是什么？有什么作用？ 自定义一个注解的过程？ 基础 Java的四个基本特性？ 特性 解释 抽象 就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性，过程抽象是对象的行为特征。 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏，封装分为属性的封装和方法的封装。 继承 是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类，父类的意义在于抽取多类事物的共性。 多态 允许不同类的对象对同一消息做出响应。方法的重载、类的覆盖正体现了多态。 面向对象和面向过程的区别？ 类别 优点 缺点 面向过程 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 没有面向对象易维护、易复用、易扩展。 面向对象 易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。 性能比面向过程低。 Java创建对象的有几种方式？ 使用new关键字 这是我们最常见的也是最简单的创建对象的方式，通过这种方式我们还可以调用任意的构造函数(无参的和有参的)。 Student student = new Student(); 使用Class类的newInstance方法 我们也可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象。 Student student = (Student)Class.forName(\"xxx.xxx.Student\").newInstance(); 或者 Student student = Student.class.newInstance(); 使用Constructor类的newInstance方法 本方法和Class类的newInstance方法很像，java.lang.reflect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。 Constructor constructor = Student.class.getInstance(); Student student = constructor.newInstance(); 使用Clone的方法 无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。这也是原型模式的应用。 Student student2 = student.clone(); 使用反序列化 当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象。在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。 ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"data.obj\")); Student student = (Student)in.readObject(); 变量命名规范？ 除第一个单词外，其他单词首字母大写。 变量名不应该以下划线或美元符号开头。 临时变量通常被取名为I、j、k、m和n，他们一般用于整型；c、d、e他们一般用于字符型。 对不易清楚识别出该变量类型的变量应使用类型名或类型名的缩写作其后缀。 JDK常有哪些用的包？ 包名 解释 java.lang 这个是系统的基础类，比如String、Math、Integer、System和Thread，提供常用功能。 java.io 这里面是所有输入输出有关的类，比如文件操作等。 java.net 这里面是与网络有关的类，比如URL、URLConnection等。 java.util 这个是系统辅助类，特别是集合类Collection、List、Map等。 java.sql 这个是数据库操作的类，Connection、Statememt、ResultSet等。 Object中定义了哪些方法？ 方法 解释 public Boolean equals (Object obj) 比较当前对象与obj是否为同一对象。 public String toString() 返回当前对象的字符串表达形式。 public native int hashCode() 返回对象的Hash码。Hash码的标志对象的唯一值，Hash码相同的对象是同一对象。 protected void finalize() throws Throwable 对象销毁时被调用。 public final native void notify() 唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个wait方法，在对象的监视器上等待。 public final native void notifyAll() 唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个wait方法，在对象的监视器上等待。 public final native void wait() 导致调用者线程等待，直到另一个线程调用notify()或者notifyAll()方法，或者指定的等待时间到达。 ==和equals区别？以及hashCode和equals方法的关系？ == equals 1. 判断两个变量或实例是不是指向同一个内存空间；2. 在JAVA中只是一个运算符合；3. 运行速度快。 1. 判断两个变量或实例所指向的内存空间的值是不是相同；2. 在JAVA中是一个方法；3. 运行速度慢。 equals相等，hashcode必相等；hashcode相等，equals可能不相等。 static关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？是否可以在static环境中访问非static变量？ static关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。 Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 Java支持的数据类型有哪些？什么是自动拆装箱？ 数据类型 字节长度(byte) byte 1 short 2 int 4 long 8 boolean 1 char 2 float 4 double 8 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double等等。反之就是自动拆箱。 String和StringBuffer、StringBuilder的区别？ ———— 可变性 线程安全性 性能 String 用字符数组保存字符串，private final char value[]，所以String对象是不可变的。 对象是不可变的，也就可以理解为常量，线程安全。 每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。 StringBuffer 继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，是可变的。 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 本身进行操作，而不是生成新的对象并改变对象引用。 StringBuilder 同StringBuffer。 并没有对方法进行加同步锁，所以是非线程安全的。 StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升。 Java中的方法重写(Override)和方法重载(Overload)是什么意思？ 重写(Override) 重载(Overload) 1. 发生在父子类中；2. 方法名、参数列表必须相同；3. 返回值类型小于等于父类；4. 抛出的异常小于等于父类；5. 访问修饰符大于等于父类；6. 如果父类方法访问修饰符为private，则子类中就不是重写。 1. 发生在同一个类中；2. 方法名必须相同；3. 参数类型不同、个数不同、顺序不同；4. 方法返回值和访问修饰符可以不同；5. 发生在编译时。 访问控制符public、protected、private以及默认(default)的区别？ 修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 类的成员不写访问修饰时默认为default，默认对于同一个包中的其他类相当于公开(public)，对于不是同一个包中的其他类相当于私有(private)。受保护(protected)对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员(包括内部类)的修饰符可以是以上四种。 接口和抽象类的区别是什么？ 接口 抽象类 1. 不能有构造方法；2. 可以有普通成员变量；3. 所有的方法隐含的都是抽象的；4. 声明的变量默认都是final的；5. 类可以实现很多个接口；6. 类如果要实现一个接口，它必须要实现接口声明的所有方法；7. 成员函数默认是public的；8. 绝对抽象的，不可以被实例化。 1. 可以有构造方法；2. 可以同时包含抽象和非抽象的方法；3. 可以包含非final的变量；4. 类只能继承一个抽象类；5. 类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的；6. 成员函数可以是private、protected或者是public；7. 不可以被实例化，但是如果它包含main方法的话是可以被调用的；8. 可以在不提供接口方法实现的情况下实现接口。 Java中Exception和Error有什么区别？ Exception Error 表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Error类一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Java中的两种异常类型是什么？他们有什么区别？ 受检查的(checked)异常 不受检查的(unchecked)异常 1. 代表程序不能直接控制的无效外界情况(如用户输入、数据库问题、网络异常、文件丢失等)；2. 除了Error和RuntimeException及其子类之外，如ClassNotFoundException、NamingException、ServletException、SQLException、IOException等；3. 需要try catch处理或throws声明抛出异常。 1. 指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复；2. 包括Error与RuntimeException及其子类，如OutOfMemoryError、UndeclaredThrowableException、IllegalArgumentException、IllegalMonitorStateException、NullPointerException、IllegalStateException、IndexOutOfBoundsException等；3. 语法上不需要声明抛出异常。 final关键字、finally代码块和finalize()方法有什么区别？ 名词 作用域 解释 final 类 一个类被final修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是final类中的成员变量是可以改变的，要想final类中的成员变量的不可以改变，必须给成员变量添加final修饰。因此，一个类不能同时被final和abstract修饰，这两个关键字相互矛盾。 方法 修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：final参数用来表示这个参数在这个函数内部不允许被修改。 属性 被final修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。final指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被final修饰的变量必须初始化，该变量其实就是常量。 finally try/catch语句块 finally代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。 finalize Object类的一个方法 protected void finalize() throws Throwable{} 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的finalize()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。 泛型是什么？有什么作用？ 因为集合可以存储的对象类型是任意的，在取出进行向下转型时，容易发生ClassCastException。所以JDK1.5以后就有了解决这个问题的技术泛型。将运行时期的ClassCastException异常转移到编译时期通过编译失败体现，避免了强制转换的麻烦。 自定义一个注解的过程？ 创建@Annotation类。 指定该注解的作用目标。@Target(ElementType.TYPE) // 接口 类 枚举 注解 @Target(ElementType.FIELD) // 字段 枚举的常量 @Target(ElementType.METHOD) // 方法 @Target(ElementType.PARAMETER) // 方法参数 @Target(ElementType.CONSTRUCTOR) // 构造函数 @Target(ElementType.LOCAL_VARIABLE) // 局部变量 @Target(ElementType.ANNOTATION_TYPE) // 注解 @Target(ElementType.PACKAGE) // 包 指定该注解的保留策略。@Retention(RetentionPolicy.SOURCE) // 注解仅存在于源码中，在class字节码文件中不包含 @Retention(RetentionPolicy.CLASS) // 默认的保存策略，注解会在class字节码文件中存在，但运行时无法获得 @Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到 指定该注解是否可以被继承(@Inherited)。 "},"pages/java/Collection.html":{"url":"pages/java/Collection.html","title":"集合","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Java集合类框架的基本接口有哪些？ 为什么集合类没有实现Cloneable和Serializable接口？ 什么是迭代器(Iterator)？Iterator和ListIterator的区别是什么？ 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ Arraylist是如何实现add操作的？ ArrayList是如何实现remove操作的？ HashMap和Hashtable有什么区别？ 你知道HashMap吗？ ConcurrentHashMap实现线程安全的底层原理是什么？ TreeMap结构，如何实现有序的？ Comparable和Comparator接口是干什么的？列出它们的区别？ Java中HashMap、LinkedHashMap和TreeMap区别使用场景？ 集合 Java集合类框架的基本接口有哪些？ 接口 解释 Collection 代表一组对象，每一个对象都是它的子元素。 Set 不包含重复元素的Collection。 List 有顺序的collection，并且可以包含重复元素。 Map 可以把键(key)映射到值(value)的对象，键不能重复。 为什么集合类没有实现Cloneable和Serializable接口？ 集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 什么是迭代器(Iterator)？Iterator和ListIterator的区别是什么？ Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 Iterator ListIterator 1. 可用来遍历Set和List集合；2. 对集合只能是前向遍历；3. 实现了Iterator接口，并包含其他的功能。比如增加元素，替换元素，获取前一个和后一个元素的索引等等。 1. 只能用来遍历List；2. 既可以前向也可以后向遍历。 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 快速失败 安全失败 1. java.util包下面的所有的集合类都是快速失败的；2. 快速失败的迭代器会抛出ConcurrentModificationException异常。 1. java.util.concurrent包下面的所有的类都是安全失败的；2. 安全失败的迭代器永远不会抛出这样的异常。 Arraylist是如何实现add操作的？ 👉 ArrayList中add()方法的执行过程 调用add(E e)方法。 获取当前ArrayList实例的元素个数size。 计算新元素追加完成后的实例应该具备的最小容量minCapacity=size+1。 获取当前ArrayList实例elementData: 如果该实例为new时创建的默认对象，获取一个默认的初始容量DEFAULT_CAPACITY=10； 如果该实例非新构建的对象，则获取该实例追加元素后应该具备的最小容量minCapacity。 元素追加或进行扩容+数据迁移操作: 追加元素后应该具备的最小容量minCapacity执行数据追加操作，直接跳到第8步； 集合刚被创建时minCapacity>elementData.length执行扩容+数据迁移操作； 追加元素时如果minCapacity>elementData.length执行扩容+数据迁移操作。 执行扩容操作，返回扩容后容量。先将容量扩容到当前容量的1.5倍，判断是否够用minCapacity。扩容后容量未超出MAX_ARRAY_SIZE，返回扩容后容量newCapacity；扩容后容量超出MAX_ARRAY_SIZE，返回Integer.MAX_VALUE。 不够用将容量扩容为minCapacity； 判断扩容后的容量是否超出了数组限定的最大容量MAX_ARRAY_SIZE=Integer.MAX_VALUE-8。 为什么数组的最大值是Integer.MAX_VALUE-8？ 数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节。如果数组长度过大，可能出现的两种错误。 OutOfMemoryError: Java heap space堆区内存不足（这个可以通过设置JVM参数-Xmx来指定）。 OutOfMemoryError: Requested array size exceeds VM limit超过了JVM虚拟机的最大限制。 执行Arrays.copyOf(elementData, newCapacity)操作，复制当前实例对象到新的数组。 执行新元素的追加操作elementData[size++]=e，size在方法内自增。 /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) { //扩容运算，原数据迁移 ensureCapacityInternal(size + 1); //追加新元素，size自增 elementData[size++] = e; return true; } ..........此处省略无关代码.......... /** * 得到一个初始容量或新元素添加完成后所需的最小容量 * @param elementData 当前实例对象 * @param minCapacity 所需的最小容量 = size + 1 */ private static int calculateCapacity(Object[] elementData, int minCapacity) { // DEFAULTCAPACITY_EMPTY_ELEMENTDATA是使用空参构造的默认空数组 // elementData如果与其相等，则当前实例创建后未进行过任何操作，此时返回默认容量10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } private void ensureExplicitCapacity(int minCapacity) { modCount++; if (minCapacity - elementData.length > 0) // 容量溢出，进行扩容运算和原数据迁移 grow(minCapacity); } /** * 要分配的数组的最大大小。 * 一些VM在数组中保留一些标题字 * 尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超出了VM限制 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * 增加容量以确保它至少可以容纳最小容量参数指定的元素数。 * * @param minCapacity 所需的最小容量 */ private void grow(int minCapacity) { // 先将当前实例的数组容量扩容到1.5倍 int oldCapacity = elementData.length; // 当前容量 int newCapacity = oldCapacity + (oldCapacity >> 1); // 位移运算 >> 1 相当于除以2 // 扩容后不够用，将数组容量直接扩容到实际长度 if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); //扩容完成，复制当前实例数据到新的数组 elementData = Arrays.copyOf(elementData, newCapacity); } private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } ArrayList是如何实现remove操作的？ public E remove(int index) { // 先检查下标索引是是否越界 rangeCheck(index); // ArrayList的修改次数加1 modCount++; // 获取索引对应的元素值 E oldValue = elementData(index); // 获取删除元素后，需要移动的元素的个数 int numMoved = size - index - 1; if (numMoved > 0) // 将元素进行移动拷贝 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 最后将多出的位置设置为空，这样说明是没有引用的对象了 elementData[--size] = null; // Let gc do its work // 返回删除的旧值 return oldValue; } HashMap和Hashtable有什么区别？ HashMap Hashtable 1. 允许键和值是null；2. 非同步，适合于单线程环境；3. 可供应用迭代的键的集合，因此，HashMap是快速失败的。 1. 不允许键或者值是null；2. 同步，适合于多线程环境；3. 对键的列举(Enumeration)。 你知道HashMap吗？ 👉 【原创】HashMap复习精讲 数组+链表+红黑树 对key求Hash值，然后再计算下标。 如果没有碰撞，直接放入桶中。 如果碰撞了，以链表的方式链接到后面； 如果链表长度超过阀值(TREEIFY_THRESHOLD == 8)，就把链表转成红黑树。 如果节点已经存在就替换旧值。 如果桶满了(容量 * 加载因子)，就需要resize。 // put操作 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { int h; // 1. 求hash值 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) { n = (tab = resize()).length; } if ((p = tab[i = (n - 1) & hash]) == null) { // 2. 如果没有碰撞，直接放入桶中 tab[i] = newNode(hash, key, value, null); } else { Node e; K k; // 3. 如果碰撞了，以链表的方式链接到后面 if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) { e = p; } else if (p instanceof TreeNode) { e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); } else { // 4. 如果链表长度超过阀值(TREEIFY_THRESHOLD == 8)，就把链表转成红黑树 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // -1 for 1st if (binCount >= TREEIFY_THRESHOLD - 1) { treeifyBin(tab, hash); } break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) { break; } p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) { // 5. 如果节点已经存在就替换旧值 e.value = value; } afterNodeAccess(e); return oldValue; } } ++modCount; // 6. 如果桶满了(容量 * 加载因子)，就需要resize if (++size > threshold) { resize(); } afterNodeInsertion(evict); return null; } 红黑树的5个特性 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点是黑色。 如果一个节点是红色的，则它的子节点必须是黑色。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点(这里指到叶子节点的路径)。 扩容后，原始值所在的位置 元素的下标要么不变，要么变为原下标+原容量。 ConcurrentHashMap实现线程安全的底层原理是什么？ 锁分段技术 首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的。但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 TreeMap结构，如何实现有序的？ TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。TreeMap基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。 // 测试用例 Map treeMap = new TreeMap<>(); treeMap.put(\"3\", 3); treeMap.put(\"2\", 2); treeMap.put(\"1\", 1); treeMap.put(\"4\", 4); for (Map.Entry item : treeMap.entrySet()) { String key = item.getKey(); Integer value = item.getValue(); System.out.println(\"key -> \" + key + \"; value -> \" + value); } // 运行结果 key -> 1; value -> 1 key -> 2; value -> 2 key -> 3; value -> 3 key -> 4; value -> 4 Comparable和Comparator接口是干什么的？列出它们的区别？ Comparable实现 Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。此外，实现Comparable接口的类的对象可以用作有序映射(如TreeMap)中的键或有序集合(TreeSet)中的元素，而不需要指定比较器。接口中通过x.compareTo(y)来比较x和y的大小。若返回负数，意味着x y。 // Person对象 public class Person implements Comparable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(Person person) { // this.age - person.age升序，person.age - this.age降序 return this.age - person.age; } @Override public String toString() { return this.name + \"-\" + this.age; } } // Comparable实现 public class ComparableMain { public static void main(String[] args) { ArrayList list = new ArrayList<>(); list.add(new Person(\"ccc\", 20)); list.add(new Person(\"AAA\", 30)); list.add(new Person(\"bbb\", 10)); list.add(new Person(\"ddd\", 40)); System.out.println(\"Comparable-before: \" + list); Collections.sort(list); System.out.println(\"Comparable-after: \" + list); } } // 结果 Comparable-before: [ccc-20, AAA-30, bbb-10, ddd-40] Comparable-after: [bbb-10, ccc-20, AAA-30, ddd-40] Comparator实现 Comparator是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个该类的比较器来进行排序。这个比较器只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator类来新建一个比较器，然后通过该比较器对类进行排序。int compare(T o1, T o2)和上面的x.compareTo(y)类似，定义排序规则后返回。正数，零和负数分别代表大于、等于和小于。 // Person略，去掉implements Comparable ... // 升序 public class AscComparator implements Comparator { @Override public int compare(Person person1, Person person2) { return person1.getAge() - person2.getAge(); } } // 降序 public class DescComparator implements Comparator { @Override public int compare(Person person1, Person person2) { return person2.getAge() - person1.getAge(); } } // Comparator实现 public class ComparatorMain { public static void main(String[] args) { ArrayList list = new ArrayList<>(); list.add(new Person(\"ccc\", 20)); list.add(new Person(\"AAA\", 30)); list.add(new Person(\"bbb\", 10)); list.add(new Person(\"ddd\", 40)); System.out.println(\"Comparator-before: \" + list); AscComparator ascComparator = new AscComparator(); list.sort(ascComparator); System.out.println(\"Comparator-asc: \" + list); DescComparator descComparator = new DescComparator(); list.sort(descComparator); System.out.println(\"Comparator-desc: \" + list); } } // 结果 Comparator-before: [ccc-20, AAA-30, bbb-10, ddd-40] Comparator-asc: [bbb-10, ccc-20, AAA-30, ddd-40] Comparator-desc: [ddd-40, AAA-30, ccc-20, bbb-10] Java中HashMap、LinkedHashMap和TreeMap区别使用场景？ HashMap LinkedHashMap TreeMap k的值没有顺序，常用来做统计。 内部有一个链表，保持Key插入的顺序。迭代的时候，也是按照插入顺序迭代，而且迭代比HashMap快。 顺序是key的自然顺序(如整数从小到大)，也可以指定比较函数，但不是插入的顺序。 "},"pages/java/Thread.html":{"url":"pages/java/Thread.html","title":"线程","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 进程和线程的区别是什么？ 创建线程有几种不同的方式？你喜欢哪一种？为什么？ 概括的解释下线程的几种可用状态？ 如何停止一个线程？ sleep和wait的区别？ 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？ 多线程之间是如何进行信息交互的？ 多线程的几种通讯方式？ 说说线程池的创建方式？ 线程池的底层工作原理？ 能说说线程池的核心配置参数？ThreadPoolExecutor有哪些拒绝策略？ JDK提供了多少种阻塞队列？如果在线程池中使用无界阻塞队列会发生什么问题？ 如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？该如何解决？ 如何合理的配置线程池？ 线程池中当coreSize=0会发生什么？ ThreadLocal为什么被设计为弱引用？ ThreadLocalMap中的Entry是什么数据结构，数组还是链表？ 锁的升级？什么是轻量级锁？什么是重量级锁？ 线程 进程和线程的区别是什么？ 进程 线程 1. 进程是拥有资源的基本单位；2. 进程拥有独立的地址空间；3. 同一个进程的线程共享该进程的地址空间；4. 进程上下文切换相对线程上下文切换会消耗更多的资源；5. 一个进程必须至少拥有一个线程；6. 进程的通信有多种方式，包括管道、共享内存、消息等等。 1. 线程是CPU调度的基本单位；2. 一个线程死掉就等于整个进程死掉，所以多进程的程序相对于多线程的程序来说会更健壮；3. 线程通过进程内的资源进行通信。 创建线程有几种不同的方式？你喜欢哪一种？为什么？ 继承Thread类。 实现Runnable接口。 应用程序可以使用Executor框架来创建线程池。 实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承(而Java不支持多继承)，只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。 概括的解释下线程的几种可用状态？ 状态 解释 就绪(Runnable) 线程准备运行，不一定立马就能开始执行。 运行中(Running) 进程正在执行线程的代码。 等待中(Waiting) 线程处于阻塞的状态，等待外部的处理结束。 睡眠中(Sleeping) 线程被强制睡眠。 I/O阻塞(Blocked on I/O) 等待I/O操作完成。 同步阻塞(Blocked on Synchronization) 等待获取锁。 死亡(Dead) 线程完成了执行。 如何停止一个线程？ 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。 使用interrupt方法中断线程。 sleep和wait的区别？ sleep wait 1. Thread类中方法；2. 可以在任何地方使用；3. 程序暂停执行指定的时间，让出cpu该其他线程，但是它的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。 1. Object类中的方法；2. 只能在同步代码块或同步方法中使用；3. 线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？ join()方法 // Thread1 public class Thread1 implements Runnable { @Override public void run() { for (int i = 0; i \" + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } // Thread2 public class Thread2 implements Runnable { @Override public void run() { for (int i = 0; i \" + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } // Thread3 public class Thread3 implements Runnable { @Override public void run() { for (int i = 0; i \" + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 测试方法 public class TestJoin1Main { public static void main(String[] args) { Thread thread1 = new Thread(new Thread1(), \"线程1\"); Thread thread2 = new Thread(new Thread2(), \"线程2\"); Thread thread3 = new Thread(new Thread3(), \"线程3\"); try { thread1.start(); thread1.join(); thread2.start(); thread2.join(); thread3.start(); thread3.join(); } catch (Exception e) { e.printStackTrace(); } } } // 结果 线程1=====>0 线程1=====>1 线程2=====>0 线程2=====>1 线程3=====>0 线程3=====>1 // 测试方法 public class TestJoin2Main { public static void main(String[] args) { Thread thread1 = new Thread(() -> { for (int i = 0; i \" + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"线程1\"); Thread thread2 = new Thread(() -> { try { thread1.join(); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \" + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"线程2\"); Thread thread3 = new Thread(() -> { try { thread2.join(); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \" + i); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"线程3\"); thread1.start(); thread2.start(); thread3.start(); } } // 结果 线程1=====>0 线程1=====>1 线程2=====>0 线程2=====>1 线程3=====>0 线程3=====>1 多线程之间是如何进行信息交互的？ 方法 解释 void notify() 唤醒在此对象监视器上等待的单个线程。 void notifyAll() 唤醒在此对象监视器上等待的所有线程。 void wait() 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法。 void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。 void wait(long timeout,int nanos) 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 多线程的几种通讯方式？ 同步 多个线程通过synchronized关键字这种方式来实现线程间的通信。 public class MyObject { synchronized public void methodA() { //do something.... } synchronized public void methodB() { //do some other thing } } public class ThreadA extends Thread { private MyObject object; @Override public void run() { super.run(); object.methodA(); } } public class ThreadB extends Thread { private MyObject object; @Override public void run() { super.run(); object.methodB(); } } public class Run { public static void main(String[] args) { MyObject object = new MyObject(); //线程A与线程B 持有的是同一个对象:object ThreadA a = new ThreadA(object); ThreadB b = new ThreadB(object); a.start(); b.start(); } } 由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了通信。这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁(获得了访问权限)，谁就可以执行。 while轮询的方式 import java.util.ArrayList; import java.util.List; public class MyList { private List list = new ArrayList(); public void add() { list.add(\"elements\"); } public int size() { return list.size(); } } import mylist.MyList; public class ThreadA extends Thread { private MyList list; public ThreadA(MyList list) { super(); this.list = list; } @Override public void run() { try { for (int i = 0; i 在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信。但是这种方式会浪费CPU资源。之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥有用的工作，只是在不断地测试某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是在干别的事情，当有电话来时，响铃通知TA电话来了。这种方式还存在另外一个问题：轮询的条件的可见性问题。线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。 wait/notify机制 import java.util.ArrayList; import java.util.List; public class MyList { private static List list = new ArrayList(); public static void add() { list.add(\"anyString\"); } public static int size() { return list.size(); } } public class ThreadA extends Thread { private Object lock; public ThreadA(Object lock) { super(); this.lock = lock; } @Override public void run() { try { synchronized (lock) { if (MyList.size() != 5) { System.out.println(\"wait begin \" + System.currentTimeMillis()); lock.wait(); System.out.println(\"wait end \" + System.currentTimeMillis()); } } } catch (InterruptedException e) { e.printStackTrace(); } } } public class ThreadB extends Thread { private Object lock; public ThreadB(Object lock) { super(); this.lock = lock; } @Override public void run() { try { synchronized (lock) { for (int i = 0; i 线程A要等待某个条件满足时(list.size() == 5)，才执行操作。线程B则向list中添加元素，改变list的size。A、B之间如何通信的呢？也就是说，线程A如何知道list.size()已经为5了呢？这里用到了Object类的wait()和notify()方法。当条件未满足时(list.size() != 5)，线程A调用wait()放弃CPU，并进入阻塞状态。不像while轮询那样占用CPU。当条件满足时，线程B调用notify()通知线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。这种方式的一个好处就是CPU的利用率提高了。但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：通知过早，会打乱程序的执行逻辑。 管道通信 java.io.PipedInputStream和java.io.PipedOutputStream。 说说线程池的创建方式？ newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 // 无限大小线程池JVM自动回收 ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i 总结：线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(5); for (int i = 0; i 总结：因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置，如Runtime.getRuntime().availableProcessors()。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 // 延时3秒执行 ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(5); for (int i = 0; i newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO、LIFO优先级)执行。 ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i 注意: 结果依次输出，相当于顺序执行各个任务。 线程池的底层工作原理？ 在创建了线程池后，等待提交过来的任务请求。 在调用execute()方法添加一个请求任务时，线程池会做如下判断：如果正在运行的线程数量小于corePoolSize=5，那么马上创建线程运行这个任务； 如果正在运行的线程数量大于或等于corePoolSize=5，那么将这个任务放入队列； 如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会启动饱和拒绝策略来执行。 当一个线程完成任务时，它会从队列中去下一个任务来执行。 当一个线程无事可做超过一定的时间(keepAliveTime)时，线程池会判断：如果当前运行的线程数大于corePoolSize=5，那么这个线程就被停掉。所以线程池的所有任务完成后它最终会收缩到corePoolSize=5的大小。 能说说线程池的核心配置参数？ThreadPoolExecutor有哪些拒绝策略？ 参数 默认值 解释 corePoolSize(核心线程数) 1 1.核心线程会一直存在，即使没有任务执行； 2.当线程数小于核心线程数的时候，即使有空闲线程，也会一直创建线程直到达到核心线程数； 3.设置allowCoreThreadTimeout=true(默认false)时，核心线程会超时关闭。 queueCapacity(任务队列容量) Integer.MAX_VALUE 也叫阻塞队列，当核心线程都在运行，此时再有任务进来，会进入任务队列，排队等待线程执行。 maxPoolSize(最大线程数) Integer.MAX_VALUE 1.线程池里允许存在的最大线程数量； 2.当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务； 3.线程池里允许存在的最大线程数量。当任务队列已满，且线程数量大于等于核心线程数时，会创建新的线程执行任务。 keepAliveTime(线程空闲时间) 60秒 1.当线程空闲时间达到keepAliveTime时，线程会退出(关闭)，直到线程数等于核心线程数； 2.如果设置了allowCoreThreadTimeout=true，则线程会退出直到线程数等于零。 allowCoreThreadTimeout(允许核心线程超时) false ———— rejectedExecutionHandler(任务拒绝处理器) AbortPolicy() 1.当线程数量达到最大线程数，且任务队列已满时，会拒绝任务； 2.调用线程池shutdown()方法后，会等待执行完线程池的任务之后，再shutdown()。如果在调用了shutdown()方法和线程池真正shutdown()之间提交任务，会拒绝新任务。 👉 四种线程池拒绝策略 拒绝策略 解释 AbortPolicy 直接抛异常。 DiscardPolicy 抛弃当前将要加入队列的任务。 DiscardOldestPolicy 抛弃任务队列中最旧任务。 CallerRunsPolicy 当前任务会强制调用run先执行，任务将由调用者线程(可能是主线程)去执行。缺点可能会阻塞主线程。 自定义 如果后续慢慢的队列里没任务了，线程空闲了，超过corePoolSize的线程会自动释放掉，在keepAliveTime之后就会释放。 JDK提供了多少种阻塞队列？如果在线程池中使用无界阻塞队列会发生什么问题？ 阻塞队列 解释 ArrayBlockingQueue 一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue 一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue 一个支持优先级排序的无界阻塞队列。 DelayQueue 一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue 一个不存储元素的阻塞队列。 LinkedTransferQueue 一个由链表结构组成的无界阻塞队列。 LinkedBlockingQueue 一个由链表结构组成的双向阻塞队列。 线程池 默认队列 解释 Executors.newFixedThreadPool(10) LinkedBlockingQueue 无限加入队列。 Executors.newScheduledThreadPool(10) DelayedWorkQueue 队列如果满了，阻塞。 Executors.newSingleThreadScheduledExecutor() DelayedWorkQueue 队列如果满了，阻塞。 Executors.newCachedThreadPool() SynchronousQueue 队列如果满了，抛异常。 Executors.newSingleThreadExecutor() LinkedBlockingQueue 无限加入队列。 因为调用异常，会调用超时，线程处理任务时间是超时时间，线程池等待队列，会变得越来越大，此时会导致内存飙升起来，而且还可能导致OOM，内存溢出或者频繁的GC。 如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？该如何解决？ 机器宕机，必然会导致线程池里的积压的任务丢失。 在提交一个任务到线程池里去，提交之前，将这个任务信息持久化到数据库里，此时的状态为未提交，提交成功之后，更新任务信息的状态为提交成功。当任务完成的时候，更新任务信息的状态为已完成；当宕机的机器重启的时候，可以开启一个后台线程，扫描数据库里未提交和已提交的任务，可以把任务读取出来，重新提交到线程池中，继续进行执行，被调用的方法一定做好幂等操作，防止请求重复执行。 如何合理的配置线程池？ 角度 类型 解释 任务的性质 CPU密集型任务 配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。 IO密集型任务 由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。 混合型任务 如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 任务的优先级 高、中和低 使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。 任务的执行时间 长、中和短 交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。 任务的依赖性 是否依赖其他系统资源，如数据库连接 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。 线程池中当coreSize=0会发生什么？ 当核心线程数为0的时候，会创建一个非核心线程进行执行。 核心线程数不为0的时候，如果核心线程数在执行，会有一个非核心线程数从队列中取对象执行线程。 核心线程数执行的是队列的take，非核心线程数执行队列的offer和poll。 核心线程数不为0且队列为SynchronousQueue时，就成了单线程运行了。 👉 自定义线程池核心线程数设置0任务还会执行吗？ 👉 最近踩的一个线程池的坑: coreSize=0&&queueCapacity>1 👉 Java线程池为什么核心线程数为0依然能执行？ ThreadLocal为什么被设计为弱引用？ // get public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } // set public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } // remove public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } private void remove(ThreadLocal key) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode & (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { e.clear(); expungeStaleEntry(i); return; } } } 👉 谈谈ThreadLocal为什么被设计为弱引用 👉 ThreadLocal的原理、作用、使用弱引用原因、应用举例 ThreadLocalMap中的Entry是什么数据结构，数组还是链表？ 👉 为什么ThreadLocal类内部的ThreadLocalMap要用Entry数组实现？ 锁的升级？什么是轻量级锁？什么是重量级锁？ 👉 多线程锁的升级原理是什么? 👉 synchronized 锁的升级原理是什么? "},"pages/java/Concurrence.html":{"url":"pages/java/Concurrence.html","title":"并发","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 什么是死锁(deadlock)？如何才能产生死锁？ 如何预防死锁？死锁的解决办法？ 说说synchronized关键字的底层原理？ 你知道synchronized的使用场景吗，它是如何使用的？ synchronized是可重入锁吗？ synchronized和Lock的区别？ 同步关键字(synchronized)修饰静态方法和修饰非静态方法的区别？ 悲观锁和乐观锁的区别？ 能聊聊你对CAS的理解以及它的底层原理吗？ 你对JDK的AQS理解吗？AQS的实现原理是什么？ 谈谈你对Java内存模型的理解？ 并发 什么是死锁(deadlock)？如何才能产生死锁？ 当一个线程永远地持有一个锁，并且其他线程都尝试获得这个锁时，那么它们将永远被阻塞。在线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远地等待下去。这种就是最简答的死锁形式(或者叫做“抱死”)。 条件 解释 互斥条件 所谓互斥就是进程在某一时间内独占资源。 请求与保持条件 一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件 进程已获得资源，在末使用完之前，不能强行剥夺。 循环等待条件 若干进程之间形成一种头尾相接的循环等待资源关系。 如何预防死锁？死锁的解决办法？ 条件 解释 打破互斥条件 即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。 打破不可抢占条件 即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。 打破占有且申请条件 可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。 打破循环等待条件 实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。 在Account中包含一个唯一的，不可变的值。比如说账号等。通过对这个值对对象进行排序(snowFlakeId)。 @Data public class Account { private Integer id; private Integer balance; public Account(Integer id, Integer balance) { this.id = id; this.balance = balance; } /** * 借记 * * @param money * @throws Exception */ public void debit(int money) throws Exception { Thread.sleep(500); balance = balance + money; } /** * 信贷 * * @param money * @throws Exception */ public void credit(int money) throws Exception { Thread.sleep(500); balance = balance - money; } public int compareTo(int money) { if (balance > money) { return 1; } else if (balance public class Helper { public void transfer(Account fromAccount, Account toAccount, int amount) throws Exception { if (fromAccount.compareTo(amount) public class TransferThread extends Thread { public static List accountList = Arrays.asList(new Account(1, 1000), new Account(2, 1000)); @Override public void run() { int i = new Random().nextInt(2); Account fromAccount, toAccount; if (i == 0) { fromAccount = accountList.get(1); toAccount = accountList.get(0); } else { fromAccount = accountList.get(0); toAccount = accountList.get(1); } try { Lock.transferMoney(fromAccount, toAccount, 1); } catch (Exception e) { System.out.println(\"发生异常-------\" + e); } } } public class Lock { public static void transferMoney(Account fromAccount, Account toAccount, int amount) throws Exception { int fromId = fromAccount.getId(); int toId = toAccount.getId(); System.out.println(\"账户\" + fromId + \" 向账户 \" + toId + \" 转账\"); if (fromId toId) { synchronized (toAccount) { synchronized (fromAccount) { new Helper().transfer(fromAccount, toAccount, amount); } } } else { throw new Exception(\"from,to不能相等!!!\"); } } } public class DemoMain { public static void main(String[] args) { for (int i = 0; i 说说synchronized关键字的底层原理？ 👉 synchronized 关键字底层原理 synchronized同步语句块的实现，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。 当执行monitorenter指令时，线程试图获取锁，也就是获取monitor(monitor对象存在于每个Java对象的对象头中，synchronized锁便是通过这种方式获取锁的，这也是为什么Java中任意对象都可以作为锁的原因)的持有权。当计数器为0，则可以成功获取，获取后将锁计数器设为1，也就是加1；相应的，在执行monitorexit指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 你知道synchronized的使用场景吗，它是如何使用的？ 分类 被锁的对象 伪代码 解释 实例方法 类的实例对象 public synchronized void method() { ... } 实例方法，锁住的是该类的实例对象。 静态方法 类对象 public static synchronized void method() { ... } 静态方法，锁住的是类对象。 实例对象 类的实例对象 synchronized(this) { ... } 同步代码块，锁住的是该类的实例对象。 Class对象 类对象 synchronized(Clazz.class) { ... } 同步代码块，锁住的是该类的类对象。 任意实例对象 实例对象Object Object object = new Object(); synchronized(object) { ... } 同步代码块，锁住的是配置的实例对象。 synchronized是可重入锁吗？ 当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。 public class Xttblog extends SuperXttblog { public static void main(String[] args) { Xttblog child = new Xttblog(); child.doSomething(); } public synchronized void doSomething() { System.out.println(\"child.doSomething()\" + Thread.currentThread().getName()); doAnotherThing(); // 调用自己类中其他的synchronized方法 } private synchronized void doAnotherThing() { super.doSomething(); // 调用父类的synchronized方法 System.out.println(\"child.doAnotherThing()\" + Thread.currentThread().getName()); } } class SuperXttblog { public synchronized void doSomething() { System.out.println(\"father.doSomething()\" + Thread.currentThread().getName()); } } child.doSomething()Thread-5492 father.doSomething()Thread-5492 child.doAnotherThing()Thread-5492 验证出synchronized是可重入锁了。因为这些方法输出了相同的线程名称，表明即使递归使用synchronized也没有发生死锁，证明其是可重入的。 重入锁实现可重入性原理或机制是每一个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为0，则释放该锁。 synchronized和Lock的区别？ synchronized Lock 1. 关键字，内置语言实现；2. 在线程发生异常时会自动释放锁，因此不会发生异常死锁；3. 非中断锁，必须等待线程执行完成释放锁。 1. Lock是接口；2. 异常时不会自动释放锁，所以需要在finally中实现释放锁；3. 中断锁；4. 使用读锁提高多线程读效率。 同步关键字(synchronized)修饰静态方法和修饰非静态方法的区别？ 修饰非静态方法 class Demo { private int i; Demo(int i) { this.i = i; } public synchronized void getI(String s) { for (int j = 0; j // 非静态方法结果 ... 1---------thread0 1---------thread0 2---------thread2 1---------thread0 2---------thread2 1---------thread0 1---------thread1 1---------thread1 2---------thread2 1---------thread1 1---------thread1 ... 可以看到Thread0和Thread2交替出现，Thread1和Thread2交替出现，但Thread0和Thread1不会交替出现。因为对非静态方法加锁，实际上是对调用该方法的对象加锁。Thread0和Thread1用的是同一个对象，所以互斥，但是Thread2则不受影响。 修饰静态方法 class Demo { static int i; Demo(int i) { Demo.i = i; } public static synchronized void staticGetI(String s) { for (int j = 0; j // 静态方法结果 ... 2---------thread0 2---------thread0 2---------thread2 2---------thread2 2---------thread1 2---------thread1 ... 三个线程均互斥。当synchronized修饰一个static方法时，多线程下，获取的是类锁(即Class本身，注意：不是实例)，作用范围是整个静态方法，作用的对象是这个类的所有对象。 一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法 public void run() { if (Thread.currentThread().getName().equals(\"thread0\")){ demo.staticGetI(Thread.currentThread().getName()); }else if (Thread.currentThread().getName().equals(\"thread1\")){ demo.getI(Thread.currentThread().getName()); } } 不会产生互斥。因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。 悲观锁和乐观锁的区别？ 悲观锁 乐观锁 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁(共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程)。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 能聊聊你对CAS的理解以及它的底层原理吗？ 内存值V，预期值A，要更新的新值B t1和t2线程都同时去访问同一变量V=56，所以他们会把主内存的值V完全拷贝一份到自己的工作内存空间，所以t1和t2线程的预期值都为V=56。假设t1在与t2线程竞争中线程t1能去更新变量的值，而其他线程都失败(失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次发起尝试)。t1线程去更新变量值改为B=57，然后写到内存中。此时对于t2来说，内存值变为了57，与预期值56不一致，就操作失败了(想改的值不再是原来的值)。 就是指当两者进行比较时，如果相等，则证明共享数据没有被修改，替换成新值，然后继续往下运行；如果不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作。容易看出CAS操作是基于共享数据不会被修改的假设，采用了类似于数据库的commit-retry的模式。当同步冲突出现的机会很少时，这种假设能带来较大的性能提升。 你对JDK的AQS理解吗？AQS的实现原理是什么？ 👉 深入分析AQS实现原理 谈谈你对Java内存模型的理解？ 为了解决缓存一致性和cpu指令重排序的问题，同时屏蔽不同机器下CPU架构不一致的问题，于是java就定义了一种协议，这个协议就是Java内存模型(JMM)。 八大原子操作 解释 lock(锁定) 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 read(读取) 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load(载入) 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use(使用) 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign(赋值) 作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store(存储) 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write(写入) 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。 unlock(解锁) 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 同时Java内存模型还规定了在执行上述八种原子操作时必须满足如下规则: 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)。 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写都是具备原子性的(例外就是long和double的非原子性协定)。 👉 深入理解Java内存模型 👉 一文看懂Java内存模型（JMM） "},"pages/java/JVM.html":{"url":"pages/java/JVM.html","title":"虚拟机","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 简单讲一下java的跨平台原理？ JDK、JRE和JVM三者之间的关系吗？ 在Java中，有哪些对象可以被垃圾回收？ 方法区中的数据什么时候被回收？ 内存泄露和内存溢出的区别？ Java类加载机制？ Java代码执行顺序？ Java虚拟机的运行时数据区有几块？线程私有和线程共享区域有哪些？ JVM是如何运行起来的？对象是如何分配的？ 说说JVM的年轻代和老年代？它们各自使用了什么垃圾收集算法？ Java对象如何从年轻代转移到老年代？ Java的双亲委派机制？ JVM中哪些类可以作为GCRoot对象？ G1回收器何时回收垃圾？ 为什么线程崩溃崩溃不会导致JVM崩溃？ 虚拟机 简单讲一下java的跨平台原理？ 由于各操作系统(windows、linux等)支持的指令集，不是完全一致的。就会让我们的程序在不同的操作系统上要执行不同程序代码。Java开发了适用于不同操作系统及位数的Java虚拟机来屏蔽个系统之间的差异，提供统一的接口。对于我们java开发者而言，你只需要在不同的系统上安装对应的不同java虚拟机，这时你的java程序只要遵循java规范，就可以在所有的操作系统上面运行java程序了。Java通过不同的系统、不同版本、不同位数的Java虚拟机(jvm)，来屏蔽不同的系统指令集差异而对外体统统一的接口(java API)，对于我们普通的java开发者而言，只需要按照接口开发即可。如果我系统需要部署到不同的环境时，只需在系统上面按照对应版本的虚拟机即可。 JDK、JRE和JVM三者之间的关系吗？ 名称 解释 JDK(Java Development Kit) 整个JAVA的核心，包括了Java运行环境JRE(Java Runtime Environment)、一堆Java工具(javac/java/jdb等)和Java基础的类库(即Java API 包括rt.jar)。 JRE(Java Runtime Environment) 运行基于Java语言编写的程序所不可缺少的运行环境。 JVM(Java Virtual Machine) Java虚拟机，它是整个Java实现跨平台的最核心的部分。 在Java中，有哪些对象可以被垃圾回收？ 对象没有引用(obj=null)。思考：如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 答：不会，在下一个垃圾回收周期中，这个对象才会被被回收。 作用域发生未捕获异常。 程序在作用域正常执行完毕。 程序执行了System.exit()。 程序发生意外终止(被杀进程等)。 JVM的内存其实是有限制的，不可能是无限的，昂贵的资源，2核4G的机器，堆内存也就2GB左右，4核8G的机器，堆内存可能也就4G左右，栈内存也需要空间，metaspace区域放类信息也需要空间。在jvm里必然是有一个内存分代模型，年轻代和老年代。给年轻代一共是2GB内存，给老年代是2GB内存，默认情况下eden和2个s的比例：8:1:1，eden是1.6GB，S是0.2GB。如果说eden区域满了，此时必然触发垃圾回收，young gc(ygc)，没有人引用的对象就是垃圾对象。 方法区中的数据什么时候被回收？ 同时满足以下3个条件: 类的所有实例都已经被回收。 加载类的ClassLoader已经被回收。 类对象的Class对象没有被引用。(即没有通过反射引用该类的地方。) 内存泄露和内存溢出的区别？ 定义 解释 内存泄露 应用程序在申请内存后，无法释放已经申请的内存空间。一次内存泄露危害可以忽略，但如果任其发展最终会导致内存溢出(out of memory)。如读取文件后流要进行及时的关闭以及对数据库连接的释放。 内存溢出 指应用程序在申请内存时，没有足够的内存空间供其使用。如我们在项目中对于大批量数据的导入，采用分段批量提交的方式。 Java类加载机制？ 👉 Java类加载机制 👉 HotSpot虚拟机对象探秘（六） Java代码执行顺序？ 父类静态代码块 -> 子类静态代码块 -> 父类构造代码块 -> 父类构造函数 -> 子类构造代码块 -> 子类构造函数。 简单来说就是先执行静态代码块，再执行父类的构造代码块和构造函数，最后执行子类的构造代码块和构造函数。 Java虚拟机的运行时数据区有几块？线程私有和线程共享区域有哪些？ 区域 私有/公有 解释 程序计数器 私有 当前线程执行的字节码的行号指示器。 Java虚拟机栈 私有 存放基本数据类型、对象引用和returnAddress类型。 本地方法栈 私有 为虚拟机使用到的Native方法服务。 Java堆 公有 存放对象的实例，也是GC回收器管理的主要区域。 方法区 公有 存放已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 运行时常量池 ———— 方法区的一部分，存放编译期生成的各种字面量和符号引用。 直接内存 ———— 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，容易引起OOM异常，NIO会调用，不受Java堆大小的限制。 JVM是如何运行起来的？对象是如何分配的？ 有一个类里面包含了一个main方法，你去执行这个main方法，此时会启动一个jvm进程，他会默认就会有一个main线程，这个main线程就负责执行这个main方法的代码，进而创建各种对象。一般tomcat，类都会加载到jvm里去，spring容器而言都会对我们的类进行实例化成bean，有工作线程会来执行我们的bean实例对象里的方法和代码，进而也会创建其他的各种对象，实现业务逻辑。 说说JVM的年轻代和老年代？它们各自使用了什么垃圾收集算法？ 年轻代对象因为生命周期短，每次有约90%以上对象的占用空间被回收，采用复制-清除算法清理，具体过程：将新生代分为一个Eden空间和两个Survivor空间，默认Eden空间和Survivor空间的比例为8:1，对象分配到Eden和其中一个Survivor空间，回收时将存活的对象复制到另一个Survivor空间，然后将Eden空间和先前使用的Survivor空间清理。 老年代因对象生命周期较长，每次回收只有少部分对象没清理，如果使用“复制-清理”算法的话需要额外预留更多的空闲空间用于复制生存对象(例如，100M的老年代占用空间每次能回收50%，那么他需要预留50M的空间，内存使用上不经济)，所以回收时使用标记-整理算法。 Java对象如何从年轻代转移到老年代？ 躲过15次GC之后进入老年代； 动态对象年龄判断； 大对象直接进入老年代； Minor GC后的对象太多，无法放入Survivor区； 老年代空间分配担保规则； 老年代垃圾回收算法。 👉 JVM中年轻代里的对象什么情况下进入老年代？ Java的双亲委派机制？ 👉 通俗易懂的双亲委派机制 JVM中哪些类可以作为GCRoot对象？ 👉 JVM中哪些类可以作为GCRoot对象 java虚拟机栈中的引用的对象。 方法区中的类静态属性引用的对象。(一般指被static修饰的对象，加载类的时候就加载到内存中。) 方法区中的常量引用的对象。 本地方法栈中的JNI(native方法)引用的对象。 G1回收器何时回收垃圾？ 👉 【原创】面试官问我G1回收器怎么知道你是什么时候的垃圾？ 为什么线程崩溃崩溃不会导致JVM崩溃？ 发生stackoverflow还有空指针错误，确实都发送了SIGSEGV，只是虚拟机不选择退出，而是自己内部作了额外的处理，其实是恢复了线程的执行，并抛出StackoverflowError和NPE，这就是为什么JVM不会崩溃且我们能捕获这两个错误/异常的原因。 如果针对SIGSEGV等信号，在以上的函数中JVM没有做额外的处理，那么最终会走到report_and_die这个方法，这个方法主要做的事情是生成hs_err_pid_xxx.log crash文件(记录了一些堆栈信息或错误)，然后退出。 虚拟机内部定义了信号处理函数，而在信号处理函数中对这两者做了额外的处理以让JVM不崩溃，另一方面也可以看出如果JVM不对信号做额外的处理，最后会自己退出并产生crash文件hs_err_pid_xxx.log(可以通过-XX:ErrorFile=/var/log/hs_err.log这样的方式指定)，这个文件记录了虚拟机崩溃的重要原因，所以也可以说，虚拟机是否崩溃只要看它是否会产生此崩溃日志文件。 "},"pages/DesignPatterns.html":{"url":"pages/DesignPatterns.html","title":"设计模式","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 23种设计模式简介？ 设计模式的六大原则？ 单例模式的优缺点及其实现的方式？ 动态代理的实现方式？ 设计模式 23种设计模式简介？ 类型 名称 意图 适用性 创建型 Factory Method(工厂方法) 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。 当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 Abstract Factory(抽象工厂) 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 一个系统要独立于它的产品的创建、组合和表示时；一个系统要由多个产品系列中的一个来配置时；当你要强调一系列相关的产品对象的设计以便进行联合使用时；当你提供一个产品类库，而只想显示它们的接口而不是实现时。 Builder(建造者) 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时；当构造过程必须允许被构造的对象有不同的表示时。 Prototype(原型) 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 当要实例化的类是在运行时刻指定时，例如通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时；或者当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。 Singleton(单例) 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 结构型 Adapter Class/Object(适配器) 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 你想使用一个已经存在的类，而它的接口不符合你的需求；你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作；(仅适用于对象Adapter)你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 Bridge(桥接) 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。 Composite(组合) 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 你想表示对象的部分-整体层次结构；你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 Decorator(装饰) 动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责，处理那些可以撤消的职责。当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 Facade(外观) 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。 Flyweight(享元) 运用共享技术有效地支持大量细粒度的对象。 一个应用程序使用了大量的对象；完全由于使用大量的对象，造成很大的存储开销；对象的大多数状态都可变为外部状态；如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象；应用程序不依赖于对象标识；由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。 Proxy(代理) 为其他对象提供一种代理以控制对这个对象的访问。 在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。 行为型 Interpreter(解释器) 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。 Template Method(模板方法) 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 Chain of Responsibility(责任链) 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定；你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可处理一个请求的对象集合应被动态指定。 Command(命令) 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 抽象出待执行的动作以参数化某对象，你可用过程语言中的回调(call back)函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。 Iterator(迭代器) 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 访问一个聚合对象的内容而无需暴露它的内部表示；支持对聚合对象的多种遍历；为遍历不同的聚合结构提供一个统一的接口(即支持多态迭代)。 Mediator(中介者) 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解；一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象；想定制一个分布在多个类中的行为，而又不想生成太多的子类。 Memento(备忘录) 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态；如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。 Observer(观察者) 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变；当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 State(状态) 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为；一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 Strategy(策略) 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。 Visitor(访问者) 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 设计模式的六大原则？ 👉 设计模式六大原则 单一职责原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 单例模式的优缺点及其实现的方式？ 优点 缺点 由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了。 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 由于单例模式只生成一个实例，所以，减少系统的性能开销，当一个对象产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 单例对象如果持有Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的Context最好是Application Context。 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 ———— 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。 ———— 饿汉式 public class Singleton { private Singleton() {}; private static Singleton single = new Singleton(); public static Singleton getInstance() { return single; } } 懒汉式 public class Singleton { private Singleton() {} private static Singleton single=null; public tatic Singleton getInstance() { if (single == null) { single = new Singleton(); } return single; } } 线程安全 public class Singleton { private Singleton() {} private static Singleton single; public static Singleton getInstance() { if(null == single){ synchronized(single){ if(null == single){ single = new Singleton(); } } } return single; } } 动态代理的实现方式？ 基于JDK的动态代理 public interface IJdkSubject { void jdkProxyMethod(String param); } public class JdkSubjectImpl implements IJdkSubject { @Override public void jdkProxyMethod(String param) { System.out.println(\"JDK Proxy \" + param); } } public class JdkSubjectProxy implements InvocationHandler { private IJdkSubject iJdkSubject; public JdkSubjectProxy(IJdkSubject jdkSubject) { this.iJdkSubject = jdkSubject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"--------------begin--------------\"); // invoke => 方法的返回值；如果没有，返回null Object invoke = method.invoke(iJdkSubject, args); System.out.println(\"--------------end--------------\"); return invoke; } } public class JdkProxyMain { public static void main(String[] args) { IJdkSubject iJdkSubject = new JdkSubjectImpl(); InvocationHandler jdkSubjectProxy = new JdkSubjectProxy(iJdkSubject); // jdkSubjectProxy.getClass().getClassLoader() => 代理类的类加载器 // iJdkSubject.getClass().getInterfaces() => 被代理类的接口，如果有多个就是数组的形式传入 // jdkSubjectProxy => 代理类实例 IJdkSubject proxyInstance = (IJdkSubject) Proxy.newProxyInstance(jdkSubjectProxy.getClass().getClassLoader(), iJdkSubject.getClass().getInterfaces(), jdkSubjectProxy); proxyInstance.jdkProxyMethod(\"success\"); } } // 运行结果 --------------begin-------------- JDK Proxy success --------------end-------------- 基于CGLIB的动态代理 public class CglibSubject { public void cglibProxyMethod() { System.out.println(\"cglib Proxy success\"); } } public class CglibInterceptor implements MethodInterceptor { @Override public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\"--------------begin--------------\"); // MethodProxy => 代理方法 // object => 被代理对象的实例 // invokeSuper => 调用被拦截的方法，不要使用invoke，会出现OOM的情况 Object obj = methodProxy.invokeSuper(object, objects); System.out.println(\"--------------end--------------\"); return obj; } } public class CglibProxyMain { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(CglibSubject.class); enhancer.setCallback(new CglibInterceptor()); CglibSubject cglibSubject = (CglibSubject) enhancer.create(); cglibSubject.cglibProxyMethod(); } } // 运行结果 --------------begin-------------- cglib Proxy success --------------end-------------- "},"pages/Network.html":{"url":"pages/Network.html","title":"网络","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 HTTP支持的请求方法？响应状态返回值的含义？ HTTP 502和504有何异同？ 浏览器发生301/302跳转背后的逻辑以及它们的区别？什么是重定向限制？ HTTP响应的结构是怎么样的？ 你知道HTTP和TCP的区别吗？ 什么是cookie？session和cookie有什么区别？ GET提交方式与POST提交方式的区别？ 客户端传输的数据如何保证安全性？ 用浏览器请求一个链接的时候，经历了哪些过程？ 你知道DNS域名解析的流程吗？ 聊聊HTTP协议的工作原理？ 聊聊HTTPS协议的工作原理？ 你知道浏览器的同源策略吗？ 前端解决跨域的方案？ 什么是跨域？如何解决跨域问题？ 你知道TCP和UDP的区别吗？ DDos攻击及预防？ 你能聊聊TCP/IP四种网络模型吗？OSI七层网络模型也说一下？ TCP握手为啥是三次而不是二次或者四次呢？ TCP粘包/拆包的原因及解决方法？ 能聊聊BIO、NIO、AIO分别都是啥？有什么区别？ 你知道Netty的零拷贝技术吗？ 什么是ARP协议？ HTTPS是先进行TCP三次握手，再进行TLS四次握手？ SSL/TLS协议建立的详细流程？ 浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？ 一个TCP连接可以对应几个HTTP请求？ 一个TCP连接中，可以同时发送多个HTTP请求吗？ 浏览器对同一Host建立TCP连接的数量有没限制？ keep-alive使用场景及优缺点？ 网络 HTTP支持的请求方法？响应状态返回值的含义？ 方法 解释 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。 HEAD 与GET请求一致，只不过不会返回响应体。 GET 请求指定的资源。 POST 向指定资源提交数据进行处理请求，数据包含在请求体中，可能会导致新资源的创建或已有资源的修改。 PUT 向指定资源位置上传最新内容。 DELETE 请求服务器删除所标识的资源。 1xx 该类型状态码表示接收到请求并且继续处理。 100 客户端必须继续发出请求。 101 客户端要求服务器根据请求转换HTTP协议版本。 2xx 该类型状态码表示动作被成功接收、理解和接受。 200 表明该请求被成功地完成，所请求的资源发送到客户端。 201 提示知道新文件的URL。 202 接受并处理，但处理未完成。 203 返回信息不确定或不完整。 204 收到请求，但返回信息为空。 205 服务器完成了请求，用户必须复位当前已经浏览过的文件。 206 服务器已经完成了部分用户的GET请求。 3xx 该类型状态码表示为了完成指定的动作，必须接受进一步处理。 300 请求的资源可在多处获得。 301 本网页被永久性转移到另一个URL。 302 请求的网页被重定向到新的地址。 303 建议用户访问其他URL或访问方式。 304 自从上次请求后，请求的网页未修改过。 305 请求的资源必须从服务器指定的地址获得。 306 前一版本HTTP中使用的代码，现已不再使用。 307 声明请求的资源临时性删除。 4xx 该类型状态码表示请求包含错误语法或不能正确执行。 400 客户端请求有语法错误。 401 请求未经授权。 402 保留有效ChargeTo头响应。 403 禁止访问，服务器收到请求，但拒绝提供服务。 404 可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。 405 用户在Request-Line字段定义的方法不被允许。 406 根据用户发送的Accept，请求资源不可访问。 407 类似401，用户必须首先在代理服务器上取得授权。 408 客户端没有在用户指定的时间内完成请求。 409 对当前资源状态，请求不能完成。 410 服务器上不再有此资源。 411 服务器拒绝用户定义的Content-Length属性请求。 412 一个或多个请求头字段在当前请求中错误。 413 请求的资源大于服务器允许的大小。 414 请求的资源URL长于服务器允许的长度。 415 请求资源不支持请求项目格式。 416 请求中包含Range请求头字段，在当前请求资源范围内没有range指示值。 417 服务器不满足请求Expect头字段指定的期望值。 5xx 该类型状态码表示服务器或网关错误。 500 服务器错误。 501 服务器不支持请求的功能。 502 网关错误。 503 无法获得服务。 504 网关超时。 505 不支持的HTTP版本。 HTTP 502和504有何异同？ 502 bad gateway，顾名思义网关错误，后端服务器tomcat没有起来，应用服务的问题(前提是接入层7层正常的情况下)。 应用服务问题一种是应用本身问题；另一种是因为依赖服务问题比如依赖服务RT高，依赖的服务有大的读取(mysql慢查，http等)，以至于调用方超过超时read时间；服务集群压力大时，也会出现502超时(502理解为不可响应或响应不过来，其实还是不可响应)。 504 gateway time-out，顾名思义网关超时，一般计算机中的超时就是配置错了，此处一般指nginx做反向代理服务器时，所连接的服务器tomcat无响应导致的。 从网络角度，502已经与后端建立了连接，但超时；504与后端连接未建立，超时。 必现502，应用“挂了” 后端机器上检查: ps -ef |grep java 检查进程是否在。 sudo netstat -lntp |grep port 检查端口有没有起来。 curl -I 127.0.0.1:port/health 应用健康检查测试下，Your health check path。 上面都正常，看下接入层access.log有没有进来: tail -300f access.log | grep xxxx grep关键字。 curl -I 10.10.10.10:80/java_hc 上面都正常情况下，去接入层检查下。 偶现502 CPU使用率高，QPS增加。考虑有大流量，后端压力导致短暂不可用，考虑临时扩容。 检查应用本身nginx read超时时间配置。proxy_read_timeout 2s; # vim /opt/nginx/nginx.conf。如果某些正常请求耗时在2s左右，那么会有少量大于2s的请求是502的。可以试着把上面耗时时间调大，看问题是否缓解。优化本身链路请求耗时是根本上的解决办法。 检查接入层nginx read的配置。 浏览器发生301/302跳转背后的逻辑以及它们的区别？什么是重定向限制？ 301永久重定向 我们访问http://www.baidu.com会跳转到https://www.baidu.com。发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。注意301请求是可以缓存的，即通过看status code，可以发现后面写着from cache。或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。 //nginx301配置：把来自veryyoung.me的请求301跳到www.veryyoung.me if ($host != 'veryyoung.me') { rewrite ^/(.*)$ http://www.veryyoung.me/$1 permanent; } 302临时重定向 比如未登陆的用户访问用户中心重定向到登录页面，访问404页面会重新定向到首页。 //nginx302配置：把来自veryyoung.me的请求302跳到www.veryyoung.me if ($host != 'veryyoung.me') { rewrite ^/(.*)$ http://www.veryyoung.me/$1 redirect; } 重定向限制是指浏览器设置，限制你的浏览器的次数。会接受“重定向”从一个主机到另一个。例如，一个网站可能已经从一个服务器或URL移动到另一个技术或其他原因，为了更方便用户，网站所有者可以实施了一项命令，告诉浏览器自动走到另一个位置(重定向)。重定向限制错误可能发生无意中当一个web页面或页面无意中创建一个循环。例如，如果页面重定向到本身，或B页面重定向回页面，那么您的web浏览器将开始构建连接在循环的每一根琴弦，直到超过限制。 HTTP响应的结构是怎么样的？ 组成部分 解释 状态码(Status Code) 描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HTTPServletResponse.SC_OK。 HTTP头部(HTTP Header) 它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Servlet中检索HTTP的头部看这里。 主体(Body) 它包含了响应的内容。它可以包含HTML代码、图片等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。 你知道HTTP和TCP的区别吗？ HTTP TCP 1. HTTP是应用层协议，定义的是传输数据的内容的规范；2. HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP；3. HTTP支持的是www服务。 1. TCP是底层通讯协议，定义的是数据传输和连接方式的规范；2. TCP/IP是协议，它是Internet国际互联网络的基础；3. TCP/IP是网络中使用的基本的通信协议。它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。 什么是cookie？session和cookie有什么区别？ cookie是Web服务器发送给浏览器的一块信息，浏览器会在本地文件中给每一个Web服务器存储cookie，以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。 session cookie 1. 基于服务器生成；2. 数据保存在服务器端；3. 相对更安全；4. 过期时间是相对的；5. 客户端无法禁用服务端的session，无论客户端浏览器做怎么样的设置，session都应该能正常工作；6. 能够存储任意的Java对象。 1. 基于浏览器生成；2. 数据保存在客户端；3. 相对不安全；4. 过期时间是绝对的；5. 客户端可以选择禁用cookie；6. 只能存储String类型的对象。 GET提交方式与POST提交方式的区别？ GET POST 1. 在浏览器回退时是无害的；2. URL地址可以被收藏；3. 被浏览器主动缓存；4. 只能进行URL编程；5. 请求参数会被完整保留在浏览器历史里；6. 在URL中传送的参数有长度限制，不能大于2KB；7. 只接受ASCLL字符；8. 参数直接暴露在URL上，所以不能用来传递敏感信息；9. 不支持文件上传。 1. 在浏览器回退时再次请求；2. URL地址不会被收藏；3. 不会被浏览器主动缓存，除非手动设置；4. 支持多种编码方式；5. 参数不会被保留在浏览器历史里；6. 在URL中传送中参数没有长度限制；7. 字符没有限制；8. 参数放在request body中，安全；9. 支持文件上传。 客户端传输的数据如何保证安全性？ 方式 解释 特点 局限性 算法 对称加密 加密和解密使用同一个密钥。 保证了数据的保密性。 无法解决密钥交换问题。 DES、3DES、AES。 公钥加密 生成一个密钥对，加密使用私钥加密，解密使用公钥解密。 解决了密钥交换问题。 对大的数据加密速度慢。 ———— 单向加密 提取数据的特征码。 定长输出，不可逆，可检验数据的完整性。 无法保证数据的保密性。 MD5、SHA1、CRC-32。 用浏览器请求一个链接的时候，经历了哪些过程？ // 参数 ip地址：192.168.31.37 子网掩码：255.255.255.0 网关地址：192.168.31.1 DNS地址：8.8.8.8 请求www.baidu.com地址，这个时候找DNS服务器，DNS服务器解析域名之后，返回一个ip地址，比如172.194.26.108。 判断本机和访问的IP是不是同一个子网，用子网掩码坐与运算。通常不在一个子网，就发送数据包给网关，也就是路由器。通过浏览器访问网站，走应用层的http协议，把浏览器发出的请求打包为数据包。把http协议请求，有请求头、空行、请求数据，就构成http请求报文，封装到一个应用层数据包里。 接下来走到传输层，按照TCP协议，TCP协议会让你设置端口，发送方端口随机选择，接收端一般默认80端口。这时会把应用层数据包封装到TCP数据包，再加一个TCP头，TCP头放了端口信息。 走网络层，会把TCP头和TCP数据包，放到IP数据包里，再做了一个IP头，IP头包括本机和目标机器的IP地址。通过IP协议，判断两个IP不在一个子网内，则将数据包通过以太网协议广播到网关，通过网关在发生出去。 最后走到数据链路层，把IP头和IP数据包封装到以太网数据包，再增加一个以太网数据包头，头里放了本机网卡MAC地址和网关MAC地址。但以太网数据包有1500字节的限制，超过要切分为多个数据包，每个数据包包含以太网头、IP头和切割后的IP数据包。 以太网数据包通过交换机发送到网关，然后通过路由器转发到别的子网或者别的路由器。以此类推，通过N个路由器或网关转发，最终到达目标服务器，比如172.194.26.108。 目标服务器接收到以太网数据包后，从IP数据包，拿出TCP数据包，再从TCP数据包取出HTTP数据包，读取出HTTP数据包里各种协议内容，比如html页面，或者业务处理，然后再把响应结果封装成http响应报文，封装到http数据包里，再封装TCP数据包，封装IP数据包，封装以太网数据包，再通过网关发送回去，完成整个请求过程。 你知道DNS域名解析的流程吗？ 浏览器先检查自身缓存中有没有被解析过的这个域名对应的IP地址。如果有，解析结束，同时域名被缓存的时间也可通过TTL属性来设置。 如果浏览器缓存中没有，浏览器会检查操作系统缓存中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过C盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的IP地址，那浏览器会首先使用这个IP地址。但是这种操作系统级别的域名解析规程也被很多黑客利用，通过修改你的hosts文件里的内容把特定的域名解析到他指定的IP地址上，造成所谓的域名劫持。所以在windows7中将hosts文件设置成了readonly，防止被恶意篡改。 如果至此还没有命中域名，才会真正的请求本地域名服务器(LDNS)来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。 如果LDNS仍然没有命中，就直接跳到Root Server域名服务器请求解析。 根域名服务器返回给LDNS一个所查询域的主域名服务器(gTLD Server，国际顶尖域名服务器，如.com .cn .org等)地址。 此时LDNS再发送请求给上一步返回的gTLD。 接受请求的gTLD查找并返回这个域名对应的Name Server的地址，这个Name Server就是网站注册的域名服务器。 Name Server根据映射关系表找到目标IP，返回给LDNS。 LDNS缓存这个域名和对应的IP。 LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。 聊聊HTTP协议的工作原理？ 👉 聊聊Http协议 聊聊HTTPS协议的工作原理？ 👉 深入理解HTTPS工作原理 客户端向服务器发起HTTPS请求，连接到服务器的443端口。 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。 服务器将自己的公钥发送给客户端。 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 然后服务器将加密后的密文发送给客户端。 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。 你知道浏览器的同源策略吗？ URL 解释 是否允许通信 HTTP://www.a.com/a.js HTTP://www.a.com/b.js 同一域名下 √ HTTP://www.a.com/lab/a.js HTTP://www.a.com/script/b.js 同一域名下不同文件夹 √ HTTP://www.a.com:8000/a.js HTTP://www.a.com/b.js 同一域名，不同端口 × HTTP://www.a.com/a.js HTTPs://www.a.com/b.js 同一域名，不同协议 × HTTP://www.a.com/a.js HTTP://70.32.92.74/b.js 域名和域名对应ip × HTTP://www.a.com/a.js HTTP://script.a.com/b.js 主域相同，子域不同 × HTTP://www.a.com/a.js HTTP://a.com/b.js 同一域名，不同二级域名 × HTTP://www.cnblogs.com/a.js HTTP://www.a.com/b.js 不同域名 × 如果是协议和端口造成的跨域问题“前台”是无能为力的。 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 URL的首部指window.location.protocol + window.location.host，也可以理解为“Domains, protocols and ports must match”。 前端解决跨域的方案？ 👉 浏览器拦截跨域请求处理方法 CORS 它允许浏览器向跨源服务器，发出XMLHTTPRequest请求，从而克服了AJAX只能同源使用的限制。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 // IE浏览器 var xdr = new XDomainRequest(); xdr.onload = function(){ console.log(xdr.responseText); } xdr.open('get', 'HTTP://www.baidu.com'); ... xdr.send(null); // 其它浏览器 var xhr = new XMLHTTPRequest(); xhr.onreadystatechange = function () { if(xhr.readyState == 4){ if(xhr.status >= 200 && xhr.status // 实现跨浏览器的CORS function createCORS(method, url){ var xhr = new XMLHTTPRequest(); if('withCredentials' in xhr){ xhr.open(method, url, true); }else if(typeof XDomainRequest != 'undefined'){ var xhr = new XDomainRequest(); xhr.open(method, url); }else{ xhr = null; } return xhr; } var request = createCORS('get', 'HTTP://www.baidu.com'); if(request){ request.onload = function(){ ... }; request.send(); } 什么是跨域？如何解决跨域问题？ 👉 什么是跨域？如何解决跨域问题？ 你知道TCP和UDP的区别吗？ 👉 TCP和UDP的9个区别是什么 TCP UDP 1. 面向连接；2. 可靠；3. 有序；4. 不保存数据的边界；5. 速度比较慢；6. 重量级；7. 数据包报头的大小是20字节；8. 流量控制；9. 金融领域。 1. 无连接；2. 不可靠；3. 不提供序列性保证；4. 保存数据的边界；5. 速度比较快；6. 轻量级；7. 数据包报头是8个字节；8. 不能进行流量控制；9. 游戏和娱乐场所。 DDos攻击及预防？ 👉 DDoS的攻击原理与防御方法 确保服务器的系统文件是最新的版本，并及时更新系统补丁。 关闭不必要的服务。 限制同时打开的SYN半连接数目，缩短SYN半连接的time out时间，限制SYN/ICMP流量。 正确设置防火墙。 认真检查网络设备和主机/服务器系统的日志，只要日志出现漏洞或是时间变更，那这台机器就可能遭到了攻击。 限制在防火墙外与网络文件共享，这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。 充分利用网络设备保护网络资源。 用足够的机器承受黑客攻击。 检查访问者的来源。 你能聊聊TCP/IP四种网络模型吗？OSI七层网络模型也说一下？ TCP/IP四种网络模型 TCP/IP名称 协议类型 应用层(Application Layer) HTTP协议 传输层(Transport Layer-TCP/UDP) TCP协议 网络层(Internet Layer) IP协议 数据链路层 以太网协议 OSI七层网络模型 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP握手为啥是三次而不是二次或者四次呢？ 建立三次握手的时候，TCP报头用到了下面几个东西，ACK、SYN、FIN。第一次握手，客户端发送连接请求报文，此时SYN=1、ACK=0，这就是说这是个连接请求，seq=x，接着客户端处于SYN_SENT状态，等待服务器响应。第二次握手，服务端收到SYN=1的请求报文，需要返回一个确认报文，ack=x+1，SYN=1，ACK=1，seq=y，发送给客户端，自己处于SYN_RECV状态。第三次握手，客户端收到了报文，将ack=y+1，ACK=1，seq=x+1。 假设两次握手就ok了。要是客户端第一次握手过去，结果卡在某个地方了，没到服务端；完了客户端再次重试发送了第一次握手过去，服务端收到了，ok了，大家来回来去，三次握手建立了连接。结果，尴尬的是，后来那个卡在哪儿的老的第一次握手发到了服务器，服务器直接就返回一个第二次握手，这个时候服务器开辟了资源准备客户端发送数据啥的，结果呢？客户端根本就不会理睬这个发回去的二次握手，因为之前都通信过了。但是如果是三次握手，那个二次握手发回去，客户端发现根本不对，就会发送个复位的报文过去，让服务器撤销开辟的资源，别等着了。 如果四次挥手的话。第一次挥手，客户端发送报文，FIN=1，seq=u，此时进入FIN-WAIT-1状态。第二次挥手，服务端收到报文，这时候进入CLOSE_WAIT状态，返回一个报文，ACK=1，ack=u+1，seq=v。客户端收到这个报文之后，直接进入FIN-WAIT-2状态，此时客户端到服务端的连接就释放了。第三次挥手，服务端发送连接释放报文，FIN=1，ack=u+1，seq=w，服务端进入LAST-ACK状态。第四次挥手，客户端收到连接释放报文之后，发应答报文，ACK=1，ack=w+1，seq=u+1，进入TIME_WAIT状态，等待一会儿客户端进入CLOSED状态，服务端收到报文之后就进入CLOSED状态。 TCP粘包/拆包的原因及解决方法？ ———— 拆包 粘包 原因 应用程序写入数据大于TCP缓冲区剩余空间大小。 应用程序写入数据小于TCP缓冲区大小，TCP将多次写入缓冲区的数据一次发送出去。 应用程序写入数据大于MSS(最大报文长度)，会发生拆包现象。 接收数据端的应用层没有及时读取接收缓冲区中的数据。 解决办法 1. 消息定长(FixedLengthFrameDecoder类)：发送端将每个数据包封装为固定长度(不够的可以通过补0填充)，这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来； 2. 将消息分为消息头和消息体(LengthFieldBasedFrameDecoder类)：发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了； 3. 包尾增加特殊字符分割：行分隔符类LineBasedFrameDecoder或自定义分隔符类DelimiterBasedFrameDecoder。 能聊聊BIO、NIO、AIO分别都是啥？有什么区别？ BIO：同步阻塞式IO。 服务端创建一个ServerSocket，客户端用一个Socket去连接那个ServerSocket，然后ServerSocket接收到Socket连接请求就创建一个Socket和一个线程去和客户端Socket通信。 客户端socket发送一个请求，服务端socket进行处理后返回响应，响应必须是等处理完成之后才能返回，这期间不能做其他事，只能等待(卡住)。而且每一个客户端接入，服务端就需要创建一个线程来服务，会导致客户端大量增加时，服务端线程会负责过高(可能几千几万个线程)，最后服务端崩溃。可以用线程池固定线程来处理客户端请求，但是高并发时会导致大量排队和延时。 NIO：同步非阻塞IO，基于Reactor模型。 Channel表示为一个已经建立好的支持I/O操作的实体(如文件和网络)的连接，在此连接上进行数据的读写操作，使用的是缓冲区来实现读写。Buffer在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储。好处：1. 减少实际的物理读写次数 2. 缓冲区在创建时就被分配内存，这块内存区域一直被重用，可以减少动态分配和回收内存的次数。好比从A工地搬1w块砖到B工地，路途远(IO性能消耗大)，没有工具时(缓冲区)，一次搬1块，要搬1w次(IO读写1w次)。用卡车(缓冲区)，一次运送5K块，2次就运完了，性能大大提高了。Selector会不断轮询注册的channel，如果某个channel上发生了读写事件，selector就会将这些channel获取出来，我们通过SelectionKey获取有读写事件的channel，就可以进行IO操作。一个Selector就通过一个线程，就可以轮询成千上万的channel，这就意味着你的服务端可以接入成千上万的客户端。 核心就是非阻塞，selector一个线程可以不停轮询channel，所有客户端都不会阻塞，最多排队。只有某个客户端发送了一个请求，才会启动一个线程来处理。客户端接入不会耗费一个线程，只会创建一个channel连接，然后注册到selector上，一个selector线程不断轮询所有的socket连接(channel)，发现有事件就通知，启动工作线程处理一个请求。工作线程从channel-buffer读数据，如果数据没有读完卡住，等待。然后处理后往buffer-channel里写数据，也是自己做，写数据时数据没有写完，也卡住等待，是同步的。 AIO：基于Proactor模型的，就是异步非阻塞模型。 每个请求会绑定一个buffer，通知操作系统去异步完成读写，此时工作线程可以做别的事情(异步)，等操作系统完成之后回调接口，把操作系统完成的数据给工作线程。 你知道Netty的零拷贝技术吗？ 👉 netty深入理解系列-Netty零拷贝的实现原理 什么是ARP协议？ 👉 计网---ARP协议 HTTPS是先进行TCP三次握手，再进行TLS四次握手？ HTTPS是先进行TCP三次握手，再进行TLSv1.2四次握手。 HTTPS中的TLS握手过程可以同时进行三次握手，这个场景是可能存在。但是在没有说任何前提条件，而说这句话就等于耍流氓。需要下面这两个条件同时满足才可以: 客户端和服务端都开启了TCP Fast Open功能，且TLS版本是1.3； 客户端和服务端已经完成过一次通信。 👉 给面试官上一课：HTTPS是先进行TCP三次握手，再进行TLS四次握手 SSL/TLS协议建立的详细流程？ ClientHello。首先，由客户端向服务器发起加密通信请求，也就是ClientHello请求。在这⼀步，客户端主要向服务器发送以下信息: 客户端支持的SSL/TLS协议版本，如TLS 1.2版本。 客户端生产的随机数(Client Random)，后面用于生产会话秘钥。 客户端支持的密码套件列表，如RSA加密算法。 SeverHello。服务器收到客户端请求后，向客户端发出响应，也就是SeverHello。服务器回应的内容有如下内容: 确认SSL/TLS协议版本，如果浏览器不支持，则关闭加密通信。 服务器生产的随机数(Server Random)，后面用于生产会话秘钥。 确认的密码套件列表，如RSA加密算法。 服务器的数字证书。 客户端回应。客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的CA公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报文，向服务器发送如下信息: ⼀个随机数(pre-master key)。该随机数会被服务器公钥加密。 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。 客户端握手结束通知，表示客户端的握手阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。上面第⼀项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的会话秘钥。 服务器的最后回应。服务器收到客户端的第三个随机数(pre-master key)之后，通过协商的加密算法，计算出本次通信的会话秘钥。然后，向客户端发送最后的信息: 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。 服务器握手结束通知，表示服务器的握手阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。 至此，整个SSL/TLS的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全使用普通的HTTP协议，只不过用会话秘钥加密内容。 浏览器建立TCP连接之后，完成一次HTTP请求，是否会断开？ HTTP协议Header中的Connection属性决定了连接是否持久，不同HTTP协议版本有所不同。 HTTP/1.0中Connection默认为close，即每次请求都会重新建立和断开TCP连接。缺点是建立和断开TCP连接，代价过大。 HTTP/1.1中Connection默认为keep-alive，即连接可以复用，不用每次都重新建立和断开TCP连接。超时之后没有连接则主动断开。可以通过声明Connection为close进行关闭。优点是TCP连接可被重复利用，减少建立连接的损耗，SSL的开销也可以避免。刷新页面时也可以复用，从而不再建立SSL连接等。 默认情况下(HTTP/1.1)建立TCP连接不会断开，只有在请求报头中声明Connection: close才会请求完成之后关闭连接。不断开的最终目的是减少建立连接所导致的性能损耗。 一个TCP连接可以对应几个HTTP请求？ 如果Connection: close，则一个TCP连接只对应一个HTTP请求。 如果Connection: Keep-alive，则一个TCP连接可对应一个到多个HTTP请求。 一个TCP连接中，可以同时发送多个HTTP请求吗？ TTP/1.1中单个TCP连接在同一时刻只能处理一个请求。HTTP/1.1在RFC 2616中规定了Pipelining来解决这个问题，但浏览器默认是关闭的。 RFC 2616中规定一个支持持久连接的客户端可以在一个连接中发送多个请求(不需要等待任意请求的响应)。收到请求的服务器必须按照请求收到的顺序发送响应。 Pipelining本身存在一些问题，比如代理服务器不能正确处理HTTP Pipelining、Head-of-line Blocking连接头阻塞(首个请求耗时过长，阻塞其他请求)。所以浏览器默认关闭该功能。 HTTP/2.0提供了多路复用技术Multiplexing，一个TCP可以并发多个HTTP请求(理论无上限，但是一般浏览器会有TCP并发数的限制)。 HTTP/1.1中为了提升性能，通常会采用连接复用和同时建立多个TCP连接的方式提升性能。 HTTP/1.1中存在Pipelining技术支持一个连接发送多个请求，但存在弊端，浏览器默认关闭。HTTP/2.0中通过多路复用技术支持一个TCP连接中并发请求HTTP。 浏览器对同一Host建立TCP连接的数量有没限制？ 不同浏览器限制不同，比如Chrome最多允许同一个Host可建立6个TCP连接。 如果服务器只支持HTTP/1.1，浏览器会采用在同一个Host下建立多个TCP连接来进行效率提升。如果是基于HTTPS传输，在SSL握手之后，还会尝试协商是否可以采用HTTP/2.0的Multiplexing功能。 keep-alive使用场景及优缺点？ 开启keep-alive对内存要求高，关闭keep-alive对CPU要求高；如果内存和CPU都足够，开启和关闭keep-alive对性能影响不大；如果考虑服务器压力，如果是静态页面，大量的调用js或者图片的话，建议开启keep-alive；如果是动态网页，建议关闭keep-alive。 注意事项: 如果需要使用keep-alive功能，服务器端如果使用nginx中keepalive_timeout值要大于0。 "},"pages/Database.html":{"url":"pages/Database.html","title":"数据库","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 能说下MyiSAM和InnoDB的区别吗？ 数据库集群会产生哪些问题？ Mysql如何实现读写分离？ 数据库性能优化？ 数据库事务的特性？ 数据库的隔离级别？ Mysql常有的索引有哪些？它们的区别是什么？ Mysql索引使用规则？索引查询失效的情况？索引缺点以及使用注意？ 常用SQL语句的优化？ left join、inner join和right join的区别？ Mysql主从复制的原理？ 说说Mysql主从同步怎么做的吧？ Mysql的MyISAM和InnoDB存储引擎的区别是啥？ union和union all区别？ SQL注入？ drop、truncate和delete的区别？ count(*)和count(字段)的区别？ 查询一个表中某个数据重复条数大于1的所有信息？ 谈谈你对Mysql的MVCC的理解？ (a, b, c)联合索引，只查询b会用到索引吗？ 什么是最左匹配原则？ 数据库 能说下MyiSAM和InnoDB的区别吗？ MyiSAM MyiSAM引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且MyiSAM不支持外键，并且索引和数据是分开存储的。 存储名称 解释 .frm 与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。 .myd myisam存储引擎专用，用于存储myisam表的数据。 .myi myisam存储引擎专用，用于存储myisam表的索引相关信息。 InnoDB InnoDB是基于聚簇索引建立的，和MyiSAM相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。 存储名称 解释 .frm 与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。 .ibd或者.ibdata 1. 这两种文件都是存放innodb数据的文件，之所以用两种文件来存放innodb的数据，是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。  i. 独享表空间存储方式使用.ibd文件，并且每个表一个ibd文件。  ii. 共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件。2. 使用哪种方式的参数在mysql的配置文件中innodb_file_per_table。 数据库集群会产生哪些问题？ 自增id问题。 数据关联查询问题(水平拆分)。 数据同步问题。 数据库集群下自增id问题的解决？ UUID(不推荐, 不能建索引)； 设置id步长(缺点：需要在设计数据库时需要确定库的数量，才能定好步长间隔)； 雪花算法(sharding-jdbc使用雪花算法)或Redis。 Mysql如何实现读写分离？ 方式 原理 Mycat Mycat原理MyCAT主要是通过对SQL的拦截，然后经过一定规则的分片解析、路由分析、读写分离分析、缓存分析等，然后将SQL发给后端真实的数据块，并将返回的结果做适当处理返回给客户端。特点：第三方客户端，反向代理。 SpringBoot动态切换数据源 动态切换数据源，根据配置的文件，业务动态切换访问的数据库。此方案通过Spring的AOP、AspactJ来实现动态织入，通过编程继承实现Spring中的AbstractRoutingDataSource，来实现数据库访问的动态切换，不仅可以方便扩展，不影响现有程序，而且对于此功能的增删也比较容易。 在Spring 2.0+中引入了AbstractRoutingDataSource, 该类充当了DataSource的路由中介。能有在运行时, 根据某种key值来动态切换到真正的DataSource上。 项目中需要集成多个数据源分别为读和写的数据源，绑定不同的key； 采用AOP技术进行拦截业务逻辑层方法，判断方法的前缀是否需要写或者读的操作； 如果方法的前缀是写的操作的时候直接切换为写的数据源，反之切换为读的数据源也可以自己定义注解进行封装。 数据库性能优化？ 添加适当的索引，索引对查询速度影响很大，必须添加索引。主键索引、唯一索引、普通索引、全文索引。 对sql语句的一些优化(查询执行速度比较慢的sql语句)。 读写分离(主从数据库)。 分表分区(分表把一张大表分成多张表；分区把一张表里面的分配到不同的区域存储)。 对mysql服务器硬件的升级操作。 数据库事务的特性？ 事务特性 解释 可靠性保证 原子性(Atomicity) 原子性指的是事务中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行，这种特性称为原子性。 由undo log保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql。 一致性(Consistency) 一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态(中途是否一致不用管)，这种特性称为一致性。 一般由代码层面来保证。 隔离性(Isolation) 隔离性指的是并发的事务是相互隔离的。多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 由MVCC来保证。 持久性(Durability) 持久性指当系统或介质发生故障时，确保已提交的更新不能丢失。 由内存 + redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复。 数据库的隔离级别？ 隔离原因 解释 脏读 一个事务读取到了另一个事务未提交的数据操作结果，可能造成所有数据一起回滚。 不可重复读(修改) 事务T1读取某一数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 幻读(新增或者删除) 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据(并不要求两次查询的SQL语句相同)。这是因为在两次查询过程中有另外一个事务插入数据造成的。 隔离级别 解释 READ UNCOMMITED(读未提交) 事务A把id=1，name=张三修改为李四，但是还未提交，这时事务B已经看到id=1的name为李四了。 READ COMMITED(读提交) 事务A把id=1, name=张三修改为李四，但是还未提交。事务B第一次读，读到是张三，看不见李四。紧接着事务A提交了事务，事务A在第二次读的时候，读到的是修改后的李四。这个也叫不可重复读，就是所谓一个事务内对一个数据的两次读，可能读到不一样的值。 REPEATABLE READ(可重复读) 无论事务A什么时候把张三修改为李四，事务B不管什么时刻读到值，都是事务B刚开启时读到的值。事务开启后对一行读取的值都是一样的。 SERIALIZABLE(串行化) 事务A运行期间，事务Ｂ不允许运行。事务Ａ提交完事务后，事务Ｂ才开始运行。串行化是为了解决幻读。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITED(读未提交) √ √ √ READ COMMITED(读提交) × √ √ REPEATABLE READ(可重复读) × × √ SERIALIZABLE(串行化) × × × 默认隔离级别REPEATABLE READ(可重复读)。 Mysql常有的索引有哪些？它们的区别是什么？ Hash索引、B+树索引 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据。 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索。 同理，哈希索引也没办法利用索引完成排序，以及like 'xxx%'这样的部分模糊查询(这种部分模糊查询，其实本质上也是范围查询)。 哈希索引也不支持多列联合索引的最左匹配规则。 B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 什么是B+树 中间元素不存数据，只是当索引用，所有数据都保存在叶子结点中。 所有的中间节点在子节点中要么是最大的元素要么是最小的元素。 叶子结点包含所有的数据，和指向这些元素的指针，而且叶子结点的元素形成了自小向大这样子的链表。 Mysql索引使用规则？索引查询失效的情况？索引缺点以及使用注意？ // product表 create index (shop_id, product_id, gmt_create); 使用规则 名称 解释 全列匹配 where条件正好用到这3个字段，就用到联合索引。 最左前缀匹配 SQL里，正好用到联合索引最左边的一个或几个列表。 最左前缀匹配，但中间某个值没有匹配 如果sql用了联合索引第一列和第三列，会按照第一列在索引里找，找完后对结果集根据第三列做全表扫描，不会走第三列的索引了。 前缀匹配 如果不是等值，或比如=, >, 范围匹配 只有符号最左前缀的列的范围才用到索引，范围之后的列用不到索引。比如: select * from product where shop_id >= 1 and product_id = 1；这里就只用到shop_id索引。 包含函数 对某个列用了函数，则该列不走索引。 失效情况 like以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效。 or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效。 组合索引，不是使用第一列索引，索引失效。 数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。优化方法：key<>0 改为 key>0 or key 对索引字段进行计算操作、字段上使用函数。 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。 缺点 增加磁盘消耗，占用磁盘文件，同时高并发频繁插入和修改索引，会导致性能损耗。 使用注意 尽量创建少的索引，一个表，2至3个。 一个字段的值几乎都不太一样的，比如id，这样用索引效果最好。 互联网系统中，一般尽量降低SQL复杂度，用简单的主键索引(聚簇索引)+少数联合索引，可以覆盖一个表的所有SQL查询，更复杂的业务逻辑，应该放在Java代码里实现。SQL越简单，后面迁移，分库分表，读写分离的成本更低，减少对SQL的改造。MySQL最好用在在线及时存储，不要用于计算(Join, 子查询，函数等等)。高并发场景下，计算放在Java内存里。 常用SQL语句的优化？ SELECT子句中避免使用 *，尽量应该根据业务需求按字段进行查询。 尽量多使用COMMIT，如对大数据量的分段批量提交释放了资源，减轻了服务器压力。 用UNION-ALL替换UNION，因为UNION-ALL不会过滤重复数据，所执行效率要快于UNION，并且UNION可以自动排序，而UNION-ALL不会。 避免在索引列上使用计算和函数，这样索引就不能使用。 用 >= 替换 >。 用 NOT EXISTS 或 (外连接+判断为空) 方案替换 NOT IN 操作符。 LIKE操作符。 left join、inner join和right join的区别？ 名称 解释 left join 返回包括左表中的所有记录和右表中联结字段相等的记录。 inner join 返回包括右表中的所有记录和左表中联结字段相等的记录。 right join 只返回两个表中联结字段相等的行。 left join select user.id as user_id, user.user_name, class.id as class_id, class.class_name from user left join class on user.id = class.id right join select user.id as user_id, user.user_name, class.id as class_id, class.class_name from user right join class on user.id = class.id inner join select user.id as user_id, user.user_name, class.id as class_id, class.class_name from user inner join class on user.id = class.id Mysql主从复制的原理？ master在每个事务更新数据完成之前，将该操作记录串行地写入到bin log文件中。 slave开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是bin log dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志(relay log)中。 SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。 说说Mysql主从同步怎么做的吧？ master提交完事务后，写入bin log。 slave连接到master，获取bin log。 master创建dump线程，推送bing log到slave。 slave启动一个IO线程读取同步过来的master的bin log，记录到relay log中继日志中。 slave再开启一个sql线程读取relay log事件并在slave执行，完成同步。 slave记录自己的bin log。 由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。 全同步复制 半同步复制 主库写入bin log后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。 库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。 主从延迟？ 1. 针对特定的业务场景，读写请求都强制走主库。 2. 读请求走从库，如果没有数据，去主库做二次查询。 Mysql的MyISAM和InnoDB存储引擎的区别是啥？ 名称 解释 MyISAM 不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存里可以缓存更多的索引，对查询的性能会更好，适用于那种少量的插入，大量查询的场景。 InnoDB 主要特点就是支持事务，走聚簇索引，强制要求有主键，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，分库分表、读写分离、主备切换，全部都可以基于innodb存储引擎。 union和union all区别？ union union all 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序。 对两个结果集进行并集操作，包括重复行，不进行排序。 SQL注入？ 👉 SQL注入详解 drop、truncate和delete的区别？ 👉 drop、truncate和delete的区别 count(*)和count(字段)的区别？ 👉 count(*)和count(字段)的区别 count(*) count(字段) 计入null值 不计入null值 查询一个表中某个数据重复条数大于1的所有信息？ select 字段1 from 表名 group by 字段1 having count(*) > 1 谈谈你对Mysql的MVCC的理解？ 👉 面试官：谈谈你对Mysql的MVCC的理解？ 👉 MVCC多版本并发控制 (a, b, c)联合索引，只查询b会用到索引吗？ 👉 有mysql联合索引(A, B, C)，那么AC查询会用到索引吗？ 👉 透彻理解联合索引(a,b,c) 什么是最左匹配原则？ 👉 最左匹配原则及其成因 "},"pages/SSM.html":{"url":"pages/SSM.html","title":"SSM框架","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 使用Spring的好处？ Spring中使用了哪些设计模式吗？ SpringIOC的启动过程吗？ SpringBean的生命周期吗？ Spring中bean实例化有哪几种方式(依赖注入)？ SpringBean有哪些作用域？是否是线程安全的？ Spring如何解决循环依赖的？ Spring IOC原理？ Spring AOP原理？ Spring事务的传播行为？ SpringMVC工作原理？ SpringMVC常用的注解？ SpringMVC单例，高并发情况下，如何保证线程安全？ 如何在过滤器处理类似重复下单的问题？ Restful的优势？ 什么是JDBC？解释下驱动(Driver)在JDBC中的角色？Class.forName()方法有什么作用？ PreparedStatement比Statement有什么优势？ 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？ 数据库连接池的优点？ JDBC连接数据库步骤？ ${}和#{}的区别是什么？ MyBatis接口为啥就能执行SQL啊？ 能画一张图并解释Spring Boot的核心架构吗？ @SpringBootApplication包含哪些注解？ SpringBoot连接池？ SpringBoot实现返回json格式的数据？ SSM框架 使用Spring的好处？ 降低了组件之间的耦合性，实现了软件各层之间的解耦。 可以使用容易提供的众多服务，如事务管理，消息服务等。 容器提供单例模式支持。 容器提供了AOP技术，利用它很容易实现如权限拦截，运行期监控等功能。 容器提供了众多的辅助类，能加快应用的开发。 Spring对于主流的应用框架提供了集成支持，如hibernate、JPA、Struts等。 Spring属于低侵入式设计，代码的污染极低。 独立于各种应用服务器。 Spring的DI机制降低了业务对象替换的复杂性。 Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择Spring的部分或全部。 Spring中使用了哪些设计模式吗？ 👉 Spring中使用的设计模式 设计模式 解释 单例模式 原型模式 模板模式 JdbcTemplate 观察者模式 ApplicationListener 工厂模式-简单工厂模式 getBean() 工厂模式-工厂方法模式 适配器模式 在AOP实现中的Advice和interceptor之间的转换。 装饰者模式 一种是类名中含有Wrapper，另一种是类名中含有Decorator。 代理模式 Spring AOP 策略模式 实例化对象 SpringIOC的启动过程吗？ 👉 容器创建流程 SpringBean的生命周期吗？ 👉 Spring中bean的生命周期详解 实例化，创建一个Bean对象。 填充属性，为属性赋值。 初始化： 如果实现了xxxAware接口，通过不同类型的Aware接口拿到Spring容器的资源。 如果实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation和postProcessAfterInitialization方法。 如果配置了init-method方法，则会执行init-method配置的方法。 销毁: 容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy方法。 如果配置了destroy-method方法，则会执行destroy-method配置的方法。 Spring中bean实例化有哪几种方式(依赖注入)？ Set方法 public class SpringAction { private SpringDao springDao; public void setSpringDao(SpringDao springDao) { this.springDao = springDao; } public void doMethod(){ springDao.doMethod(); } } 普通构造方法 public class SpringAction { private SpringDao springDao; public SpringAction(SpringDao springDao){ this.springDao = springDao; } public void doMethod(){ springDao.doMethod(); } } 静态工厂 public class SpringAction { private FactoryDao staticFactoryDao; public void setStaticFactoryDao(FactoryDao staticFactoryDao) { this.staticFactoryDao = staticFactoryDao; } } public class DaoFactory { public static final FactoryDao getStaticFactoryDaoImpl(){ return new StaticFacotryDaoImpl(); } } 实例工厂 public class SpringAction { private FactoryDao factoryDao; public void setFactoryDao(FactoryDao factoryDao) { this.factoryDao = factoryDao; } } public class DaoFactory { public FactoryDao getFactoryDaoImpl(){ return new FactoryDaoImpl(); } } SpringBean有哪些作用域？是否是线程安全的？ 类别 是否线程安全 作用域 singleton(默认) 不确定 单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。 prototype 安全 原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例，一般来说下面几种作用域，在开发的时候一般都不会用，99.99%的时候都是用singleton单例作用域。 request 不确定 对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效，在请求完成以后，bean会失效并被垃圾回收器回收。 session 不确定 对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效，在session过期后，bean会随之失效。 globalSession 不确定 每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效。 线程安全这个问题，要从单例与原型Bean分别进行说明。对于原型Bean，每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。对于单例Bean，所有线程都共享一个单例实例Bean，因此是存在资源的竞争。如果单例Bean，是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如SpringMVC的Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。对于有状态的Bean，Spring官方提供的Bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。 Spring如何解决循环依赖的？ 👉 spring如何解决循环依赖 首先，Spring 解决循环依赖有两个前提条件: 不全是构造器方式的循环依赖。 必须是单例。 基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化的对象。 第一级缓存Map singletonObjects: 用来保存实例化、初始化都完成的对象。 第二级缓存Map earlySingletonObjects: 用来保存实例化完成，但是未初始化完成的对象。 第三级缓存Map> singletonFactories: 用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象。 场景: A、B互相依赖？ 创建对象A，实例化的时候把A对象工厂放入三级缓存。 A注入属性时，发现依赖B，转而去实例化B。 同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂。拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。 接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存。 最后，一级缓存中保存着实例化、初始化都完成的A、B对象。 为什么要三级缓存？二级不行吗？ 不可以，主要是为了生成代理对象。因为三级缓存中放的是生成具体对象的匿名内部类，他可以生成代理对象，也可以是普通的实例对象。使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，BeanPostProcessor去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。 Spring IOC原理？ IOC(Inversion Of Control)是指容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接操控。控制权由应用代码中转到了外部容器，控制权的转移是所谓反转。对于Spring而言，就是由Spring来控制对象的生命周期和对象之间的关系；IOC还有另外一个名字——“依赖注入(Dependency Injection)”。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。 所有的类都会在Spring容器中登记，告诉Spring这是个什么东西，你需要什么东西，然后Spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被Spring控制，所以这叫控制反转。 在系统运行中，动态的向某个对象提供它所需要的其他对象。 依赖注入的思想是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。 总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。 注入方式有两种：依赖注入和设置注入。 IOC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。 Spring AOP原理？ AOP面向方面编程基于IOC，是对OOP的有益补充。 AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 AOP代表的是一个横向的关系，将“对象”比作一个空心的圆柱体，其中封装的是对象的属性和行为；则面向方面编程的方法，就是将这个圆柱体以切面形式剖开，选择性的提供业务逻辑。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹，但完成了效果。 实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。 代理方式 解释 JDK动态代理 其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理，其核心的两个类是InvocationHandler和Proxy。 CGLIB代理 实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM(开源的java字节码编辑类库)操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。 Spring事务的传播行为？ 👉 Spring事务传播机制详解 传播行为 解释 PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。 PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。 PROPAGATION_MANDATORY 表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。 PROPAGATION_REQUIRED_NEW 表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。 PROPAGATION_NOT_SUPPORTED 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。 PROPAGATION_NEVER 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。 PROPAGATION_NESTED 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务。 SpringMVC工作原理？ 步骤1客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径(在web.xml中指定)，web容器将请求转交给DispatcherServlet。 步骤2DispatcherServlet接收到这个请求之后将根据请求的信息(包括URL、Http方法、请求报文头和请求参数Cookie等)以及HandlerMapping的配置找到处理请求的处理器(Handler)。 步骤3、4DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler(Handler将具体的处理进行封装)，再由具体的HandlerAdapter对Handler进行具体的调用。 步骤5Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。 步骤6Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherServlet通过ViewResolver将逻辑视图转化为真正的视图View。 步骤7DispatcherServlet通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。 SpringMVC常用的注解？ 名称 解释 @Controller Controller控制器是通过服务接口定义的提供访问应用程序的一种行为，它解释用户的输入，将其转换成一个模型然后将试图呈献给用户。Spring MVC使用@Controller定义控制器，它还允许自动检测定义在类路径下的组件并自动注册。如想自动检测生效，需在XML头文件下引入spring-context。 @RequestMapping 既可以作用在类级别，也可以作用在方法级别。 @PathVariable @PathVariable中的参数可以是任意的简单类型，如int, long, Date等等。Spring会自动将其转换成合适的类型或者抛出TypeMismatchException异常。 @RequestParam @RequestParam将请求的参数绑定到方法中的参数上。其实，即使不配置该参数，注解也会默认使用该参数。如果想自定义指定参数的话，如果将@RequestParam的required属性设置为false(如@RequestParam(value=\"id\",required=false))。 @RequestBody 方法参数应该被绑定到HTTP请求Body上。 @ResponseBody 将返回类型直接输入到HTTP response body中。 @RestController 创建REST类型的控制器与@Controller类型。 SpringMVC单例，高并发情况下，如何保证线程安全？ Spring单例模式下用它来切换不同线程之间的参数。用ThreadLocal是为了保证线程安全，实际上ThreadLocal的key就是当前线程的Thread实例。单例模式下，Spring把每个线程可能存在线程安全问题的参数值放进了ThreadLocal。这样虽然是一个实例在操作，但是不同线程下的数据互相之间都是隔离的，因为运行时创建和销毁的bean大大减少了，所以大多数场景下这种方式对内存资源的消耗较少，而且并发越高优势越明显。总的来说就是，单例模式因为大大节省了实例的创建和销毁，有利于提高性能，而ThreadLocal用来保证线程安全性。 如何在过滤器处理类似重复下单的问题？ 通过设置token的形式。把当前用户信息和token设置到session里，token为当前时间戳的值，同一用户下每次提交的token不一样，才允许通过，如果是2次以上的请求，那么可以使用token.equals(session.getAttribute(\"token\"))来判断是否在同一个时刻有重复提交，如果相等，那么给错误提示: 重复提交！如果没有，那么就把token设置到对应的Session里。 \" /> public void doFilter(ServletRequest request, ServletResponse response, FilterChain arg2) throws IOException, ServletException { HttpServletRequest servletrequest = (HttpServletRequest) request; HttpServletResponse servletresponse = (HttpServletResponse) response; // 获取页面token值 String clientToken = servletrequest.getParameter(\"token\"); String uid=servletrequest.getParameter(\"uid\"); // 页面token值为空就不用过滤 if(clientToken==null){ arg2.doFilter(request, response); }else{ HttpSession session = servletrequest.getSession(); // 获取会话token值 String sessionToken = (String) session.getAttribute(\"token\"); String sessionUid=(String) session.getAttribute(\"uid\"); // 判断页面token值是否等于会话token值，会话token值为空就是第一次提交，相等就是重复提交 if (sessionToken != null && uid.equals(sessionUid) && clientToken.equals(sessionToken)) { servletresponse.setContentType(\"text/html\"); servletresponse.setCharacterEncoding(\"GBK\"); // 跳转到错误提示页面 servletresponse.sendRedirect(servletrequest.getContextPath()+\"/public/duplicataSubmitError.jsp\"); }else{ session.setAttribute(\"uid\",uid); // 把页面token值赋予会话token值 session.setAttribute(\"token\", clientToken); arg2.doFilter(request, response); } } } Restful的优势？ 优势 解释 客户-服务器 客户-服务器约束背后的原则是分离关注点。通过分离用户接口和数据存储这两个关注点，改善了用户接口跨多个平台的可移植性；同时通过简化服务器组件，改善了系统的可伸缩性。 无状态 通信在本质上是无状态的，改善了可见性、可靠性、可伸缩性。 缓存 改善了网络效率减少一系列交互的平均延迟时间，来提高效率、可伸缩性和用户可觉察的性能。 统一接口 REST架构风格区别于其他基于网络的架构风格的核心特征是，它强调组件之间要有一个统一的接口。 什么是JDBC？解释下驱动(Driver)在JDBC中的角色？Class.forName()方法有什么作用？ JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。 JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 Class.forName()用来载入跟数据库建立连接的驱动。 PreparedStatement比Statement有什么优势？ Statement PreparedStatement 每次执行sql语句，相关数据库都要执行sql语句的编译。 PreparedStatement是预编译的，对于批量处理可以大大提高效率，也叫JDBC存储过程。 在对数据库只执行一次性存取的时侯，用Statement对象进行处理。 对象的开销比Statement大，对于一次性操作并不会带来额外的好处。 是'+'字符串拼接，安全性较低。 用'?'传参,可以防止sql注入，具有安全性。 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？ CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：CallableStament.prepareCall()。 数据库连接池的优点？ 限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃。 数据库连接不需要每次都去创建或销毁，节约了资源。 数据库连接不需要每次都去创建，响应时间更快。 JDBC连接数据库步骤？ 加载JDBC驱动程序通过Class类的forName方法实现，并将驱动地址放进去成功加载后，会将Driver类的实例注册到DriverManager类中。 提供JDBC连接的URL、创建数据库的连接要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。使用DriverManager的getConnection()方法传入指定的欲连接的数据库的路径、数据库的用户名和密码。Connection con = DriverManager.getConnection(url,username,password); \"jdbc:mysql://localhost:3306/test?user=root&password=123&useUnicode=true&characterEncoding=utf-8\" 创建一个Statement要执行SQL语句，必须获得java.sql.Statement实例；执行静态SQL语句，通常通过Statement实例实现；执行动态SQL语句，通常通过PreparedStatement实例实现。String sql = \"\"; Statement st = con.createStatement(); PreparedStatement pst = con.prepareStatement(sql); 执行SQL语句Statement接口提供了executeQuery、executeUpdate、execute三种方法。executeQuery执行select语句，返回ResultSet结果集；executeUpdate执行insert、update、delete语句。ResultSet rst = pst.executeQuery(); 关闭JDBC对象操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源。 ${}和#{}的区别是什么？ ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。 #{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。使用#{}可以有效的防止SQL注入，提高系统安全性。 MyBatis接口为啥就能执行SQL啊？ 👉 MyBatis你只写了接口为啥就能执行SQL啊？ 能画一张图并解释Spring Boot的核心架构吗？ 特征 解释 独立运行Spring项目 Spring Boot可以以jar包形式独立运行，运行一个Spring Boot项目只需要通过java -jar xx.jar来运行。 内嵌servlet容器 Spring Boot可以选择内嵌Tomcat、jetty或者Undertow，这样我们无须以war包形式部署项目。 提供starter简化Maven配置 Spring提供了一系列的start pom来简化Maven的依赖加载。例如，当你使用了spring-boot-starter-web，会自动加入依赖包。 自动装配Spring SpringBoot会根据在类路径中的jar包，类。为jar包里面的类自动配置Bean，这样会极大地减少我们要使用的配置。当然，SpringBoot只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean，而SpringBoot没有提供支持，则可以自定义自动配置。 准生产的应用监控 SpringBoot提供基于HTTP SSH Telnet对运行时的项目进行监控。 无代码生产和XML配置 Spring Boot不是借助于代码生成来实现的，而是通过条件注解来实现的，这是Spring4.x提供的新特性。 @SpringBootApplication包含哪些注解？ @ComponentScan扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到Spring容器进行管理。 @SpringBootConfiguration继承自@Configuration，二者功能一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到Spring容器中，并且实例名就是方法名。 @EnableAutoConfiguration启动自动的配置，@EnableAutoConfiguration注解的意思就是SpringBoot根据你添加的jar包来配置你项目的默认配置。 SpringBoot连接池？ 👉 详解SpringBoot配置连接池 SpringBoot实现返回json格式的数据？ @ResponseBody 需要在@RequestMapping中，添加produces=\"application/json;charset=UTF-8\"，设定返回值的类型。 @ResponseBody @RequestMapping(value = \"/body/data\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\") public String writeByBody(@RequestBody JSONObject jsonParam) { // 直接将json信息打印出来 System.out.println(jsonParam.toJSONString()); // 将获取的json数据封装一层，然后在给返回 JSONObject result = new JSONObject(); result.put(\"msg\", \"ok\"); result.put(\"method\", \"@ResponseBody\"); result.put(\"data\", jsonParam); return result.toJSONString(); } HttpServletResponse 通过HttpServletResponse获取到输出流后，写出数据到客户端，也就是网页了。 @RequestMapping(value = \"/resp/data\", method = RequestMethod.POST) public void writeByResp(@RequestBody JSONObject jsonParam,HttpServletResponse resp) { // 将获取的json数据封装一层，然后在给返回 JSONObject result = new JSONObject(); result.put(\"msg\", \"ok\"); result.put(\"method\", \"HttpServletResponse\"); result.put(\"data\", jsonParam); //写json数据到客户端 this.writeJson(resp, result); } public void writeJson(HttpServletResponse resp ,JSONObject json ){ PrintWriter out = null; try { //设定类容为json的格式 resp.setContentType(\"application/json;charset=UTF-8\"); out = resp.getWriter(); //写到客户端 out.write(json.toJSONString()); out.flush(); } catch (IOException e) { e.printStackTrace(); }finally{ if(out != null){ out.close(); } } } "},"pages/Redis.html":{"url":"pages/Redis.html","title":"Redis","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 什么是Redis？简述它的优缺点？ Redis持久化机制？ 知道什么是热key吗？热key问题怎么解决？ 缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存更新、缓存降级问题？ 热点数据和冷数据是什么？ Memcache与Redis的区别都有哪些？ 单线程的Redis为什么这么快？ Redis的数据类型，以及每种数据类型的使用场景？ Redis有哪些适合的使用场景？ Redis的过期策略以及内存淘汰机制？ Redis为什么是单线程的？ 有没有尝试进行多机Redis的部署？如何保证数据一致的？ Redis对于大量的请求怎么样处理？ Redis常见性能问题和解决方案？ 讲解下Redis线程模型？ 为什么Redis的操作是原子性的，怎么保证原子性的？ Redis实现分布式锁？ Redis有哪些架构模式？讲讲各自的特点？ 什么是一致性哈希算法？ 什么是哈希槽？ 如何保证缓存与数据库一致性的？ Redis大key问题？ Redis 什么是Redis？简述它的优缺点？ Redis的全称是Remote Dictionary Server，本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。 因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说用他的List来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的memcached来用。Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis持久化机制？ Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。 RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。(快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。) AOF持久化，Redis会将每一个收到的写命令都通过write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。 知道什么是热key吗？热key问题怎么解决？ 所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。 针对热key的解决方案: 提前把热key打散到不同的服务器，降低压力。 加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询。 缓存雪崩、缓存穿透、缓存击穿、缓存预热、缓存更新、缓存降级问题？ 问题 定义 解决办法 缓存雪崩 由于原有缓存失效，新缓存未到期间(例如我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。 大多数系统设计者考虑用加锁(最多的解决方案)或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是将缓存失效时间分散开。 缓存穿透 用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空(相当于进行了两次无用的查询)。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。Bitmap典型的缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间和时间来完成了。 缓存击穿 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 设置热点数据永远不过期；加互斥锁。 缓存预热 系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据。 直接写个缓存刷新页面，上线时手工操作下；数据量不大，可以在项目启动的时候自动进行加载；定时刷新缓存。 缓存更新 除了缓存服务器自带的缓存失效策略之外(Redis默认的有6种策略可供选择)，我们还可以根据具体的业务需求进行自定义的缓存淘汰。 定时去清理过期的缓存；当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂。 缓存降级 当访问量剧增、服务出现问题(如响应时间慢或不响应)或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 热点数据和冷数据是什么？ 热点数据，缓存才有价值。 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存。 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。 Memcache与Redis的区别都有哪些？ —— Redis Memcache 存储方式 部份存在硬盘上，Redis可以持久化其数据。 数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 数据支持类型 支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储。 所有的值均是简单的字符串。 底层模型/通信应用协议 直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 —— value值大小不同 最大可以达到512M。 只有1MB。 速度 快 慢 数据备份 支持master-slave模式的数据备份。 —— 单线程的Redis为什么这么快？ 纯内存操作。 单线程操作，避免了频繁的上下文切换。 采用了非阻塞I/O多路复用机制。 Redis的数据类型，以及每种数据类型的使用场景？ 👉 Redis五种数据结构 名称 解释 string 最常规的set/get操作，value可以是string也可以是数字。一般做一些复杂的计数功能的缓存。 hash 这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 list 使用list的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。 set 因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 sorted set sorted set多了一个权重参数score，集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。 思考：zset是如何排序的？ Redis有哪些适合的使用场景？ 使用场景 解释 会话缓存(Session Cache) 最常用的一种使用Redis的情景是会话缓存(session cache)，用Redis缓存会话比其他存储(如Memcached)的优势在于Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？幸运的是，随着Redis这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。 全页缓存(FPC) 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。 队列 Redis在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列 平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言(如 Python)对list的push/pop操作。如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis 作为broker，你可以从这里去查看。 排行榜/计数器 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合(Set)和有序集合(SortedSet)也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行:ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 发布/订阅 最后(但肯定不是最不重要的)是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统。 Redis的过期策略以及内存淘汰机制？ Redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略？ 定时删除，用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key，因此没有采用这一策略。 定期删除+惰性删除是如何工作的呢？ 定期删除，Redis默认每个100ms检查，是否有过期的key，有过期key则删除。需要说明的是，Redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms，全部key进行检查，Redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，Redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么？ 不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。在redis.conf中有一行配置。 maxmemory-policy volatile-lru maxmemory-policy参数 解释 volatile-lru(默认) 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰。 volatile-ttl 从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰。 volatile-random 从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。 allkeys-lru 从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰。 allkeys-random 从数据集(server.db[i].dict)中任意选择数据淘汰。 no-enviction 禁止驱逐数据，新写入操作会报错。 如果没有设置expire的key，不满足先决条件(prerequisites)；那么volatile-lru，volatile-random和volatile-ttl策略的行为和noeviction(不删除)基本上一致。 Redis为什么是单线程的？ 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。Redis利用队列技术将并发访问变为串行访问。 绝大部分请求是纯粹的内存操作。 采用单线程,避免了不必要的上下文切换和竞争条件。 非阻塞IO优点:速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)； 支持丰富数据类型，支持string，list，set，sorted set，hash； 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行； 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题； 同时有多个子系统去set一个key。这个时候要注意什么呢？不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可； 如果对这个key操作，要求顺序：分布式锁+时间戳。假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推； 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性； 对Redis的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题，Redis内部已经帮你处理好并发的问题了。 有没有尝试进行多机Redis的部署？如何保证数据一致的？ 主从复制，读写分离 一类是主数据库(master)、一类是从数据库(slave)。主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。 Redis对于大量的请求怎么样处理？ Redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求。 Redis是通过IO多路复用(select、epoll、kqueue。依据不同的平台，采取不同的实现)来处理多个客户端请求的。 Redis常见性能问题和解决方案？ Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次。 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。 尽量避免在压力很大的主库上增加从库。 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master 讲解下Redis线程模型？ 文件事件处理器包括分别是套接字、I/O多路复用程序、文件事件分派器(dispatcher)、以及事件处理器。使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。 I/O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面，然后通过这个队列，以有序(sequentially)、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后(该套接字为事件所关联的事件处理器执行完毕)，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。 为什么Redis的操作是原子性的，怎么保证原子性的？ 对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。 Redis的操作之所以是原子性的，是因为Redis是单线程的。 Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。 多个命令在并发中也是原子性的吗？不一定，将get和set改成单命令操作，incr。使用Redis的事务，或者使用Redis+Lua==的方式实现。 Redis实现分布式锁？ Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。将key的值设为value，当且仅当key不存在。若给定的key已经存在，则SETNX不做任何动作。使用del key命令就能释放锁。 如何解决死锁？ 通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。 使用setnx key \"当前系统时间+锁持有的时间\" 和 getset key \"当前系统时间+锁持有的时间\" 组合的命令就可以实现。 Redis有哪些架构模式？讲讲各自的特点？ 模式 解释 特点 问题 单机版 ———— 1. 简单。 1. 内存容量有限；2. 处理能力有限；3. 无法高可用。 主从复制 Redis的复制(replication)功能允许用户根据一个Redis服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步给从服务器，从而一直保证主从服务器的数据相同。 1. master/slave角色；2. master/slave数据相同；3. 降低master读压力在转交从库。 1. 无法保证高可用；2. 没有解决master写的压力。 哨兵 Redis sentinel是一个分布式系统中监控Redis主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：1. 监控(Monitoring): Sentinel会不断地检查你的主服务器和从服务器是否运作正常；2. 提醒(Notification)：当被监控的某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知；3. 自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作。 1. 保证高可用；2. 监控各个节点；3. 自动故障迁移。 1. 没有解决master写的压力。 集群(proxy型) Twemproxy是一个Twitter开源的一个Redis和Memcache快速/轻量级代理服务器；Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和Redis协议。 1. 多种hash算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins；2. 支持失败节点自动删除；3. 后端Sharding分片逻辑对业务透明，业务方的读写方式和操作单个Redis一致。 1. 增加了新的proxy，需要维护其高可用。2. failover逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预。 集群(直连型) 从Redis3.0之后版本支持Redis-Cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。 1. 无中心架构(不存在哪个节点影响性能瓶颈)，少了proxy层；2. 数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；3. 可扩展性，可线性扩展到1000个节点，节点可动态添加或删除；4. 高可用性，部分节点不可用时，集群仍可用。通过增加Slave做备份数据副本；5. 实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升。 1. 资源隔离性较差，容易出现相互影响的情况；2. 数据通过异步复制，不保证数据的强一致性。 什么是一致性哈希算法？ 👉 一致性哈希算法原理 什么是哈希槽？ 从Redis3.0之后版本支持Redis-Cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。 结构特点 所有的Redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。 节点的fail是通过集群中超过半数的节点检测失效时才生效。 客户端与Redis节点直连，不需要中间proxy层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。 Redis-Cluster把所有的物理节点映射到[0-16383]slot上(不一定是平均分配)，cluster负责维护nodeslotvalue。 Redis集群预分好16384个桶，当需要在Redis集群中放置一个key-value时，根据CRC16(key)mod 16384的值，决定将一个key放到哪个桶中。 如何保证缓存与数据库一致性的？ 串行化 读请求和写请求串行化，串到一个内存队列里去。串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降 低，用比正常情况下多几倍的机器去支撑线上请求。 Cache Aside Pattern 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应；更新的时候，先更新数据库，然后再删除缓存。 为什么是删除缓存，而不是更新缓存？原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？举个栗子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存更新20次、100次；但是这个缓存在1分钟内只被读取了1次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在1分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低，用到缓存才去算缓存。其实删除缓存，而不是更新缓存，就是一个lazy计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像Mybatis、Hibernate都有懒加载思想。查询一个部门，部门带了一个员工的list，没有必要说每次查询部门，都里面的1000个员工的数据也同时查出来啊。80%的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询1000个员工。 Redis大key问题？ 👉 Redis大key问题、问题分析、解决方案 "},"pages/Elasticsearch.html":{"url":"pages/Elasticsearch.html","title":"Elasticsearch","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Elasticsearch是什么？ Elasticsearch的核心概念？ Elasticsearch核心概念、数据库核心概念？ shard、replica机制？ 单node环境下如何创建index？ 剖析Elasticsearch并发冲突问题？ Elasticsearch document路由原理？ Elasticsearch写入一致性原则？ DeepPaging操作的问题？ 倒排索引相关问题？ 什么是分词器？ 什么是mapping？mapping的核心数据类型？dynamic mapping时数据类型转换？如何查看mapping？ filter与query对比及区别？ ES相关度评分算法？ ES的写入流程(buffer、segment、commit)？ 基于translog和commit point如何进行数据恢复？ 磁盘文件如何合并(segment merge)？ partial update(部分更新)实现原理？ bulk操作相关问题？ 如何重建索引？ Elasticsearch Elasticsearch是什么？ 基于lucene，隐藏复杂性，提供简单易用的restful API接口、java API接口(还有其他语言的API接口)。 分布式的文档存储引擎。 分布式的搜索引擎和分析引擎。 分布式，支持PB级数据。 Elasticsearch的核心概念？ 名称 解释 Near Realtime(NRT) 近实时，两个意思，从写入数据到数据可以被搜索到有一个小延迟(大概1秒)；基于es执行搜索和分析可以达到秒级。 Cluster(集群) 包含多个节点，每个节点属于哪个集群是通过一个配置(集群名称，默认是Elasticsearch)来决定的，对于中小型应用来说，刚开始一个集群就一个节点很正常。 Node(节点) 集群中的一个节点，节点也有一个名称(默认是随机分配的)，节点名称很重要(在执行运维管理操作的时候)，默认节点会去加入一个名称为“Elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个Elasticsearch集群，当然一个节点也可以组成一个Elasticsearch集群。 Document(文档)、field 文档，ES中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。 Index(索引) 包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。 Type(类型) 每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。 shard 单台机器无法存储大量数据，Elasticsearch可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。 replica 任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard(建立索引时一次设置，不能修改，默认5个)，replica shard(随时修改数量，默认1个)，默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。 Elasticsearch核心概念、数据库核心概念？ Elasticsearch 数据库 Index 库 Type 表 Document 行 shard、replica机制？ index包含多个shard。 每个shard都是一个最小工作单元，承载部分数据，lucene实例，完整的建立索引和处理请求的能力。 增减节点时，shard会自动在nodes中负载均衡。 primary shard和replica shard，每个document肯定只存在于某一个primary shard以及其对应的replica shard中，不可能存在于多个primary shard。 replica shard是primary shard的副本，负责容错，以及承担读请求负载。 primary shard的数量在创建索引的时候就固定了，replica shard的数量可以随时修改。 primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard。 primary shard不能和自己的replica shard放在同一个节点上(否则节点宕机，primary shard和副本都丢失，起不到容错的作用)，但是可以和其他primary shard的replica shard放在同一个节点上。 单node环境下如何创建index？ PUT /test_index { \"settings\" : { \"number_of_shards\" : 3, \"number_of_replicas\" : 1 } } 单node环境下，创建一个index，有3个primary shard，3个replica shard。 集群status是yellow。 这个时候，只会将3个primary shard分配到仅有的一个node上去，另外3个replica shard是无法分配的。 集群可以正常工作，但是一旦出现节点宕机，数据全部丢失，而且集群不可用，无法承接任何请求。 剖析Elasticsearch并发冲突问题？ 方案 解释 悲观锁 常见关系型数据库，比如mysql，读取时加锁。 乐观锁 不加锁。写的时候判断当前version和ES的version是否一致。 Elasticsearch document路由原理？ 当客户端创建document的时候，ES就需要决定这个doc是放在这个index的哪个shard上，这个过程称为document routing，即数据路由。 primary shard一旦index建立，是不允许修改的，但是replica shard可以随时修改。 路由算法：shard = hash(routing) % number_of_primary_shards。 从hash函数中，产出的hash值一定是相同的。 无论hash值是几，无论是什么数字，对number_of_primary_shards求余数，结果一定是在0~number_of_primary_shards-1之间这个范围内的。 Elasticsearch写入一致性原则？ consistency，one(primary shard)，all(all shard)，quorum(default)。 名称 解释 one(primary shard) 要求我们这个写操作，只要有一个primary shard是active活跃可用的，就可以执行。 all(all shard) 要求我们这个写操作，必须所有的primary shard和replica shard都是活跃的，才可以执行这个写操作。 quorum(default) 默认的值，要求所有的shard中，必须是大部分的shard都是活跃的，可用的，才可以执行这个写操作quorum=(primary+number_of_replicas)/2+1。 DeepPaging操作的问题？ 简单说就是搜索特别深导致性能低下的问题。 比如总共60000条数据，3个shard，每个shard分2W条，每页10条，如果要搜到1000页时，取的是第几条到第几条数据？实际上每个shard都要将内部的2W条数据的第10001~10010条拿出来，不是10条，是10010条取出，3个shard都返回10010条数据给coordinate node，这个协调节点共收到30030条，再进行排序。_score，相关度分数，然后取到排位最高的前10条数据，这就是我们要的第1000页的10条数据。这个过程耗费网络带宽，内存，CPU，有大量性能问题，所以要避免deep paging操作。 倒排索引相关问题？ 简单说统计每个单词在哪些doc中出现，建立索引，方便后续快速查到该单词的文档。 搜索的时候，要依靠倒排索引；排序的时候，需要依靠正排索引。看到每个document的每个field，然后进行排序。所谓的正排索引，其实就是doc values。在建立索引的时候，一方面会建立倒排索引，以供搜索用；一方面会建立正排索引，也就是doc values，以供排序、聚合、过滤等操作使用。doc values是被保存在磁盘上的，此时如果内存足够，OS会自动将其缓存在内存中，性能还是会很高；如果内存不足够，OS会将其写入磁盘上。 preference决定了哪些shard会被用来执行搜索操作。例如_primary、_primary_first、 _local、_only_node:xyz、_prefer_node:xyz、_shards:2,3。 bouncing results问题，两个document排序，field值相同；不同的shard上可能排序不同；每次请求轮询打到不同的replica shard上；每次页面上看到的搜索结果的排序都不一样。这就是bouncing result，也就是跳跃的结果。解决方案就是将preference设置为一个字符串，比如说user_id让每个user每次搜索的时候都使用同一个replica shard去执行，就不会看到bouncing results了。 结构 好处 坏处 1. 包含这个关键词的document list；2. 包含这个关键词的所有document的数量：IDF(inverse document frequency)；3. 这个关键词在每个document中出现的次数：TF(term frequency)；4. 这个关键词在这个document中的次序；5. 每个document的长度：length norm；6. 包含这个关键词的所有document的平均长度。 1. 不需要锁，提升并发能力，避免锁的问题；2. 数据不变，一直保存在os cache中，只要cache内存足够；3. filter cache一直驻留在内存，因为数据不变；4. 可以压缩，节省cpu和io开销。 1. 每次都要重新构建整个索引。 什么是分词器？ 切分词；Normalization(提升recall召回率)。 Normalization，建立倒排索引的时候，会执行一个操作，也就是说对拆分出的各个单词进行相应的处理，以提升后面搜索的时候能够搜索到相关联的文档的概率。时态的转换、单复数的转换、同义词的转换、大小写的转换。分词器将一段文本进行各种处理(时态转换、单复数转换等等)，最后处理好的结果才会拿去建立倒排索引。 query string必须以和index建立时相同的analyzer进行分词。query string对exact value和full text的区别对待。exact value在建立倒排索引的时候、分词的时候，是将整个值一起作为一个关键词建立到倒排索引中的；full text会经历各种各样的处理，分词，normalization(时态转换、同义词转换、大小写转换)，才会建立到倒排索引中。同时exact value和full text类型的field就决定了，在一个搜索过来的时候，对exact value field或者是full text field进行搜索的行为也是不一样的，会跟建立倒排索引的行为保持一致；比如说exact value搜索的时候，就是直接按照整个值进行匹配，full text query string也会进行分词和normalization再去倒排索引中去搜索。 什么是mapping？mapping的核心数据类型？dynamic mapping时数据类型转换？如何查看mapping？ 自动或手动为index中type建立的一种数据结构和相关配置，简称mapping。dynamic mapping自动为我们建立index、创建type以及type对应的mapping。mapping中包含了每个field对应的数据类型，以及如何分词等设置，包括自动设置数据类型，也可以提前手动创建index和type的mapping，自己对各field进行设置，包括数据类型、索引行为、分词器等等。 mapping核心数据类型string、byte、short、integer、long、float、double、boolean、date。 dynamic mapping时true or false转boolean、123转long、123.45转double、2017-01-01转date、\"hello world\"转string/text。 查询mapping：GET /index/_mapping/type。 filter与query对比及区别？ filter query 1. 仅仅只是按照搜索条件过滤出需要的数据而已，不计算任何相关度分数，对相关度没有任何影响；2. 只是根据一些条件筛选出一部分数据，不关注其排序；3. 不希望一些搜索条件来影响你的document排序；4. 不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据。 1. 会去计算每个document相对于搜索条件的相关度，并按照相关度进行排序；2. 进行搜索需要将最匹配搜索条件的数据先返回；3. 越符合这些搜索条件的document越排在前面返回；4. 要计算相关度分数，按照分数进行排序，而且无法cache结果。 ES相关度评分算法？ 算法名称 解释 term frequency/inverse document frequency 简称为TF/IDF算法 Term frequency 搜索文本中的各个词条在field文本中出现了多少次，出现次数越多就越相关。 Inverse document frequency 搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多就越不相关。 ES的写入流程(buffer、segment、commit)？ 数据写入buffer缓冲和translog日志文件。 每隔一秒钟，buffer中的数据被写入新的segment file，并进入os cache，此时segment被打开并供search使用，不立即执行commit。(数据写入os cache，并被打开供搜索的过程，叫做refresh，默认是每隔1秒refresh一次。也就是说，每隔一秒就会将buffer中的数据写入一个新的index segment file，先写入os cache中。所以，ES是近实时的，数据写入到可以被搜索，默认是1秒。) buffer被清空。 重复1~3，新的segment不断添加，buffer不断被清空，而translog中的数据不断累加。 当translog长度达到一定程度的时候，commit操作发生。buffer中的所有数据写入一个新的segment，并写入os cache，打开供使用； buffer被清空； 一个commit point被写入磁盘，标明了所有的index segment； filesystem cache中的所有index segment file缓存数据，被fsync强行刷到磁盘上； 现有的translog被清空，创建一个新的translog。 基于translog和commit point如何进行数据恢复？ fsync+清空translog，就是flush，默认每隔30分钟flush一次，或者当translog过大的时候，也会flush。POST /my_index/_flush，一般来说别手动flush，让它自动执行就可以了。translog每隔5秒被fsync一次到磁盘上。在一次增删改操作之后，当fsync在primary shard和replica shard都成功之后，那次增删改操作才会成功。但是这种在一次增删改时强行fsync translog可能会导致部分操作比较耗时，也可以允许部分数据丢失，设置异步fsync translog。 PUT /my_index/_settings { \"index.translog.durability\": \"async\", \"index.translog.sync_interval\": \"5s\" } 磁盘文件如何合并(segment merge)？ 每秒一个segment file文件过多，而且每次search都要搜索所有的segment，很耗时。默认会在后台执行segment merge操作。在merge的时候，被标记为deleted的document也会被彻底物理删除。 每次merge操作的执行流程： 选择一些有相似大小的segment，merge成一个大的segment； 将新的segment flush到磁盘上去； 写一个新的commit point，包括了新的segment，并且排除旧的那些segment； 将新的segment打开供搜索； 将旧的segment删除。 partial update(部分更新)实现原理？ post /index/type/id/_update { \"doc\": { \"要修改的少数几个field即可，不需要全量的数据\" } } eg： PUT /test_index/test_type/10 { \"test_field1\": \"test1\", \"test_field2\": \"test2\" } POST /test_index/test_type/10/_update { \"doc\": { \"test_field2\": \"updated test2\" } } 内部先获取document。 在内存中封装用户提交的新document，发送PUT请求到ES内部。 将老的document标记为deleted。 将新的document存入索引中。 比全量替换的优点：所有查询、修改和写回操作都发生在ES的一个shard内部，避免网络开销(减少2次网络请求)提升性能。 bulk操作相关问题？ 每一个操作要两个json串，语法如下： {\"action\": {\"metadata\"}} {\"data\"} eg： {\"index\": {\"_index\": \"test_index\", \"_type\", \"test_type\", \"_id\": \"1\"}} {\"test_field1\": \"test1\", \"test_field2\": \"test2\"} 可以执行操作的类型如下： 操作 解释 delete 删除一个文档，只要1个json串就可以了。 create PUT /index/type/id/_create，强制创建。 index 普通的put操作，可以是创建文档，也可以是全量替换文档。 update 执行的partial update操作。 bulk request会加载到内存里，如果太大的话，性能反而会下降，因此需要反复尝试一个最佳的bulk size。一般从1000~5000条数据开始，尝试逐渐增加。另外，如果看大小的话，最好是在5~15MB之间。 如何重建索引？ 一个field的设置是不能被修改的，如果要修改一个field，那么应该重新按照新的mapping建立一个index，然后将数据批量查询出来，重新用bulk api写入index中。批量查询的时候，建议采用scroll api，并且采用多线程并发的方式来reindex数据，每次scroll就查询指定日期的一段数据，交给一个线程即可。 一开始依靠dynamic mapping插入数据，但是不小心有些数据是2017-01-01这种日期格式的，所以title这种field被自动映射为了date类型，实际上它应该是string类型的。 当后期向索引中加入string类型的title值的时候就会报错。 如果此时想修改title的类型是不可能的。 唯一的办法就是进行reindex，也就是说重新建立一个索引，使用scroll api将旧索引的数据批量查询出来，再导入新索引。 采用bulk api将scroll查出来的一批数据，批量写入新索引。 如果说旧索引的名字是old_index，新索引的名字是new_index，终端java应用已经在使用old_index在操作了，难道还要去停止java应用，修改使用的index为new_index，才重新启动java应用吗？这个过程中就会导致java应用停机，可用性降低。 解决方案 给java应用一个别名，这个别名是指向旧索引的，java应用先用着，java应用先用goods_index alias来操作，此时实际指向的是旧的my_index。重建索引后，将goods_index alias切换到my_index_new上去。java应用会直接通过index别名使用新的索引中的数据，java应用程序不需要停机，零提交，高可用。 "},"pages/Zookeeper.html":{"url":"pages/Zookeeper.html","title":"Zookeeper","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Zookeeper是什么？ Zookeeper提供了什么？ Zookeeper有哪几种znode？ Zookeeper有哪些适合的使用场景？ Zookeeper获取分布式锁的流程？ Zookeeper数据复制？ Zookeeper工作原理？ Zookeeper是如何保证事务的顺序一致性的？ Zookeeper下Server工作状态？ Zookeeper是如何选取主leader的？ Zookeeper同步流程？ Zookeeper节点宕机如何处理？ Zookeeper watch机制？ 为什么我们在分布式系统架构中需要使用Zookeeper集群？ Zookeeper Zookeeper是什么？ ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的Zookeeper机器来处理。对于写请求，这些请求会同时发给其他Zookeeper机器并且达成一致后，请求才会返回成功。因此，随着Zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。有序性是Zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid(Zookeeper Transaction Id)。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个Zookeeper最新的zxid。 Zookeeper提供了什么？ 名称 解释 文件系统 Zookeeper提供一个多层级的节点命名空间(节点称为znode)。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。 通知机制 client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到Zookeeper的通知，然后client可以根据znode变化来做出业务上的改变等。 Zookeeper有哪几种znode？ 名称 解释 PERSISTENT(持久化目录节点) 客户端与Zookeeper断开连接后，该节点依旧存在。 PERSISTENT_SEQUENTIAL(持久化顺序编号目录节点) 客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。 EPHEMERAL(临时目录节点) 客户端与Zookeeper断开连接后，该节点被删除。 EPHEMERAL_SEQUENTIAL(临时顺序编号目录节点) 客户端与Zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。 Zookeeper有哪些适合的使用场景？ 使用场景 解释 命名服务(文件系统)   命名服务是指通过指定的名字来获取资源或者服务的地址，利用Zookeeper创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。 配置管理(文件系统、通知机制)   程序分布式的部署在不同的机器上，将程序的配置信息放在Zookeeper的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变Zookeeper中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。 集群管理(文件系统、通知机制)   所谓集群管理无在乎两点：是否有机器退出和加入、选举master。   对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与Zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道它上船了。   新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。 分布式锁(文件系统、通知机制)   有了Zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类：一个是保持独占，另一个是控制时序。  对于第一类，我们将Zookeeper上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建/distribute_lock节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock节点就释放出锁。  对于第二类，/distribute_lock已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。 Zookeeper获取分布式锁的流程？ 在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。 代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper实现分布式锁的细节。 Zookeeper数据复制？ Zookeeper作为一个集群提供一致的数据服务，自然它要在所有机器间做数据复制。数据复制的好处： 容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作; 提高系统的扩展能力：把负载分布到多个节点上，或者增加节点来提高系统的负载能力; 提高性能：让客户端本地访问就近的节点，提高用户访问速度。 从客户端读写访问的透明度来看，数据复制集群系统分下面两种： 名称 解释 写主(WriteMaster) 对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离。 写任意(Write Any) 对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。 对Zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好；而写，随着机器的增多吞吐能力肯定下降(这也是它建立observer的原因)，而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。 Zookeeper工作原理？ Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式(选主)和广播模式(同步)。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。 Zookeeper是如何保证事务的顺序一致性的？ Zookeeper采用了递增的事务Id来标识，所有的proposal(提议)都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch(时期、纪元、世、新时代)用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。 Zookeeper下Server工作状态？ 每个Server在工作过程中有三种状态： 名称 解释 LOOKING 当前Server不知道leader是谁，正在搜寻。 LEADING 当前Server即为选举出来的leader。 FOLLOWING leader已经选举出来，当前Server与之同步。 Zookeeper是如何选取主leader的？ 当leader崩溃或者leader失去大多数的follower，这时Zookeeper进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zookeeper的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。 Zookeeper同步流程？ 选完Leader以后，Zookeeper就进入状态同步过程: Leader等待server连接。 Follower连接leader，将最大的zxid发送给leader。 Leader根据follower的zxid确定同步点。 完成同步后通知follower已经成为uptodate状态。 Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。 Zookeeper节点宕机如何处理？ Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失;如果是一个Leader宕机，Zookeeper会选举出新的Leader。 Zookeeper集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在Zookeeper节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以3个节点的cluster可以挂掉1个节点(leader可以得到2票>1.5)，2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票 Zookeeper watch机制？ 一次性触发数据发生改变时，一个watcher event会被发送到client，但是client只会收到一次这样的信息。 watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。 数据监视Zookeeper有数据监视和子数据监视get data() and exists()设置数据监视，get children()设置了子节点监视。 注册watcher getData、exists、getChildren。 触发watcher create、delete、setData。 setData()会触发znode上设置的data watch(如果set成功的话)。一个成功的create()操作会触发被创建的znode上的数据watch，以及其父节点上的child watch。而一个成功的delete()操作将会同时触发一个znode的data watch和child watch(因为这样就没有子节点了)，同时也会触发其父节点的child watch。 当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。 Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watcher的布尔类型。 为什么我们在分布式系统架构中需要使用Zookeeper集群？ 单点问题 单点问题是分布式环境中最常见也是最经典的问题之一，在很多分布式系统中都会存在这样的单点问题。具体地说，单点问题是指在一个分布式系统中，如果某一个组件出现故障就会引起整个系统的可用性大大下降甚至是处于瘫痪状态，那么我们就认为该组件存在单点问题。ZooKeeper 确实已经很好地解决了单点问题。我们已经了解到，基于“过半”设计原则，ZooKeeper 在运行期间，集群中至少有过半的机器保存了最新的数据。因此，只要集群中超过半数的机器还能够正常工作，整个集群就能够对外提供服务。 容灾 在进行ZooKeeper的容灾方案设计过程中，我们要充分考虑到“过半原则”。也就是说，无论发生什么情况，我们必须保证ZooKeeper集群中有超过半数的机器能够正常工作。 "},"pages/Kafka.html":{"url":"pages/Kafka.html","title":"Kafka","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Kafka中的ISR(InSyncRepli)、OSR(OutSyncRepli)、AR(AllRepli)代表什么？ Kafka中的HW、LEO等分别代表什么？ Kafka的用途有哪些？使用场景如何？ Kafka中是怎么体现消息顺序性的？ “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？ 有哪些情形会造成重复消费？或丢失信息？ Kafka分区的目的？ Kafka的高可靠性是怎么实现的？ topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？ topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？ 简述Kafka的日志目录结构？ 如何解决消费者速率低的问题？ Kafka的哪些设计让它有如此高的性能？ Kafka启动不起来的原因？ 聊一聊Kafka Controller的作用？ Kafka中有哪些地方需要选举？这些地方的选举策略又有哪些？ 失效副本是指什么？有哪些应对措施？ Kafka消息是采用Pull模式，还是Push模式？ Kafka创建Topic时如何将分区放置到不同的Broker中? Kafka中的事务是怎么实现的? Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？ Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？ 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？ Kafka Kafka中的ISR(InSyncRepli)、OSR(OutSyncRepli)、AR(AllRepli)代表什么？ 名称 解释 ISR(InSyncRepli) 速率和leader相差低于10秒的follower的集合。 OSR(OutSyncRepli) 速率和leader相差大于10秒的follower。 AR(AllRepli) 所有分区的follower。 Kafka中的HW、LEO等分别代表什么？ 名称 解释 HW 又名高水位，根据同一分区中，最低的LEO所决定。 LEO 每个分区的最高offset。 Kafka的用途有哪些？使用场景如何？ 用途 场景 用户追踪 根据用户在web或者app上的操作，将这些操作消息记录到各个topic中，然后消费者通过订阅这些消息做实时的分析,或者记录到HDFS，用于离线分析或数据挖掘。 日志收集 通过kafka对各个服务的日志进行收集，再开放给各个consumer。 消息系统 缓存消息。 运营指标 记录运营监控数据，收集操作应用数据的集中反馈，如报错和报告。 Kafka中是怎么体现消息顺序性的？ 每个分区内，每条消息都有offset，所以只能在同一分区内有序，但不同的分区无法做到消息顺序性。 “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？ 对的,超过分区数的消费者就不会再接收数据。 有哪些情形会造成重复消费？或丢失信息？ 先处理后提交offset，会造成重读消费。 先提交offset后处理，会造成数据丢失。 Kafka分区的目的？ 对于kafka集群来说，分区可以做到负载均衡，对于消费者来说，可以提高并发度，提高读取效率。 Kafka的高可靠性是怎么实现的？ 为了实现高可靠性，kafka使用了订阅的模式，并使用isr和ack应答机制： 能进入isr中的follower和leader之间的速率不会相差10秒。 当ack=0时，producer不等待broker的ack，不管数据有没有写入成功，都不再重复发该数据。 当ack=1时，broker会等到leader写完数据后，就会向producer发送ack，但不会等follower同步数据，如果这时leader挂掉，producer会对新的leader发送新的数据，在old的leader中不同步的数据就会丢失。 当ack=-1或者all时，broker会等到leader和isr中的所有follower都同步完数据，再向producer发送ack，有可能造成数据重复。 topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？ 可以增加 bin/kafka-topics.sh --zookeeper localhost:2181/kafka --alter --topic topic-config --partitions 3 topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？ 不可以，先有的分区数据难以处理。 简述Kafka的日志目录结构？ 每一个分区对应一个文件夹，命名为topic-0，topic-1，每个文件夹内有.index和.log文件。 如何解决消费者速率低的问题？ 增加分区数和消费者数。 Kafka的哪些设计让它有如此高的性能？ kafka是分布式的消息队列。 对log文件进行了segment，并对segment建立了索引。 (对于单节点)使用了顺序读写，速度可以达到600M/s。 引用了zero拷贝，在OS系统就完成了读写操作。 Kafka启动不起来的原因？ 在关闭kafka时，先关了zookeeper，就会导致kafka下一次启动时会报节点已存在的错误。只要把zookeeper中的zkdata/version-2的文件夹删除即可。 聊一聊Kafka Controller的作用？ 负责kafka集群的上下线工作，所有topic的副本分区分配和选举leader工作。 Kafka中有哪些地方需要选举？这些地方的选举策略又有哪些？ 在ISR中需要选择，选择策略为先到先得。 失效副本是指什么？有哪些应对措施？ 失效副本为速率比leader相差大于10秒的follower。将失效的follower先提出ISR。等速率接近leader10秒内，再加进ISR。 Kafka消息是采用Pull模式，还是Push模式？ 在producer阶段，是向broker用Push模式。在consumer阶段，是向broker用Pull模式。在Pull模式下，consumer可以根据自身速率选择如何拉取数据，避免了低速率的consumer发生崩溃的问题。但缺点是，consumer要时不时的去询问broker是否有新数据，容易发生死循环，内存溢出。 Kafka创建Topic时如何将分区放置到不同的Broker中? 首先副本数不能超过broker数。第一分区是随机从Broker中选择一个，然后其他分区相对于0号分区依次向后移。第一个分区是从nextReplicaShift决定的，而这个数也是随机产生的。 Kafka中的事务是怎么实现的? Kafka事务有两种，producer事务和consumer事务。 producer事务是为了解决kafka跨分区跨会话问题，kafka不能跨分区跨会话的主要问题是每次启动的producer的PID都是系统随机给的，所以为了解决这个问题，我们就要手动给producer一个全局唯一的id，也就是transaction id，简称TID。我们将TID和PID进行绑定，在producer带着TID和PID第一次向broker注册时，broker就会记录TID，并生成一个新的组件__transaction_state用来保存TID的事务状态信息。当producer重启后，就会带着TID和新的PID向broker发起请求，当发现TID一致时，producer就会获取之前的PID，将覆盖掉新的PID，并获取上一次的事务状态信息，从而继续上次工作。 consumer事务相对于producer事务就弱一点，需要先确保consumer的消费和提交位置为一致且具有事务功能，才能保证数据的完整，不然会造成数据的丢失或重复。 Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？ 拦截器 > 序列化器 > 分区器 Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？ 使用两个线程： main线程和sender线程，main线程会依次经过拦截器，序列化器，分区器将数据发送到RecourdAccumlator(线程共享变量)。 再由sender线程从RecourdAccumlator中拉取数据发送到kafka broker。 相关参数： batch.size：只有数据积累到batch.size之后，sender才会发送数据。 linger.ms：如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？ offset+1，生产者发送数据offset是从0开始的，消费者消费的数据offset是从offset+1开始的。 "},"pages/Eureka.html":{"url":"pages/Eureka.html","title":"Eureka","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 什么是Eureka？ 客户端启动时如何注册到服务端？ 服务端如何保存客户端服务信息？ 客户端如何拉取服务端已保存的服务信息？ 如何构建高可用的Eureka集群？ 心跳和服务剔除机制是什么？ Eureka自我保护机制是什么？ Eureka 什么是Eureka？ Eureka是Netflix组件的一个子模块，也是核心模块之一。云端服务发现，一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。 下图总结了Eureka服务端与Eureka客户端之间协同工作的流程： 流程说明 Eureka客户端启动后，定时向Eureka服务端注册自己的服务信息（服务名、IP、端口等）； 客户端启动后，定时拉取服务端以保存的服务注册信息； 拉取服务端保存的服务注册信息后，就可调用消费其他服务提供者提供的服务。 客户端启动时如何注册到服务端？ 源码分析 Eureka客户端在启动后，会创建一些定时任务，其中就有一个任务heartbeatExecutor就是就是处理心跳的线程池，部分源码（源码位置：com.netflix.discovery.DiscoveryClient）如下： heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-HeartbeatExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff ...此处省略其他代码 //finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch initScheduledTasks(); 查看方法initScheduledTasks以及注释，可知该方法是初始化所有的任务（schedule tasks）。 /** * Initializes all scheduled tasks. */ private void initScheduledTasks() { ... // Heartbeat timer scheduler.schedule( new TimedSupervisorTask( \"heartbeat\", scheduler, heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, new HeartbeatThread() ), renewalIntervalInSecs, TimeUnit.SECONDS); ... } 在上述方法中，创建了一个线程HeartbeatThread，该线程就是处理心跳任务： /** * The heartbeat task that renews the lease in the given intervals. */ private class HeartbeatThread implements Runnable { public void run() { if (renew()) { lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis(); } } } /** * Renew with the eureka service by making the appropriate REST call */ boolean renew() { EurekaHttpResponse httpResponse; try { httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null); logger.debug(PREFIX + \"{} - Heartbeat status: {}\", appPathIdentifier, httpResponse.getStatusCode()); if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) { REREGISTER_COUNTER.increment(); logger.info(PREFIX + \"{} - Re-registering apps/{}\", appPathIdentifier, instanceInfo.getAppName()); long timestamp = instanceInfo.setIsDirtyWithTime(); boolean success = register(); if (success) { instanceInfo.unsetIsDirty(timestamp); } return success; } return httpResponse.getStatusCode() == Status.OK.getStatusCode(); } catch (Throwable e) { logger.error(PREFIX + \"{} - was unable to send heartbeat!\", appPathIdentifier, e); return false; } } 在renew方法中，首先会发送一个心跳数据到服务端，服务端返回一个状态码，如果是NOT_FOUND（即404），表示Eureka服务端不存在该客户端的服务信息，那么就会向服务端发起注册请求： boolean register() throws Throwable { logger.info(PREFIX + \"{}: registering service...\", appPathIdentifier); EurekaHttpResponse httpResponse; try { httpResponse = eurekaTransport.registrationClient.register(instanceInfo); } catch (Exception e) { logger.warn(PREFIX + \"{} - registration failed {}\", appPathIdentifier, e.getMessage(), e); throw e; } if (logger.isInfoEnabled()) { logger.info(PREFIX + \"{} - registration status: {}\", appPathIdentifier, httpResponse.getStatusCode()); } return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode(); } 在register方法中，向服务端的注册信息instanceInfo，它是com.netflix.appinfo.InstanceInfo，包括服务名、ip、端口、唯一实例ID等信息。 总结 Eureka客户端在启动时，首先会创建一个心跳的定时任务，定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID等信息。 服务端如何保存客户端服务信息？ 源码分析 服务端注册源码（com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.class的方法register）如下： @Override public void register(final InstanceInfo info, final boolean isReplication) { int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS; if (info.getLeaseInfo() != null && info.getLeaseInfo().getDurationInSecs() > 0) { leaseDuration = info.getLeaseInfo().getDurationInSecs(); } super.register(info, leaseDuration, isReplication); replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication); } 调用了父类（com.netflix.eureka.registry.AbstractInstanceRegistry）register方法，源码如下： public abstract class AbstractInstanceRegistry implements InstanceRegistry { ... private final ConcurrentHashMap>> registry = new ConcurrentHashMap>>(); ... public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) { try { read.lock(); Map> gMap = registry.get(registrant.getAppName()); REGISTER.increment(isReplication); if (gMap == null) { final ConcurrentHashMap> gNewMap = new ConcurrentHashMap>(); gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); if (gMap == null) { gMap = gNewMap; } } ... } } 在register方法中，我们可以看到将服务实例信息InstanceInfo注册到了register变量中，它其实就是一个ConcurrentHashMap。 总结 客户端通过Jersey框架（亚马逊的一个http框架）将服务实例信息发送到服务端，服务端将客户端信息放在一个ConcurrentHashMap对象中。 客户端如何拉取服务端已保存的服务信息？ 在知道客户端是如何拉取服务端信息的同时，也需要清楚以下问题：是需要时才去服务端拉取，还是先拉取到本地，需要用的时候直接从本地获取？ 源码分析 private void initScheduledTasks() { if (clientConfig.shouldFetchRegistry()) { // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); scheduler.schedule( new TimedSupervisorTask( \"cacheRefresh\", scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds, TimeUnit.SECONDS, expBackOffBound, new CacheRefreshThread() ), registryFetchIntervalSeconds, TimeUnit.SECONDS); } ... } 上述代码中初始化了一个刷新缓存的定时任务，我们看到第14行的新建了一个线程CacheRefreshThread，既是用来定时刷新服务端已保存的服务信息。 总结 客户端拉取服务端服务信息是通过一个定时任务定时拉取的，每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取。 如何构建高可用的Eureka集群？ 首先，搭建一个高可用的Eureka集群，只需要在每个注册中心（服务端）通过配置：eureka.client.service-url.defaultZone指定其他服务端的地址，多个使用逗号隔开，如： eureka.client.service-url.defaultZone=http://localhost:10000/eureka/,http://localhost:10001/eureka/,http://localhost:10002/eureka/ 在eureka的高可用状态下，这些注册中心是对等的，他们会互相将注册在自己的实例同步给其他的注册中心，同样是通过问题1的方式将注册在自己上的实例注册到其他注册中心去。 那么问题来了，一旦其中一个eureka收到一个客户端注册实例时，既然eureka注册中心将注册在自己的实例同步到其他注册中心中的方式和客户端注册的方式相同，那么在接收的eureka注册中心一端，会不会再同步回给注册中心（或者其他注册中心），从而导致死循环。 源码解析 replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication); replicateToPeers方法字面意思是同步或者复制到同事（即其他对等的注册中心），最后一个参数为isReplication，是一个boolean值，表示是否同步（复制），如果是客户端注册的，那么为false,如果是其他注册中心同步的则为true，replicateToPeers方法中，如果isReplication=false时，将会发起同步（第19行）： private void replicateToPeers(Action action, String appName, String id, InstanceInfo info /* optional */, InstanceStatus newStatus /* optional */, boolean isReplication) { Stopwatch tracer = action.getTimer().start(); try { if (isReplication) { numberOfReplicationsLastMin.increment(); } // If it is a replication already, do not replicate again as this will create a poison replication if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) { return; } for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) { // If the url represents this host, do not replicate to yourself. if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) { continue; } replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node); } } finally { tracer.stop(); } } 总结 搭建高可用的Eureka集群，只需要在注册中心的配置文件中配置其他注册中心的地址，配置属性如下：eureka.client.service-url.defaultZone。 注册中心收到注册信息后会判断是否是其他注册中心同步的信息还是客户端注册的信息，如果是客户端注册的信息，那么他将会将该客户端信息同步到其他注册中心去；否则收到信息后不作任何操作。通过此机制避免集群中信息同步的死循环。 心跳和服务剔除机制是什么？ 源码解析 在eureka源码中，有个evict（剔除、驱逐，源码位置：com.netflix.eureka.registry.AbstractInstanceRegistry）的方法： public void evict(long additionalLeaseMs) { logger.debug(\"Running the evict task\"); if (!isLeaseExpirationEnabled()) { logger.debug(\"DS: lease expiration is currently disabled.\"); return; } // We collect first all expired items, to evict them in random order. For large eviction sets, // if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it, // the impact should be evenly distributed across all applications. List> expiredLeases = new ArrayList<>(); for (Entry>> groupEntry : registry.entrySet()) { Map> leaseMap = groupEntry.getValue(); if (leaseMap != null) { for (Entry> leaseEntry : leaseMap.entrySet()) { Lease lease = leaseEntry.getValue(); if (lease.isExpired(additionalLeaseMs) && lease.getHolder() != null) { expiredLeases.add(lease); } } } } // To compensate for GC pauses or drifting local time, we need to use current registry size as a base for // triggering self-preservation. Without that we would wipe out full registry. int registrySize = (int) getLocalRegistrySize(); int registrySizeThreshold = (int) (registrySize * serverConfig.getRenewalPercentThreshold()); int evictionLimit = registrySize - registrySizeThreshold; int toEvict = Math.min(expiredLeases.size(), evictionLimit); if (toEvict > 0) { logger.info(\"Evicting {} items (expired={}, evictionLimit={})\", toEvict, expiredLeases.size(), evictionLimit); Random random = new Random(System.currentTimeMillis()); for (int i = 0; i lease = expiredLeases.get(i); String appName = lease.getHolder().getAppName(); String id = lease.getHolder().getId(); EXPIRED.increment(); logger.warn(\"DS: Registry: expired lease for {}/{}\", appName, id); internalCancel(appName, id, false); } } } 在上述代码第4行，做了isLeaseExpirationEnabled（字面意思：是否启用租约到期，即是否开启了服务过期超时机制，开启之后就会将过期的服务进行剔除）的if判断，源码（com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl实现类中）如下： @Override public boolean isLeaseExpirationEnabled() { if (!isSelfPreservationModeEnabled()) { // The self preservation mode is disabled, hence allowing the instances to expire. return true; } return numberOfRenewsPerMinThreshold > 0 && getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold; } 同样在上述方法开始的第3行也做了isSelfPreservationModeEnabled方法的判断，该方法是判断是否开启了自我保护机制（有关自我保护机制有关说明在第6节），接下来看到第4行的注释翻译如下：自保存模式被禁用，因此允许实例过期。也就是说如果关闭了自我保护机制，那么直接就允许实例过期，也就是说可以将过期的服务实例剔除。那如果开启了自我保护机制，会做如下判断： numberOfRenewsPerMinThreshold > 0 && getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold getNumOfRenewsInLastMin即最后一分钟接收到的心跳总数，numberOfRenewsPerMinThreshold 表示收到一分钟内收到服务心跳数临界值（后简称临界值），也就是说当临界值大于0，且最后一分钟接收到的心跳总数大于临界值时，允许实例过期，他的计算方式源码如下： protected void updateRenewsPerMinThreshold() { this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds()) * serverConfig.getRenewalPercentThreshold()); } 其中： this.expectedNumberOfClientsSendingRenews：接收到的客户端数量； serverConfig.getExpectedClientRenewalIntervalSeconds()：客户端发送心跳时间的间隔，默认是30秒； serverConfig.getRenewalPercentThreshold()：一个百分比率阈值，默认是0.85，可以通过配置修改。 从上述代码的计算方法可以看出：一分钟内收到服务心跳数临界值=客户端数量*（60/心跳时间间隔）*比率。带入默认值：一分钟内收到服务心跳数临界值 = 客户端数量 * （60/30） * 0.85 = 客户端数量 * 1.7。所以假如有总共有10个客户端，那么表示一分钟至少需要收到17次心跳。如果开启只我保护机制，那么一分钟内收到的心跳数大于一分钟内收到服务心跳数临界值时，则启用租约到期机制，即服务剔除机制。如果没有启用服务剔除机制（即开启了自我保护机制或者一分钟收到的心跳数小于临界值），那么直接return结束，不做任何操作。否则代码继续运行，从代码的第9行注释到最后，可以看出先跳出已过期的服务实例，然后通过随机数的方式将这些已过期的实例进行剔除。 总结 心跳机制 客户端启动后，就会启动一个定时任务，定时向服务端发送心跳数据，告知服务端自己还活着，默认的心跳时间间隔是30秒。 服务剔除机制 如果开启了自我保护机制，那么所有的服务，包括长时间没有收到心跳的服务（即已过期的服务）都不会被剔除。 如果未开启自我保护机制，那么将判断最后一分钟收到的心跳数与一分钟收到心跳数临界值比较，如果前者大于后者，且后者大于0的话，则启用服务剔除机制。 一旦服务剔除机制开启，则Eureka服务端并不会直接剔除所有已过期的服务，而是通过随机数的方式进行剔除，避免自我保护开启之前将所有的服务（包括正常的服务）给剔除。 Eureka自我保护机制是什么？ 在分布式系统的CAP理论中，Eureka采用的AP，也就是Eureak保证了服务的可用性（A），而舍弃了数据的一致性（C）。当网络发生分区时，客户端和服务端的通讯将会终止，那么服务端在一定的时间内将收不到大部分的客户端的一个心跳，如果这个时候将这些收不到心跳的服务剔除，那可能会将可用的客户端剔除了，这就不符合AP理论。 "},"pages/Dubbo.html":{"url":"pages/Dubbo.html","title":"Dubbo","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Dubbo是什么？ Dubbo的主要应用场景？ Dubbo的核心功能？ Dubbo的核心组件？ Dubbo支持哪些协议，每种协议的应用场景及优缺点？ Dubbo超时时间怎样设置？服务调用超时问题怎么解决？ 调用Dubbo的时候如何处理请求超时的情况？ Dubbo有些哪些注册中心？ Zookeeper挂掉了Dubbo还能继续使用吗？ Dubbo服务注册与发现的流程及其原因？ Dubbo集群的负载均衡有哪些策略？ Dubbo的整体架构设计有哪些分层？ Dubbo为什么需要服务治理？ Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？ Dubbo的集群容错方案有哪些？ Dubbo支持哪些序列化方式？ Dubbo在安全机制方面是如何解决？ Dubbo通信协议Dubbo协议为什么要消费者比提供者个数多？ Dubbo通信协议Dubbo协议为什么不能传大包？ Dubbo通信协议Dubbo协议为什么采用异步单一长连接？ Dubbo Dubbo是什么？ Dubbo是一个分布式、高性能、透明化的RPC服务框架，提供服务自动注册、自动发现等高效服务治理方案，可以和Spring框架无缝集成。 Dubbo的主要应用场景？ 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。 Dubbo的核心功能？ 核心功能 解释 Remoting(网络通信框架) 提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。 Cluster(服务框架) 提供基于接口方法的透明远程过程调用，包括多协议支持、以及软负载均衡、失败容错、地址路由、动态配置等集群支持。 Registry(服务注册) 基于注册中心目录服务，使服务消费方能动态的查找服务提供方。使地址透明，使服务提供方可以平滑增加或减少机器。 Dubbo的核心组件？ 核心组件 说明 Provider 暴露服务的服务提供方。 Consumer 调用远程服务的服务消费方。 Registry 服务注册与发现的注册中心。 Monitor 统计服务的调用次数和调用时间的监控中心。 Container 服务运行容器。 Dubbo支持哪些协议，每种协议的应用场景及优缺点？ 协议 应用场景 dubbo(默认) 单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步Hessian序列化。 rmi 采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议TCP。多个短连接，TCP协议传输，同步传输，适用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞。 webservice 基于WebService的远程调用协议，集成CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系统集成和跨语言调用。 http 基于Http表单提交的远程调用协议，使用Spring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用。 hessian 集成Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供与Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。 memcache 基于memcached实现的RPC协议。 redis 基于redis实现的RPC协议。 Dubbo超时时间怎样设置？服务调用超时问题怎么解决？ 名称 解释 服务提供者端设置超时时间 在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。 服务消费者端设置超时时间 如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。 Dubbo在调用服务不成功时，默认是会重试两次的。 调用Dubbo的时候如何处理请求超时的情况？ Dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？ 对于核心的服务中心，去除Dubbo超时重试机制，并重新评估设置超时时间。业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理。 当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。 Dubbo有些哪些注册中心？ 注册中心 解释 Multicast注册中心 Multicast注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现。 Zookeeper注册中心(默认) 基于分布式协调系统Zookeeper实现，采用Zookeeper的watch机制实现数据变更。 Redis注册中心 基于Redis实现，采用key/Map存储，主key存储服务名和类型，Map中key存储服务URL，value存储服务过期时间。基于redis的发布/订阅模式通知数据变更。 Zookeeper挂掉了Dubbo还能继续使用吗？ 监控中心宕掉不影响使用，只是丢失部分采样数据。 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务。 注册中心对等集群，任意一台宕掉后，将自动切换到另一台。 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯。 服务提供者无状态，任意一台宕掉后，不影响使用。 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复。 Dubbo服务注册与发现的流程及其原因？ 流程说明 Provider(提供者)绑定指定端口并启动服务。 指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储。 Consumer(消费者)，连接注册中心，并发送应用信息、所求服务信息至注册中心。 注册中心根据消费者所求服务信息匹配对应的提供者列表发送至Consumer应用缓存。 Consumer在发起远程调用时基于缓存的消费者列表择其一发起调用。 Provider状态变更会实时通知注册中心、在由注册中心实时推送至Consumer。 设计的原因 Consumer与Provider解偶，双方都可以横向增减节点数。 注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台。 去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用。 服务提供者无状态，任意一台宕掉后，不影响使用。 Dubbo集群的负载均衡有哪些策略？ 策略 解释 Random LoadBalance 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。 RoundRobin LoadBalance 轮循选取提供者策略，平均分布，但是存在请求累积的问题。 LeastActive LoadBalance 最少活跃调用策略，解决慢提供者接收更少的请求。 ConstantHash LoadBalance 一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。 Dubbo的整体架构设计有哪些分层？ 分层结构 说明 服务接口层(Service) 该层与业务逻辑相关，根据provider和consumer的业务设计对应的接口和实现。 配置层(Config) 对外配置接口，以ServiceConfig和ReferenceConfig为中心。 服务代理层(Proxy) 服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton。 服务注册层(Registry) 封装服务地址的注册与发现，以服务URL为中心。 路由层(Cluster) 封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。 集群层(Cluster) 封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心。 监控层(Monitor) RPC调用次数和调用时间监控。 远程调用层(Protocol) 封装RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。 信息交换层(Exchange) 封装请求响应模式，同步转异步，以Request和Response为中心。 网络传输层(Transport) 抽象mina和netty为统一接口，以Message 为中心。 Dubbo为什么需要服务治理？ 过多的服务URL配置困难。 负载均衡分配节点压力过大的情况下也需要部署集群。 服务依赖混乱，启动顺序不清晰。 过多服务导致性能指标分析难度较大，需要监控。 Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？ 可以的，启动Dubbo时，消费者会从Zookeeper拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。 Dubbo的集群容错方案有哪些？ 容错方案 解释 Failover Cluster(默认) 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。 Failfast Cluster 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 Failsafe Cluster 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 Failback Cluster 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 Forking Cluster 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks=\"2\"来设置最大并行数。 Broadcast Cluster 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。 Dubbo支持哪些序列化方式？ 默认使用Hessian序列化，还有Dubbo、FastJson、Java自带序列化。 Dubbo在安全机制方面是如何解决？ Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。Dubbo还提供服务黑白名单，来控制服务所允许的调用方。 Dubbo通信协议Dubbo协议为什么要消费者比提供者个数多？ 因为Dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡。 Dubbo通信协议Dubbo协议为什么不能传大包？ 因为Dubbo协议采用单一长连接，如果每次请求的数据包大小为500KByte，假设网络为千兆网卡(1024Mbit=128MByte)，每条连接最大7MByte(不同的 环境可能不一样，供参考)，单个服务提供者的TPS(每秒处理事务数)最大为:128MByte/500KByte=262。单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为:7MByte/500KByte=14。如果能接受，可以考虑使用，否则网络将成为瓶颈。 Dubbo通信协议Dubbo协议为什么采用异步单一长连接？ 因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务，比如Morgan的提供者只有6台提供者，却有上百台消费者，每天有1.5亿次调用。如果采用常规的hessian服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接减少连接握手验证等，并使用异步IO复用线程池防止C10K问题。 "},"pages/MicroService.html":{"url":"pages/MicroService.html","title":"微服务","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 你们的系统使用了哪种服务框架？为什么要这样技术选型？ 如果让你设计一个RPC框架，该从哪些方向考虑？ 能画一张图说说Spring Cloud的核心架构吗？它又是如何调用的？ 你们的服务注册中心进行过选型调研吗？对比一Eureka和Zookeeper？ 你们对网关的技术选型是怎么考虑的？能对比一下各种网关的优劣吗？ 如果系统访问量比现在增加10倍，你们考虑过系统的扩容方案吗？ 唯一ID生成机制中的snowflake算法的时钟回拨问题如何解决？ 分布式的“有状态”和“无状态”？ Skywalking中的traceId是如何在服务之间传递的？ Apollo配置中心动态生效实现原理？ 微服务 你们的系统使用了哪种服务框架？为什么要这样技术选型？ ———— Spring Cloud Dubbo 并发性能 使用的是HTTP协议，性能与Dubbo对比稍微差点。 是一款优秀的RPC框架，并发能力比Spring Cloud强。 注册中心 有全家桶配置中心: eureka nacos，亦可以选择Zookeeper。 一般选择Zookeeper。 分布式配置中心 nacos / Spring Cloud Config Apollo 网关 Zuul / Spring Cloud Gateway 需引入其他网关组件 负载均衡 ribbon 自带负载均衡 熔断功能 hystrix 需引入其他熔断框架 社区活跃度 活跃，版本更新快 不活跃 如果让你设计一个RPC框架，该从哪些方向考虑？ 要点 解释 服务发现与服务注册 1.如果我们想在Service A中调用Service B，那么我们首先得知道Service B的地址。所以，我们需要有一个服务注册中心，通过这个中心，服务可以把自己的信息注册进来，也可以获取到别的服务的信息； 2.客户端也需要watch服务注册中心的目标服务的地址的变化。 网络通信 1.服务和服务之间的网络通信模型， NIO/IO等等； 2.客户端如何复用与服务端的连接， 而不是每次请求都重新创建一个新连接； 3.客户端收到返回后，如何知道是哪个请求的返回并且做出正确处理。 消息的序列化 服务间通信的消息通过什么方式进行序列化？Hessian，XML、JSON、Protobuf…，甚至Java原生的序列化方式，你总得选择一个。 负载均衡 客户端通过服务注册中心拿到一堆地址，该调哪个呢？最简单的方式，可以通过RR、WRR的方式去做LB。 容灾 1.健康监测：在某一个服务节点挂掉的时候， 如何在服务注册中心删去这个服务地址？ 2.服务调用超时与重试：在调用一个服务实例的时候，如果超时或者报错，怎么处理？ 3.服务限流：如何限制最大并发数？这个又可以从客户端和服务端两个角度分析。 能画一张图说说Spring Cloud的核心架构吗？它又是如何调用的？ 首先每个服务启动的时候都需要往注册中心进行注册。 用户先对网关发起下单请求，网关收到请求后发现呃，是下单操作，要到订单系统，然后把请求路由到订单系统。 订单系统啪啦啪啦一顿操作，然后通过Feign去调用库存系统减库存，通知仓储服务发货，调用积分系统加积分。 在发起调用之前，订单系统还得通过Ribbon去注册中心去拉取各系统的注册表信息，并且挑一台机器给Feign来发起网络调用。 你们的服务注册中心进行过选型调研吗？对比一Eureka和Zookeeper？ Zookeeper基于CP，不保证高可用，如果Zookeeper正在选主，或者Zookeeper集群中半数以上机器不可用，那么将无法获得数据。Eureka基于AP，能保证高可用，即使所有机器都挂了，也能拿到本地缓存的数据。作为注册中心，其实配置是不经常变动的，只有发版和机器出故障时会变。对于不经常变动的配置来说，CP是不合适的，而AP在遇到问题时可以用牺牲一致性来保证可用性，既返回旧数据，缓存数据。所以理论上Eureka是更适合作注册中心。而现实环境中大部分项目可能会使用Zookeeper，那是因为集群不够大，并且基本不会遇到用做注册中心的机器一半以上都挂了的情况。所以实际上也没什么大问题。 你们对网关的技术选型是怎么考虑的？能对比一下各种网关的优劣吗？ 动态路由 新开发某个服务，动态把请求路径和服务的映射关系热加载到网关里去；服务增减机器，网关自动热感知。 灰度发布 授权认证 性能监控 每个API接口的耗时、成功率、QPS。 系统日志 数据缓存 限流熔断 ———— Zuul1.x Spring Cloud Gateway 实现 基于Servlet2.x构建，使用阻塞的API。 基于Spring 5、Project Reactor、Spring Boot 2，使用非阻塞式的API。 长连接 不支持 支持 不适用场景 后端服务响应慢或者高并发场景下，因为线程数量是固定(有限)的，线程容易被耗尽，导致新请求被拒绝。 中小流量的项目，使用Zuul1.x更合适。 限流 无 内置限流过滤器 上手难度 同步编程，上手简单。 门槛较高，上手难度中等。 Spring Cloud集成 是 是 Sentinel集成 是 是 技术栈沉淀 Zuul1开源近七年，经受考验，稳定成熟。 未见实际落地案例。 Github used by 1007 repositories 102 repositories Github issues 88 Open / 2736 Closed 135 Open / 850 Closed 官方性能对比 2.09k / 12.56ms 3.24k / 6.61ms Zuul1的开源时间很早，Netflix、Riot、携程、拍拍贷等公司都已经在生产环境中使用，自身经受了实践考验，是生产级的API网关产品。Gateway在2019年离开Spring Cloud孵化器，应用于生产的案例少，稳定性有待考证。从性能方面比较，两种产品在流量小的场景下性能表现差不多；并发高的场景下Gateway性能要好很多。从开发方面比较，Zuul1编程模型简单，易于扩展；Gateway编程模型稍难，代码阅读难度要比Zuul高不少，扩展也稍复杂一些。 如果系统访问量比现在增加10倍，你们考虑过系统的扩容方案吗？ 方案 解释 网关 横向加机器 注册中心 纵向升配置 数据库 纵向升配置 网关直接多部署10倍的机器即可，前面的Nginx做会负载均衡，把流量均匀分发给各个网关机器。服务扩容，都很简单的，多加机器，部署启动，自动注册到注册中心去。此时其他服务会自动感知到你的服务多加了一些机器。服务实例变多了10倍，此时几十个服务实例，几百个服务实例，对eureka机器会造成每秒几百请求，没问题，eureka机器，8核16G的配置，单机抗上千请求，很轻松。数据库本来是每秒几百请求，10倍，每秒高峰期是三四千请求，横向扩容很麻烦，此时可以考虑给单个数据库部署的机器提高配置，32核128G高配物理机，每秒钟抗几千请求问题不大。 唯一ID生成机制中的snowflake算法的时钟回拨问题如何解决？ 首先, snowflake的末尾12位是序列号, 用来记录同一毫秒内产生的不同id, 同一毫秒总共可以产生4096个id, 每一毫秒的序列号都是从0这个基础序列号开始递增假设我们的业务系统在单机上的QPS为3w/s, 那么其实平均每毫秒只需要产生30个id即可, 远没有达到设计的4096, 也就是说通常情况下序列号的使用都是处在一个低水位, 当发生时钟回拨的时候, 这些尚未被使用的序号就可以派上用场了。因此, 可以对给定的基础序列号稍加修改, 后面每发生一次时钟回拨就将基础序列号加上指定的步长, 例如开始时是从0递增, 发生一次时钟回拨后从1024开始递增, 再发生一次时钟回拨则从2048递增, 这样还能够满足3次的时钟回拨到同一时间点(发生这种操作就有点扯了)。 分布式的“有状态”和“无状态”？ 无状态 有状态 对单次请求的处理不依赖其他请求。也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到(比如说数据库)，服务器本身不存储任何信息。 它会在自身保存一些数据，先后的请求是有关联的。 单体条件下面，服务只有一个，因此状态每个时刻也就只有一种状态。在分布式集群环境下面，就存在一个状态同步问题，因此也有有状态服务设计和无状态服务设计。比如session，如果session保存在每一台服务器上，那么就是有状态设计，可能会出现集群内，服务状态不一致的现象；如果session由专门的一台服务器来保存，就是无状态设计，服务不保存状态，需要的时候从同一的服务器中获取，保证了服务在任何时刻的状态一致。 有状态的服务，会有比较明显的缺点，服务间数据需要同步，成为副本关系，逻辑复杂也浪费资源 ；无状态的应用服务器，不保存上下文信息，只负责对用户的每次请求提交数据进行处理然后返回处理结果 无状态应用服务器之间是对等的关系，无依赖，请求到哪个服务器，处理结果都一样的。 Skywalking中的traceId是如何在服务之间传递的？ 👉 基于trace_id链路追踪 Apollo配置中心动态生效实现原理？ 👉 Apollo配置中心动态生效实现原理 👉 携程开源配置中心Apollo的设计与实现 Apollo配置中心动态生效机制，是基于http长轮询请求和Spring扩展机制实现的。在Spring容器启动过程中，Apollo通过自定义的BeanPostProcessor和BeanFactoryPostProcessor将参数中包含${...}占位符和@Value注解的Bean注册到Apollo框架中定义的注册表中。然后通过http长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo会根据变化的配置key找到对应的Bean，然后修改Bean的属性，从而实现了配置动态生效的特性。 "},"pages/Arithmetic.html":{"url":"pages/Arithmetic.html","title":"算法专题","keywords":"","body":" 数据结构 贪心算法 动态规划 二叉搜索树 DFS BFS 滑动窗口 双指针 区间调度 单调栈/队列 阶乘 二分法查找 水塘抽样 位操作 综合 "},"pages/DataStructure.html":{"url":"pages/DataStructure.html","title":"数据结构","keywords":"","body":"数据结构 反转链表II 解法 // todo "},"pages/arithmetic/Greedy.html":{"url":"pages/arithmetic/Greedy.html","title":"贪心算法","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 无重叠区间 用最少数量的箭引爆气球 跳跃游戏 跳跃游戏 II 贪心算法 无重叠区间 解法 class Solution { public int eraseOverlapIntervals(int[][] intervals) { return intervals.length - intervalSchedule(intervals); } private int intervalSchedule(int[][] intervals) { if (intervals.length == 0) { return 0; } Arrays.sort(intervals, Comparator.comparingInt(o -> o[1])); int count = 1; int xEnd = intervals[0][1]; for (int[] interval : intervals) { int start = interval[0]; if (start >= xEnd) { count++; xEnd = interval[1]; } } return count; } } 用最少数量的箭引爆气球 解法 class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) { return 0; } Arrays.sort(points, Comparator.comparingInt(o -> o[1])); int count = 1; int xEnd = points[0][1]; for (int[] point : points) { int start = point[0]; if (start > xEnd) { count++; xEnd = point[1]; } } return count; } } 跳跃游戏 解法 class Solution { public boolean canJump(int[] nums) { int n = nums.length; int farthest = 0; for (int i = 0; i = n - 1; } } 跳跃游戏 II 解法 class Solution { public int jump(int[] nums) { int n = nums.length; int end = 0, farthest = 0; int jumps = 0; for (int i = 0; i "},"pages/arithmetic/DynamicProgramming.html":{"url":"pages/arithmetic/DynamicProgramming.html","title":"动态规划","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 动态规划 斐波那契数列 凑零钱问题 目标和 最长递增子序列 俄罗斯套娃信封问题 最大子序和 最长公共子序列 分割等和子集 零钱兑换 II 石子游戏 四键键盘 正则表达式匹配 鸡蛋掉落 戳气球 买卖股票的最佳时机 实现strStr() 编辑距离 动态规划 动态规划 基本模板 // 初始化base dp[0][0][...] = base // 进行状态转移 for 状态1 in 状态1的所有取值: for 状态2 in 状态2的所有取值: for ... dp[状态1][状态2][...] = 求最值(选择1, 选择2...) 斐波那契数列 解法一 class Solution { public int fib(int N) { if (N memory = new HashMap<>(2); return helper(memory, N); } private Integer helper(Map memory, int n) { if (n == 1 || n == 2) { return 1; } if (memory.get(n) != null) { return memory.get(n); } memory.put(n, helper(memory, n - 1) + helper(memory, n - 2)); return memory.get(n); } } 解法二 class Solution { public int fib(int N) { if (N == 0) { return 0; } if (N == 1 || N == 2) { return 1; } int[] dp = new int[N + 1]; dp[1] = dp[2] = 1; for (int i = 3; i 解法三 class Solution { public int fib(int N) { if (N == 0) { return 0; } if (N == 1 || N == 2) { return 1; } int prev = 1, cur = 1; for (int i = 3; i 凑零钱问题 解法一 class Solution { private Map dpMap = new HashMap<>(); public int coinChange(int[] coins, int amount) { return dp(coins, amount); } private int dp(int[] arr, int n) { if (n == 0) { return 0; } if (n 解法二 class Solution { public int coinChange(int[] coins, int amount) { int[] dpTable = new int[amount + 1]; Arrays.fill(dpTable, amount + 1); dpTable[0] = 0; for (int i = 0; i 目标和 解法一(回溯法) class Solution { private int result = 0; public int findTargetSumWays(int[] nums, int S) { if (nums.length == 0) { return 0; } backtrack(nums, 0, S); return result; } private void backtrack(int[] nums, int i, int rest) { if (i == nums.length) { if (rest == 0) { result++; } return; } rest += nums[i]; backtrack(nums, i + 1, rest); rest -= nums[i]; rest -= nums[i]; backtrack(nums, i + 1, rest); rest += nums[i]; } } 解法二(动态规划) class Solution { Map dpMap = new HashMap<>(); public int findTargetSumWays(int[] nums, int S) { if (nums.length == 0) { return 0; } return dp(nums, 0, S); } private int dp(int[] nums, int i, int rest) { if (i == nums.length) { if (rest == 0) { return 1; } return 0; } String key = i + \",\" + rest; if (dpMap.containsKey(key)) { return dpMap.get(key); } int result = dp(nums, i + 1, rest - nums[i]) + dp(nums, i + 1, rest + nums[i]); dpMap.put(key, result); return result; } } 最长递增子序列 解法 class Solution { public int lengthOfLIS(int[] nums) { int[] dp = new int[nums.length]; Arrays.fill(dp, 1); for (int i = 0; i nums[j]) { dp[i] = Math.max(dp[i], dp[j] + 1); } } } int res = 0; for (int value : dp) { res = Math.max(res, value); } return res; } } 俄罗斯套娃信封问题 解法 class Solution { public int maxEnvelopes(int[][] envelopes) { int length = envelopes.length; Arrays.sort(envelopes, (o1, o2) -> o1[0] == o2[0] ? (o2[1] - o1[1]) : (o1[0] - o2[0])); int[] height = new int[length]; for (int i = 0; i = poker) { right = mid; } else { left = mid + 1; } } if (left == piles) { piles++; } top[left] = poker; } return piles; } } 最大子序和 解法一 class Solution { public int maxSubArray(int[] nums) { int length = nums.length; if (length == 0) { return 0; } int[] dp = new int[length]; dp[0] = nums[0]; for (int i = 1; i 解法二 class Solution { public int maxSubArray(int[] nums) { int length = nums.length; if (length == 0) { return 0; } int cur = nums[0]; int next, res = cur; for (int i = 1; i 最长公共子序列 解法一 class Solution { private Map dpMap = new HashMap<>(2); public int longestCommonSubsequence(String text1, String text2) { return dp(text1.toCharArray(), text2.toCharArray(), text1.length() - 1, text2.length() - 1); } private int dp(char[] str1, char[] str2, int i, int j) { if (i == -1 || j == -1) { return 0; } if (dpMap.containsKey(i + \"-\" + j)) { return dpMap.get(i + \"-\" + j); } int res; if (str1[i] == str2[j]) { res = dp(str1, str2, i - 1, j - 1) + 1; } else { res = Math.max(dp(str1, str2, i - 1, j), dp(str1, str2, i, j - 1)); } dpMap.put(i + \"-\" + j, res); return res; } } 解法二 class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); // 构建 DP table 和 base case // dp[i][j] 表示： 字符串 str1[0:i] 和字符串 str2[0:j] 的最大公共子序列 int[][] dp = new int[m + 1][n + 1]; // 进行状态转移 for (int i = 1; i 分割等和子集 解法 class Solution { public boolean canPartition(int[] nums) { int sum = 0; for (int num : nums) { sum += num; } if (sum % 2 != 0) { return false; } int length = nums.length; sum /= 2; boolean[][] dp = new boolean[length + 1][sum + 1]; for (int i = 0; i 零钱兑换 II 解法 class Solution { public int change(int amount, int[] coins) { int length = coins.length; int[][] dp = new int[length + 1][amount + 1]; for (int i = 0; i = 0) { dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[length][amount]; } } 石子游戏 解法 class Solution { public boolean stoneGame(int[] piles) { int n = piles.length; int[][][] dp = new int[n][n][2]; for (int i = 0; i right) { dp[j][k][0] = left; dp[j][k][1] = dp[j + 1][k][0]; } else { dp[j][k][0] = right; dp[j][k][1] = dp[j][k - 1][0]; } } } int[] res = dp[0][n - 1]; return res[0] - res[1] > 0; } } 四键键盘 解法 // todo 正则表达式匹配 解法 // todo 鸡蛋掉落 解法 class Solution { public int superEggDrop(int K, int N) { int[][] dp = new int[N + 1][K + 1]; for (int i = 0; i broken) { left = mid + 1; } else { right = mid; } } return Math.max(dp[right - 1][eggs - 1], dp[floors - right][eggs]) + 1; } } 戳气球 解法 // todo 买卖股票的最佳时机 解法 class Solution { public int maxProfit(int[] prices) { if (prices.length == 0) { return 0; } int n = prices.length; int[][] dp = new int[n][2]; for (int i = 0; i 实现strStr() 解法 class Solution { class KMP { private int[][] dp; private String pat; public KMP(String pat) { this.pat = pat; int M = pat.length(); dp = new int[M][256]; dp[0][pat.charAt(0)] = 1; int X = 0; for (int j = 1; j 编辑距离 解法一 class Solution { private Map dpMap = new HashMap<>(); public int minDistance(String word1, String word2) { return dp(word1.toCharArray(), word2.toCharArray(), word1.length() - 1, word2.length() - 1); } private int dp(char[] word1, char[] word2, int i, int j) { if (i == -1) { return j + 1; } if (j == -1) { return i + 1; } if (dpMap.containsKey(i + \"-\" + j)) { return dpMap.get(i + \"-\" + j); } int res; if (word1[i] == word2[j]) { res = dp(word1, word2, i - 1, j - 1); } else { res = Math.min(dp(word1, word2, i, j - 1) + 1, Math.min(dp(word1, word2, i - 1, j) + 1, dp(word1, word2, i - 1, j - 1) + 1)); } dpMap.put(i + \"-\" + j, res); return res; } } 解法二 class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i "},"pages/arithmetic/BinarySearchTree.html":{"url":"pages/arithmetic/BinarySearchTree.html","title":"二叉搜索树","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 二叉搜索树 验证 相同的树 搜索 删除 插入 二叉搜索树 二叉搜索树 定义 二叉搜索树(Binary Search Tree，简称BST)是一种很常用的二叉树。它定义 一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右 边子树的所有节点的值。 基本模板 void traverse(TreeNode root) { // root 需要做什么？在这做。 // 其他的不用 root 操心，抛给框架 traverse(root.left); traverse(root.right); } TreeNode类 public class TreeNode { public int val; public TreeNode left; public TreeNode right; public TreeNode() { } public TreeNode(int x) { val = x; } public TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } 验证 解法 public boolean isValidBST(TreeNode root) { return isValidBST(root, null, null); } Boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) { if (root == null) { return true; } if (min != null && root.val = max.val) { return false; } return isValidBST(root.left, min, root) && isValidBST(root.right, root, max); } 相同的树 解法 public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null && q == null) { return true; } if (p == null || q == null) { return false; } if (p.val != q.val) { return false; } return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); } 搜索 解法 public TreeNode searchBST(TreeNode root, int val) { if (root == null) { return null; } if (root.val == val) { return root; } else if (root.val val) { root = searchBST(root.left, val); } return root; } 删除 解法 public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } if (root.val == key) { if (root.left == null) { return root.right; } if (root.right == null) { return root.left; } TreeNode minNode = getMinNode(root.right); root.val = minNode.val; root.right = deleteNode(root.right, minNode.val); } else if (root.val > key) { root.left = deleteNode(root.left, key); } else if (root.val 插入 解法 public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } if (root.val val) { root.left = insertIntoBST(root.left, val); } return root; } "},"pages/arithmetic/DFS.html":{"url":"pages/arithmetic/DFS.html","title":"DFS","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 回溯法 全排列 全排列II 子集 子集II 组合 组合II N皇后 DFS 回溯法 基本模板 List result = []; public void backtrack(路径, 选择列表) { if (满足结束条件) { result.add(路径); return; } for (选择 in 选择列表) { 做选择; backtrack(路径, 选择列表); 撤销选择; } } 全排列 解法 class Solution { private List> res = new ArrayList<>(); public List> permute(int[] nums) { LinkedList track = new LinkedList<>(); backtrack(nums, track); return res; } private void backtrack(int[] nums, LinkedList track) { if (track.size() == nums.length) { res.add(new LinkedList<>(track)); return; } for (int num : nums) { if (track.contains(num)) { continue; } track.add(num); backtrack(nums, track); track.removeLast(); } } } 全排列II 解法 // https://leetcode-cn.com/problems/permutations-ii/ 子集 解法 class Solution { private List> list = new ArrayList<>(); public List> subsets(int[] nums) { LinkedList track = new LinkedList<>(); backtrack(0, nums, track); return list; } private void backtrack(int i, int[] nums, LinkedList track) { list.add(new ArrayList<>(track)); for (int j = i; j 子集II 解法 // https://leetcode-cn.com/problems/subsets-ii/ 组合 解法 class Solution { private List> combineList = new ArrayList<>(); public List> combine(int n, int k) { backtrack(1, n, k, new LinkedList<>()); return combineList; } private void backtrack(int i, int n, int k, LinkedList track) { if (track.size() == k) { combineList.add(new LinkedList<>(track)); return; } for (int j = i; j 组合II 解法 // https://leetcode-cn.com/problems/combination-sum-ii/ N皇后 解法 class Solution { private List> result = new ArrayList<>(); public List> solveNQueens(int n) { List border = new LinkedList<>(); for (int i = 0; i border, int row) { if (row == border.size()) { List temp = new ArrayList<>(border); result.add(temp); return; } int n = border.get(row).length(); for (int col = 0; col border, int row, int col) { int n = border.size(); for (int i = 0; i = 0 && j = 0 && j >= 0; i--, j--) { if (border.get(i).charAt(j) == 'Q') { return false; } } return true; } private void replace(List params, int row, int col, Character newVal) { String oldStr = params.get(row); StringBuilder sb = new StringBuilder(oldStr); sb.setCharAt(col, newVal); params.set(row, sb.toString()); } } "},"pages/arithmetic/BFS.html":{"url":"pages/arithmetic/BFS.html","title":"BFS","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 BFS算法 二叉树的最小深度 打开转盘锁 BFS BFS算法 基本模板 // 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue q; // 核心数据结构 Set visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i 二叉树的最小深度 解法 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue queue = new LinkedList<>(); queue.offer(root); int depth = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i 打开转盘锁 解法 class Solution { private String plusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '9') { ch[j] = '0'; } else { ch[j] += 1; } return new String(ch); } private String minusOne(String s, int j) { char[] ch = s.toCharArray(); if (ch[j] == '0') { ch[j] = '9'; } else { ch[j] -= 1; } return new String(ch); } public int openLock(String[] deadends, String target) { Set deads = new HashSet<>(); Collections.addAll(deads, deadends); Set visited = new HashSet<>(); Queue queue = new LinkedList<>(); int step = 0; queue.offer(\"0000\"); visited.add(\"0000\"); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i "},"pages/arithmetic/SlidingWindow.html":{"url":"pages/arithmetic/SlidingWindow.html","title":"滑动窗口","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 滑动窗口 字符串的排列 最小覆盖子串 找到字符串中所有字母异位词 无重复字符的最长子串 滑动窗口 滑动窗口 基本模板 public void slidingWindow(String s, String t) { Map window = new HashMap<>(2); Map needs = new HashMap<>(2); for (int i = 0; i 字符串的排列 解法 class Solution { public boolean checkInclusion(String s1, String s2) { List res = new ArrayList<>(); int left = 0, right = 0; Map needs = new HashMap<>(2); Map window = new HashMap<>(2); for (int i = 0; i 最小覆盖子串 解法 class Solution { public String minWindow(String s, String t) { int start = 0, minLen = Integer.MAX_VALUE; int left = 0, right = 0; Map window = new HashMap<>(2); Map needs = new HashMap<>(2); for (int i = 0; i 找到字符串中所有字母异位词 解法 class Solution { public List findAnagrams(String s, String t) { List res = new ArrayList<>(); int left = 0, right = 0; Map needs = new HashMap<>(2); Map window = new HashMap<>(2); for (int i = 0; i 无重复字符的最长子串 解法 class Solution { public int lengthOfLongestSubstring(String s) { int left = 0, right = 0; Map window = new HashMap<>(2); int res = 0; while (right 1) { Character c2 = s.charAt(left); window.put(c2, window.get(c2) - 1); left++; } res = Math.max(res, right - left); } return res; } } "},"pages/arithmetic/DoublePoint.html":{"url":"pages/arithmetic/DoublePoint.html","title":"双指针","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 环形链表 环形链表II 双指针 环形链表 解法 public class Solution { static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public boolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } 环形链表II 解法 public class Solution { public ListNode detectCycle(ListNode head) { if (!this.hasCycle(head)) { return null; } ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { break; } } slow = head; while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; } private boolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; } } "},"pages/arithmetic/IntervalDispatch.html":{"url":"pages/arithmetic/IntervalDispatch.html","title":"区间调度","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 交集 并集 区间调度 交集 解法 class Solution { public int[][] intervalIntersection(int[][] A, int[][] B) { int i = 0, j = 0; List res = new ArrayList<>(); while (i = a1 && a2 >= b1) { int[] temp = new int[2]; temp[0] = Math.max(a1, b1); temp[1] = Math.min(a2, b2); res.add(temp); } if (b2 并集 解法 class Solution { public int[][] merge(int[][] intervals) { if (intervals.length == 0) { return new int[0][]; } Arrays.sort(intervals, (o1, o2) -> { if (o1[0] == o2[0]) { return o1[1] - o2[1]; } else { return o1[0] - o2[0]; } }); List res = new ArrayList<>(); int[] cur, last; res.add(intervals[0]); for (int i = 1; i "},"pages/arithmetic/MonotonousStackAndQueue.html":{"url":"pages/arithmetic/MonotonousStackAndQueue.html","title":"单调栈/队列","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 单调栈 下一个更大元素I 下一个更大元素II 滑动窗口最大值 单调栈/队列 单调栈 基本模板 public int[] nextGreaterElement(int[] nums) { int[] ans = new int[nums.length]; Stack s = new Stack<>(); for (int i = nums.length - 1; i >= 0; i--) { while (!s.isEmpty() && s.peek() 下一个更大元素I 解法 public int[] nextGreaterElement(int[] nums1, int[] nums2) { int[] convert = this.nextGreaterElement(nums2); Map convertMap = new HashMap<>(2); for (int i = 0; i 下一个更大元素II 解法 public int[] nextGreaterElement(int[] nums) { int n = nums.length; int[] ans = new int[n]; Stack s = new Stack<>(); for (int i = 2 * n - 1; i >= 0; i--) { while (!s.isEmpty() && s.peek() 滑动窗口最大值 解法 public class Solution { static class MonotonicQueue { private Deque data; MonotonicQueue() { data = new ArrayDeque<>(); } public void push(int n) { while (!data.isEmpty() && data.getLast() res = new ArrayList<>(); for (int i = 0; i "},"pages/arithmetic/Factorial.html":{"url":"pages/arithmetic/Factorial.html","title":"阶乘","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 阶乘后的零 阶乘函数后K个零 阶乘 阶乘后的零 解法 class Solution { public int trailingZeroes(int n) { int res = 0; long divisor = 5; while (divisor 阶乘函数后K个零 解法 class Solution { private long trailingZeroes(long n) { long res = 0; long divisor = 5; while (divisor target) { hi = mid; } else { hi = mid; } } return lo; } private long rightBound(int target) { long lo = 0, hi = Long.MAX_VALUE; while (lo target) { hi = mid; } else { lo = mid + 1; } } return lo - 1; } public int preimageSizeFZF(int K) { return (int) (rightBound(K) - leftBound(K) + 1); } } "},"pages/arithmetic/BinarySearch.html":{"url":"pages/arithmetic/BinarySearch.html","title":"二分法查找","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 二分法 二分查找 在排序数组中查找元素的第一个和最后一个位置 爱吃香蕉的珂珂 在 D 天内送达包裹的能力 判断子序列 二分法查找 二分法 基本模板 public class Solution { // 最基本的二分查找算法 int binarySearch(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } else if (nums[mid] == target) { return mid; } } return -1; } // 寻找左侧边界的二分查找 int leftBound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } } if (left >= nums.length || nums[left] != target) { return -1; } return left; } // 寻找右侧边界的二分查找 int rightBound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } } if (right 二分查找 解法 class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } } return -1; } } 在排序数组中查找元素的第一个和最后一个位置 解法 class Solution { public int[] searchRange(int[] nums, int target) { int[] res = new int[]{-1, -1}; res[0] = leftBound(nums, target); res[1] = rightBound(nums, target); return res; } private int leftBound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } } if (left >= nums.length || nums[left] != target) { return -1; } return left; } private int rightBound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left target) { right = mid - 1; } } if (right 爱吃香蕉的珂珂 解法 class Solution { private int timeOf(int n, int speed) { return (n / speed) + ((n % speed > 0) ? 1 : 0); } private int getMax(int[] piles) { int max = 0; for (int n : piles) { max = Math.max(n, max); } return max; } private boolean canFinish(int[] piles, int speed, int H) { int time = 0; for (int n : piles) { time += timeOf(n, speed); } return time 在 D 天内送达包裹的能力 解法 class Solution { private int getMax(int[] weights) { int max = 0; for (int n : weights) { max = Math.max(n, max); } return max; } private int getSum(int[] weights) { int sum = 0; for (int item : weights) { sum += item; } return sum; } // 如果载重为 cap，是否能在 D 天内运完货物？ private boolean canFinishCap(int[] w, int D, int cap) { int i = 0; for (int day = 0; day = 0) { i++; if (i == w.length) { return true; } } } return false; } public int shipWithinDays(int[] weights, int D) { // 载重可能的最小值 int left = getMax(weights); // 载重可能的最大值 + 1 int right = getSum(weights) + 1; while (left 判断子序列 解法 class Solution { private int leftBound(ArrayList arr, int tar) { int lo = 0, hi = arr.size(); while (lo arr.get(mid)) { lo = mid + 1; } else { hi = mid; } } return lo; } public boolean isSubsequence(String s, String t) { int m = s.length(), n = t.length(); Map> indexMap = new LinkedHashMap<>(); for (int i = 0; i new ArrayList<>()); indexMap.get(character).add(i); } int j = 0; for (int i = 0; i ) indexMap.get(character), j); if (pos == indexMap.get(character).size() || pos == -1) { return false; } j = indexMap.get(character).get(pos) + 1; } return true; } } "},"pages/arithmetic/ReservoirSampling.html":{"url":"pages/arithmetic/ReservoirSampling.html","title":"水塘抽样","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 链表随机节点 随机数索引 水塘抽样 链表随机节点 解法 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { private ListNode head; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ public Solution(ListNode head) { this.head = head; } /** Returns a random node's value. */ public int getRandom() { if (this.head == null) { return -1; } Random r = new Random(); int i = 0, res = 0; ListNode p = head; // while 循环遍历链表 while (p != null) { // 生成一个 [0, i) 之间的整数 // 这个整数等于 0 的概率就是 1/i if (r.nextInt(++i) == 0) { res = p.val; } p = p.next; } return res; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(head); * int param_1 = obj.getRandom(); */ 随机数索引 解法 class Solution { private int[] nums; public Solution(int[] nums) { this.nums = nums; } public int pick(int target) { Random random = new Random(); int n = 0; int index = 0; for(int i = 0;i "},"pages/arithmetic/BitManipulation.html":{"url":"pages/arithmetic/BitManipulation.html","title":"位操作","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 基本位操作 位1的个数 2的幂 位操作 基本位操作 利用或操作“|”和空格将英文字符转换为小写 ('a' | ' ') = 'a'; ('A' | ' ') = 'a'; 利用与操作“&”和下划线将英文字符转换为大写 ('b' & '_') = 'B' ('B' & '_') = 'B' 利用异或操作“^”和空格进行英文字符大小写互换 ('d' ^ ' ') = 'D' ('D' ^ ' ') = 'd' 判断两个数是否异号 int x = -1, y = 2; bool f = ((x ^ y) 不用临时变量交换两个数 int a = 1, b = 2; a ^= b; b ^= a; a ^= b; // 现在 a = 2, b = 1 加一 int n = 1; n = -~n; // 现在 n = 2 减一 int n = 2; n = ~-n; // 现在 n = 1 位1的个数 解法 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int res = 0; while (n != 0) { n = n & (n - 1); res++; } return res; } } 2的幂 解法 class Solution { public boolean isPowerOfTwo(int n) { if (n "},"pages/arithmetic/Composite.html":{"url":"pages/arithmetic/Composite.html","title":"综合","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 LRU缓存机制 字符串相乘 计数质数 超级次方 接雨水 K个一组翻转链表 回文链表 找到所有数组中消失的数字 错误的集合 有效的括号 Nim游戏 灯泡开关 和为K的子数组 煎饼排序 综合 LRU缓存机制 解法 public class LRUCache { class DLinkedNode { int key; int value; DLinkedNode prev; DLinkedNode next; public DLinkedNode() { } public DLinkedNode(int key, int value) { this.key = key; this.value = value; } } private Map cache = new HashMap<>(); private int size; private int capacity; private DLinkedNode head, tail; public LRUCache(int capacity) { this.size = 0; this.capacity = capacity; head = new DLinkedNode(); tail = new DLinkedNode(); head.next = tail; tail.prev = head; } private void addToHead(DLinkedNode node) { node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; } private void removeNode(DLinkedNode node) { node.prev.next = node.next; node.next.prev = node.prev; } private void modeToHead(DLinkedNode node) { removeNode(node); addToHead(node); } private DLinkedNode removeTail() { DLinkedNode node = tail.prev; removeNode(node); return node; } public int get(int key) { DLinkedNode node = cache.get(key); if (node == null) { return -1; } modeToHead(node); return node.value; } public void put(int key, int value) { DLinkedNode node = cache.get(key); if (node == null) { DLinkedNode newNode = new DLinkedNode(key, value); cache.put(key, newNode); addToHead(newNode); ++size; if (size > capacity) { DLinkedNode tail = removeTail(); cache.remove(tail.key); --size; } } else { node.value = value; modeToHead(node); } } } 字符串相乘 解法 class Solution { public String multiply(String num1, String num2) { int m = num1.length(), n = num2.length(); int[] res = new int[m + n]; for (int i = m - 1; i >= 0; i--) { for (int j = n - 1; j >= 0; j--) { int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + res[p2]; res[p2] = sum % 10; res[p1] += sum / 10; } } int i = 0; while (i 计数质数 解法 class Solution { public int countPrimes(int n) { boolean[] isPrim = new boolean[n]; Arrays.fill(isPrim, true); for (int i = 2; i * i 超级次方 解法 class Solution { private int base = 1337; private int myPow(int a, int k) { a %= base; int res = 1; for (int i = 0; i 接雨水 暴力解法 class Solution { public int trap(int[] height) { int n = height.length; int ans = 0; for (int i = 1; i = 0; j--) { leftMax = Math.max(leftMax, height[j]); } ans += Math.min(leftMax, rightMax) - height[i]; } return ans; } } 备忘录解法 class Solution { public int trap(int[] height) { if (height.length == 0) { return 0; } int n = height.length; int ans = 0; int[] leftMax = new int[n]; int[] rightMax = new int[n]; leftMax[0] = height[0]; rightMax[n - 1] = height[n - 1]; for (int i = 1; i = 0; i--) { rightMax[i] = Math.max(height[i], rightMax[i + 1]); } for (int i = 1; i K个一组翻转链表 解法 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { private ListNode reverse(ListNode a, ListNode b) { ListNode prev, cur, next; prev = null; cur = a; // while 终止的条件改一下就行了 while (cur != b) { next = cur.next; cur.next = prev; prev = cur; cur = next; } // 返回反转后的头结点 return prev; } public ListNode reverseKGroup(ListNode head, int k) { if (head == null) { return null; } // 区间 [a, b) 包含 k 个待反转元素 ListNode a, b; a = b = head; for (int i = 0; i 回文链表 解法 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ListNode slow, fast; slow = fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } if (fast != null) { slow = slow.next; } ListNode left = head; ListNode right = reverse(slow); while (right != null) { if (left.val != right.val) { return false; } left = left.next; right = right.next; } return true; } private ListNode reverse(ListNode a) { ListNode prev, cur, next; prev = null; cur = a; while (cur != null) { next = cur.next; // 逐个结点反转 cur.next = prev; // 更新指针位置 prev = cur; cur = next; } // 返回反转后的头结点 return prev; } } 找到所有数组中消失的数字 解法 class Solution { public List findDisappearedNumbers(int[] nums) { for (int i = 0; i 0) { nums[newIndex] *= -1; } } List result = new LinkedList<>(); for (int i = 1; i 0) { result.add(i); } } return result; } } 错误的集合 解法 class Solution { public int[] findErrorNums(int[] nums) { int n = nums.length; int dup = -1; for (int i = 0; i 0) { missing = i + 1; } } return new int[]{dup, missing}; } } 有效的括号 解法 class Solution { public boolean isValid(String s) { Stack left = new Stack<>(); for (int i = 0; i Nim游戏 解法 class Solution { public boolean canWinNim(int n) { return n % 4 != 0; } } 灯泡开关 解法 class Solution { public int bulbSwitch(int n) { return (int)Math.sqrt(n); } } 和为K的子数组 解法 class Solution { public int subarraySum(int[] nums, int k) { int n = nums.length; int[] sum = new int[n + 1]; sum[0] = 0; for (int i = 0; i 煎饼排序 解法 class Solution { private List res = new LinkedList<>(); public List pancakeSort(int[] arr) { sort(arr, arr.length); return res; } private void sort(int[] cakes, int n) { if (n == 1) { return; } int maxCake = 0; int maxCakeIndex = 0; for (int i = 0; i maxCake) { maxCakeIndex = i; maxCake = cakes[i]; } } reverse(cakes, 0, maxCakeIndex); res.add(maxCakeIndex + 1); reverse(cakes, 0, n - 1); res.add(n); sort(cakes, n - 1); } private void reverse(int[] arr, int i, int j) { while (i "},"pages/Deploy.html":{"url":"pages/Deploy.html","title":"服务部署","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Nginx实现请求转发的方式？负载均衡的实现方式？ Tomcat的作用以及理解？ Linux常用命令 如何查看内存使用情况？ Linux如何精准匹配一个日志记录？ Linux里面如何查找指定文件某个字段？ 服务部署 Nginx实现请求转发的方式？负载均衡的实现方式？ 反向代理和负载均衡 策略 解释 代码 轮询(默认) 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 upstream backserver {   server 192.168.0.14;   server 192.168.0.15; } 指定权重 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 upstream backserver {   server 192.168.0.14 weight=10;   server 192.168.0.15 weight=10; } IP绑定 ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 upstream backserver {   ip_hash;   server 192.168.0.14:88;   server 192.168.0.15:80; } fair(第三方) 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 upstream backserver {   server server1;   server server2;   fair; } url_hash(第三方) 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 upstream backserver {   server squid1:3128;   server squid2:3128;   hash $request_uri;   hash_method crc32; } Tomcat的作用以及理解？ 当一个动态动态网页编写完成后是不能直接被别人通过浏览器访问的，要想访问此动态网页就必须让浏览器通过一段程序来访问此网页，这段程序就是服务器，他用来接受浏览器的请求，进行处理，将结果返回给浏览器。 Linux常用命令 命令 解释 man rm(rm --help) 查看帮助 cd 进入目录 ps -ef | grep java 查看进程 pstree | grep java 查看进程树 kill somePid 杀掉某进程 kill -9 $(ps -ef | grep udpserver | grep java|awk '{print $2}' ) 删除udpserver进程 rpm -aq | grep php 查看安装介质 pwd 查看当前目录 ls -l -t -l 显示详情，-t 按时间排序 ll 相当于ls -l find / -name libNativeMethod.so 等同 ll | grep someFile grep someText * 在当前目录所有文本中查找 ifconfig IP地址配置，可以使用setup命令启动字符界面来配置 chmod a+x someFile 所有用户都可以执行 chmod u+x someFile 当前用户可以执行 env 环境配置，相当window下set env | grep PATH 查看环境变量 export 相当于set classpath echo 输出变量名 netstat -npl 查看端口 lsof -i:22 查看端口进程 cp from to 拷贝文件 cp -fr ./j2sdk1.4.2_04 /usr/java 拷贝目录 mkdir 创建目录 mv 剪切或者重命名 rm -r 递归删除， -f表示force >someFile 清空文件内容 which java 查看java进程对应的目录 who 显示当前用户 如何查看内存使用情况？ procs r 列表示运行和等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。 b 列表示在等待资源的进程数，比如正在等待I/O或者内存交换等。 memory swpd 切换到内存交换区的内存数量(k表示)。如果swpd的值不为0，或者比较大，比如超过了100m，只要si、so的值长期为0，系统性能还是正常。 free 当前的空闲页面列表中内存数量(k表示)。 buff 作为buffer cache的内存数量，一般对块设备的读写才需要缓冲。 cache 作为page cache的内存数量，一般作为文件系统的cache，如果cache较大，说明用到cache的文件较多，如果此时IO中bi比较小，说明文件系统效率比较好。 swap si 由内存进入内存交换区数量。 so 由内存交换区进入内存数量。 io bi 从块设备读入数据的总量(读磁盘)(每秒kb)。 bo 块设备写入数据的总量(写磁盘)(每秒kb)。 system in 列表示在某一时间间隔中观测到的每秒设备中断数。 cs 列表示每秒产生的上下文切换次数，如当cs比磁盘I/O和网络信息包速率高得多，都应进行进一步调查。 cpu us 列显示了用户方式下所花费 CPU 时间的百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序。 sy 列显示了内核进程所花费的cpu时间的百分比。这里us+sy的参考值为80%，如果us+sy大于80%说明可能存在CPU不足。 id 列显示了cpu处在空闲状态的时间百分比。 wa 列显示了IO等待所占用的CPU时间的百分比。这里wa的参考值为30%，如果wa超过30%，说明IO等待严重，这可能是磁盘大量随机访问造成的，也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作)。 Linux如何精准匹配一个日志记录？ tail -n 10 test.log // 查询日志尾部最后10行的日志 tail -n +10 test.log // 查询10行之后的所有日志 head -n 10 test.log // 查询日志文件中的头10行日志 head -n -10 test.log // 查询日志文件除了最后10行的其他所有日志 按行号查看 // 得到关键日志的行号，例如102行 cat -n test.log |grep \"地形\" // 得到\"地形\"关键字所在的行号是102行，此时如果我想查看这个关键字前10行和后10行的日志 // tail -n +92 表示查询92行之后的日志 // head -n 20 表示在前面的查询结果里再查前20条记录 cat -n test.log | tail -n +92 | head -n 20 按日期查看 // 两个日期必须是日志中打印出来的日志，否则无效 // 可以先 grep '2014-12-17 16:17:20' test.log 确定日志中是否有该时间点 sed -n '/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p' test.log Linux里面如何查找指定文件某个字段？ grep \"search content\" filename "},"pages/Introduction.html":{"url":"pages/Introduction.html","title":"自我/项目概述","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 简单的自我介绍？ 你简单介绍一下xxx项目？ 项目的生命周期？ 项目的优化？ 你还有什么需要询问我的吗？ 自我/项目概述 简单的自我介绍？ 我是xxx，工作n年，我先后在xxx公司、yyy公司工作。先后做个xxx项目、yyy项目。 你简单介绍一下xxx项目？ 为了解决xxx问题，开发了一套xxx系统，该系统主要有那些部分组成。简单介绍项目的整体架构。参与某个模块的开发。就要求你说一下这个模块的业务及设计。 项目的生命周期？ 需求分析 概要设计 详细设计(用例图，流程图，类图) 数据库设计(powerdesigner) 代码开发(编写) 单元测试(junit白盒测试)(开发人员) SVN/GIT版本管理工具(提交，更新代码，文档) 集成测试(黑盒测试，loadrunner(编写测试脚本)(高级测试)) 上线试运行(用户自己体验) 压力测试（loadrunner） 正式上线 维护 项目的优化？ 代码优化 代码结构层次的优化(目的：更加方便代码的维护--可维护性、可读性) 代码注释(代码规范) 工具类的封装(方便代码的维护，使代码结构更加清晰不臃肿，保证团队里代码质量一致性) 公共部分的提取 代码性能的优化(目的：使程序的性能最优化) 使用一些性能比较高的类(bufferInputStream) 缓冲区块的大小(4k或者8k) 公共部分的提取 通常要用stringbuffer替代string加号拼接 业务优化(从用户体验度角度进行考虑，减少用户操作的步骤提高工作效率) 可以通过tabindex属性来改变tab键盘的操作顺序 可以通过回车键来进行搜索或者提交操作 对于单选按钮和复选按钮可以通过操作后面的文本来选择前面的单选按钮以及复选按钮 添加的信息要按照id倒序进行排列 进行搜索操作时加入js loading操作(不仅告诉用户所进行的请求正在被处理，而且防止用户多次点击提交操作) 当进行删除操作的时候要弹出提示框，警告用户要进行删除操作，是否确认 根据returnURL在用户登录成功后直接跳到想要访问的资源 进行删除操作时通过confirm提示用户是否确认删除操作，操作完后提示操作是否成功 减少用户操作的步骤 使用autocomplete插件快速进行搜索 你还有什么需要询问我的吗？ 公司要做的项目？项目中会使用一下什么技术？ 注意：经历了多轮面试后，对于你的自我介绍和项目项目经验面试官就不太关心了。你说一下你最擅长的什么？你简单说一下？最终技术面试完成后，都会让你回家等消息，或者等hr来和你谈薪资和福利。 "},"pages/InterviewSkill.html":{"url":"pages/InterviewSkill.html","title":"面试技巧","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 请你做一下自我介绍？ 你觉得你最大的优点是什么？ 说说你最大的缺点？ 你对加班的看法？ 如何安排自己的时间？会不会排斥加班？ 在五年的时间内，你的职业规划？ 你的朋友是如何评价你的？ 你还有什么要问我的吗？ 你对薪资的要求？ 为什么选择我们这家公司？ 谈谈你对跳槽的看法？ 谈谈如何适应新的工作环境？ 你来我们公司做前端可以吗？ 假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？ 请说说你对我们公司了解多少？ 请说出你选择这份工作的目的？ 你能为我们公司带来什么呢？ 怎样看待学历和能力？ 你的业余爱好是什么？ 作为被面试者请你给我打一下分？ 你怎么理解PHP这个职位？ 喜欢这份工作的哪一点？ 说说你对PHP行业和发展趋势的看法？ 对工作的期望与目标何在？ 就你申请的这个职位，你认为你还欠缺什么？ 你通常如何处理別人的批评？ 怎样对待自己的失敗？ 什么会让你有成就感？ 眼下你生活中最重要的是什么？ 你为什么愿意到我们公司来工作？ 你和别人发生过争执吗？你是怎样解决的？ 你做过的哪件事最令自己感到骄傲？ 想过创业吗？ 对这项工作，你有哪些可预见的困难？ 如果我录用你，你将怎样开展工作？ 你希望与什么样的上级共事？ 与上级意见不一致时，你将怎么办？ 您在前一家公司的离职原因是什么？ 你工作经验欠缺，如何能胜任这项工作？ 如果你在这次面试中没有被录用，你怎么打算？ 谈谈你做过的项目？ 谈谈你过去的工作中，最令你受挫的事情？ 你觉得原来的工作对你从事PHP开发有帮助吗？ 工作中你难以和同事、上司相处，你该怎么办？ 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？ 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？ 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？ 如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？ 每天进步一点，很卑微的一点有用吗？ 如果你所在公司有那么几个人总是做面子活，你会怎么处理，怎么做？ 如果在公司，有看不上的同事怎么办？ 面试时基本注意事项 面试时如何消除紧张感 面试时应注意的礼仪 面试九忌 面试技巧 请你做一下自我介绍？ 一般人回答这个问题过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括最强的技能、最深入研究的知识领域、性格中最积极的部分、做过的最成功的事，主要的成就等。这些回答关于学习或者生活都可以，但要突出积极的个性和做事的能力，说得合情合理企业才会相信。企业很重视一个人的礼貌，求职者要尊重考官，要在自我介绍结束后说一句“谢谢”。(最好有简单的实例，一两句话体现出自己的优势。) 你觉得你最大的优点是什么？ 沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱。我在兄弟连经过五个月的高强度培训及项目实战，使我适合这份工作(专业培训，有项目经验)。要例举具体的优点，如做事认真、抗压能力强、乐于助人、学习能力强等，然后要举实例证明这也是最重要的一点。(不宜把那些明显的优点说成缺点：不要把面试官当成傻子。) 说说你最大的缺点？ 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么，如果求职者说自己有强迫症、爱忌妒人、非常懒、脾气大、工作效率低，那么肯定不会被企业录用。绝对不要自作聪明地回答“我最大的缺点是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。企业喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转回到优点上，突出优点的部分。回答样本：我平时比较爱忘事，然后我通过写便条来提醒我自己什么时候该做什么事。 你对加班的看法？ 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。回答样本：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。(注：不要说加班必须要有加班费，串休等的言语，永远不要因为工作辛苦而离职。) 如何安排自己的时间？会不会排斥加班？ 基本上，如果上班工作有效率，工作量合理的话，应该不太需要加班。可是我也知道有时候很难避免加班，加上现在工作都采用责任制，所以我会调配自己的时间，全力配合。 分析：虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。 在五年的时间内，你的职业规划？ 一般公司高管或者副总喜欢问个人职业规划方面的问题。当然，说出其他一些你感兴趣的职位也是可以的，比如产品销售部经理，生产部经理等一些与你的专业有相关背景的工作。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。能把职业规划分成几部分去完成，比如1个月、三个月、半年、1年以至3年的具体发展目标和实施方案。(主要你的规划要表现出你的上进心。) 你的朋友是如何评价你的？ 面试官想从侧面了解一下你的性格及与人相处的问题。 回答样本一：我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。 回答样本二：我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。 你还有什么要问我的吗？ 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：咱公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说咱公司的晋升机制是什么样的？公司希望我以后向什么方向发展？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。 你对薪资的要求？ 如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。 回答样本一：我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。 回答样本二：我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。 回答样本三：如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场作了调查，而且自己具有这方面的价值。(更要看公司的发展，不要只看眼前小利！) 为什么选择我们这家公司？ 曾经在报章杂志看过关于公司的报道，与自己所追求的理念有志一同。而贵公司在业界的成绩也是有目共睹的，而且对员工的教育训练、升迁等也都很有制度。并具体详谈你调查到的内容会让面试官觉得你很用心。 分析：去面试前先做功课，了解一下该公司的背景，让对方觉得你真的很有心想得到这份工作，而不只是探探路。 谈谈你对跳槽的看法？ 我认为跳槽应该是进入到更好的企业和更大的平台，而不是在公司待几个月就认为公司同事关系不好，自己发展有瓶颈就跳槽，这样换工作是无意义的。 频繁的跳槽对单位和个人双方都不利，应该反对。(忠告：不要刚刚工作就离职了，如加班、工作量大、领导不好等，做为新人必须更加努力，心态摆正。) 谈谈如何适应新的工作环境？ 办公室里每个人有各自的岗位与职责，不得擅离岗位。 根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。 多请示并及时汇报，遇到不明白的要虚心请教。 抓间隙时间，多学习，努力提高自己代码质量和代码规范性。 你来我们公司做前端可以吗？ 面试者在考验面试者是否对所述职位专一时，如果面试者过多表现在前端上的技能，那面试官就会用这个问题问你，如果你回答可以，那么面试官会认为你求职目标不明确，从而不会要你继续面试。(如果问你可否从事别的职位，我们可以拒绝，表示对求职职位的明确性。) 假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？ 成绩比较突出，得到领导的肯定是件好事情，以后更加努力。 检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。 工作中，切勿伤害别人的自尊心。 不再领导前拨弄是非。 请说说你对我们公司了解多少？ 在去公司面试前上网查一下该公司主营业务(公司官网、百度-新闻、招聘网站)或者向公司内的学长咨询(向就业专员要电话)。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。(知己知彼才能百战不殆，面试之前一定要做好准备。) 请说出你选择这份工作的目的？ 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。包括对面试官的了解和团队的了解都是面试之前应该了解的。 你能为我们公司带来什么呢？ 假如你可以的话，试着告诉他们你可以减低他们的培养费用——“我已经接受过兄弟连五个月的高强度培训，立刻就可以上岗工作”。 企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。 给公司带来活力，“我更加积极、更加努力、更加有朝气”。 怎样看待学历和能力？ 学历不一定完全代表能力，虽然我的学历不够硬但是我会在技术上更努力更认真，并在短期内发挥自己的优势，把公司项目做的更好。 你的业余爱好是什么？ 找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。或者看技术论坛，会给工作带来新的思路，或者看关于数据库优化/数据原理的书籍。 作为被面试者请你给我打一下分？ 试着列出四个优点和一个非常非常非常小的缺点。(可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的) 你怎么理解PHP这个职位？ 把岗位职责和任务及工作态度阐述一下，更多的说PHP发展和优势以及你学习PHP的原因。比如：PHP语言上的应用发展，PHP最大特点就是语法灵活，开发速度快，开发成本低，最适合开发业务流程，所以互联中使用PHP开发动态网站将成为主流。(其他专业也是一样的，了解所学专业的优势！) 喜欢这份工作的哪一点？ 每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。 说说你对PHP行业和发展趋势的看法？ 语言本身的发展上，PHP从5版本之后将面向过程转变到面向对象思想方面，做出过一次重大的改变， PHP以后的技术方展，除了在基本语法上保持开发高效之外，需要将部分模块不段升级和优化。也要从运行效率上有大的提高，以及多提供一些针对不同企业扩展的第三方类库进行丰富。 PHP语言上的应用发展，PHP最大特点就是语法灵活，开发速度快， 开发成本低，最适合开发业务流程，所以互联中使用PHP开发动态网站将成为主流。 对工作的期望与目标何在？ 就是职业规划的另一种问法，也是公司在以后培养你的方向上的选择。可以提一些具体的想法和做法。让上级认为你之前考虑过这个事，而且重视自己的职业发展。 就你申请的这个职位，你认为你还欠缺什么？ 企业喜欢问求职者弱点，他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。 你通常如何处理別人的批评？ 沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。 我会等大家冷靜下来再讨论，反思自己是否有这方面问题并进行完善。 怎样对待自己的失敗？ 我认为失败不是坏事，一件事情没有成功肯定是我做的地方有不是，我觉得能积极面对失败并总结经验成功就指日可待。(要解决问题，不要被困难打跑！) 什么会让你有成就感？ 为公司竭力效劳，尽我所能，完成一个项目，并且能提出自己的创新想法。 眼下你生活中最重要的是什么？ 对我来说，能在这个领域找到工作是最重要的，能在公司任职对我说最重要。 你为什么愿意到我们公司来工作？ 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”我希望能够进入一家与我共同成长的公司”，“你们公司一直都稳定发展，在近几年来在市场上很有竞争力”，“我认为公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。 你和别人发生过争执吗？你是怎样解决的？ 这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。基本上没有和他人产生矛盾，首先有矛盾就是因为大家对同一个问题有不同的解决方案，把方案里的优秀点统一起来就是最佳解决方案。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。 你做过的哪件事最令自己感到骄傲？ 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。记住：你的前途取决于你的知识、你的社交能力和综合表现。 想过创业吗？ 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？而且HR会觉得你在公司的稳定性弱，所以有或者没有不要马上说出来。 对这项工作，你有哪些可预见的困难？ 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。 可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。 分析：一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的：一是看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。二是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。 如果我录用你，你将怎样开展工作？ 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。” 分析：这个问题的主要目的也是了解应聘者的工作能力和计划性、条理性，而且重点想要知道细节。如果向思路中所讲的迂回战术，面试官会认为回避问题，如果引导了几次仍然是回避的话，此人绝对不会录用了。 你希望与什么样的上级共事？ 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。 最好回避对上级具体的希望，多谈对自己的要求。 如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。 分析：这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。 与上级意见不一致时，你将怎么办？ 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。” 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。” 分析：这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。(注：在工作初期，做为菜鸟的我们，很多时候不明白领导方案的意思，不要走进一个误区，认为领导能力不如自己，既然他能成为你的领导，他肯定有他过人的能力。) 您在前一家公司的离职原因是什么？ 避免把“离职原因”说得太详细、太具体。尽量说原单位给你带来的提升，体现出感恩的心态，而不能抱怨公司哪里不好。 相关例子：如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。(一定不要说上一家公司不好！) 你工作经验欠缺，如何能胜任这项工作？ 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。” 分析：这个问题思路中的答案尚可。突出自己的吃苦能力和适应性以及学习能力(不是学习成绩)为好。 如果你在这次面试中没有被录用，你怎么打算？ 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败。 要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。 善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。 主要是技术上哪里薄弱，把不足的技术抓紧时间攻克。 谈谈你做过的项目？ 举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿帮的。 谈谈你过去的工作中，最令你受挫的事情？ 如果是学生可以用竞赛里的名次来举例；如果是员工可以以工作中自己努力而又没有做成功的项目来举例。 分析：该问题的目的是借此了解你对挫折的容忍度及调解方式。 你觉得原来的工作对你从事PHP开发有帮助吗？ 这是针对求职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。 工作中你难以和同事、上司相处，你该怎么办？ 我会服从领导的指挥，配合同事的工作。 我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。 如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。 作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。(领导服从，同事多从自己身上找问题，以大局为重，工作中对事不对人！) 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？ 工作一段时间后发现工作不适合你，有两种情况： 如果你确实热爱PHP程序员这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距。 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。而且我会推荐更适合PHP职位的人选。 在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？ 原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。 如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。 还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？ 我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望公司帮助解决。 分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。 总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。 如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？ 我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种： 我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。 他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。 每天进步一点，很卑微的一点有用吗？ 1.01的365次方=37. 78>1，1. 01=1+0.01，也就是每天进步一点。1. 01的365次方也就是说你每天进步一点点，一年以后，你将进步很大，远远大于“1”。 1的365次方=1，1是指原地踏步，一年以后你还是原地踏步，还是那个“1”。 0.99的365次方=0.026，0.99=1-0.01，也就是说你每天退步一点点，你将在一年以后，远远小于“1”，远远被人抛在后面，将会是“1”事无成。 如果你所在公司有那么几个人总是做面子活，你会怎么处理，怎么做？ 不要与这样的人计较，不要改变自己的价值观。 学习沟通能力，在不影响底线的情况下，在企业中情商比智商更重要。 放平心态，学习别人的优点，不要和别人一样，把目标放远，不要只看眼前小利，好比每个月的那次免责请假，不是请假了就是占便宜。 既然讨厌这样的人，但是不要成为这样的人，一定要是领导在与不在一个样。 想干掉这样的人，就要成为这样的人的上司，而不是武力或同样的手段对付他。 切记背后不要说人。 如果在公司，有看不上的同事怎么办？ 多了解，看看是不是有什么问题。 对事不对人，工作不是交朋友。 在工作中不是交朋友，看不看的上都不能影响工作，如果带有私人感情的去工作，肯定会影响工作效率。 看看到底是自己的问题还是别人的问题，如果是只有你一个人看不上他，需要看看自己的问题出在哪，及时改正。 面试时基本注意事项 要谦虚谨慎 面试和面谈的区别之一就是面试时对方往往是多数人，其中不乏专家、学者，求职者在回答一些比较有深度的问题时，切不可不懂装懂，不明白的地方就要虚心请教或坦白说不懂，这样才会给用人单位留下诚实的好印象。 要机智应变 当求职者一人面对众多考官时，心理压力很大，面试的成败大多取决于求职者是否能机智果断，随机应变，能当场把自己的各种聪明才智发挥出来。首先，要注意分析面试类型，如果是主导式，你就应该把目标集中投向主考官，认真礼貌地回答问题；如果是答辩式，你则应把目光投向提问者，切不可只关注甲方而冷待乙方；如果是集体式面试，分配给每个求职者的时间很短，事先准备的材料可能用不上，这时最好的方法是根据考官的提问在脑海里重新组合材料，言简意赅地作答，切忌长篇大论。其次要避免尴尬场面，在回答问题时常遇到这些情况：未听清问题便回答，听清了问题自己一时不能作答，回答时出现错误或不知怎么回答的问题时，可能使你处于尴尬的境地。避免尴尬的技巧是：对未听清的问题可以请求对方重复一遍或解释一下；一时回答不出可以请求考官提下一个问题，等考虑成熟后再回答前一个问题；遇到偶然出现的错误也不必耿耿于怀而打乱后面问题的思路。 要扬长避短 每个人都有自己的特长和不足，无论是在性格上还是在专业上都是这样。因此在面试时一定要注意扬我所长，避我所短。必要时可以婉转地说明自己的长处和不足，用其他方法加以弥补。例如有些考官会问你这样的问题：“你曾经犯过什么错误吗？”你这时候就可以选择这样回答：“以前我一直有一个粗心的毛病，有一次实习的时候，由于我的粗心把公司的一份材料弄丢了，害的老总狠狠地把我批评了一顿。后来我经常和公司里一个非常细心的女孩子合作，也从她那里学来了很多处理事情的好办法，一直到现在，我都没有因为粗心再犯什么错。”这样的回答，即可以说明你曾经犯过这样的错误，回答了招聘官提出的问题，也表明了那样的错误只是以前出现，现在已经改正了。 显示潜能 面试的时间通常很短，求职者不可能把自己的全部才华都展示出来，因此要抓住一切时机，巧妙地显示潜能。例如，应聘会计职位时可以将正在参加计算机专业的业余学习情况“漫不经心”地讲出来，可使对方认为你不仅能熟练地掌握会计业务，而且具有发展会计业务的潜力；报考秘书工作时可以借主考官的提问，把自己的名字、地址、电话等简单资料写在准备好的纸上，顺手递上去，以显示自己写一手漂亮字体的能力等。显示潜能时要实事求是、简短、自然、巧妙，否则也会弄巧成拙。 面试时如何消除紧张感 由于面试成功与否关系到求职者的前途，所以大学生面试时往往容易产生紧张情绪，有的大学生可能还由于过度紧张导致面试失败。所以紧张感在面试中是常见的。紧张是应考者在考官面前精神过度集中的一种心理状态，初次参加面试的人都会有紧张感觉，慌慌张张、粗心大意、说东忘西、词不达意的情况是常见的。那么怎样才能在面试时克服、消除紧张呢？ 要保持”平常心” 在竞争面前，人人都会紧张，这是一个普遍的规律，面试时你紧张，别人也会紧张，这是客观存在的，要接受这一客观事实。这时你不妨坦率地承认自己紧张，也许会求得理解。同时要进行自我暗示，提醒自己镇静下来，常用的方法是或大声讲话，把面对的考官当熟人对待；或掌握讲话的节奏；或握紧双拳、闭目片刻，先听后讲；或调侃两三句等等，都有助于消除紧张。 不要把成败看得太重 “胜败乃兵家常事”要这样提醒自己，如果这次不成，还有下一次机会；这个单位不聘用，还有下一个单位面试的机会等着自己；即使求职不成，也不是说你一无所获，你可以在分析这次面试过程中的失败，总结经验，得出宝贵的面试经验，以新的姿态迎接下一次的面试。在面试时不要老想着面试结果，要把注意力放在谈话和回答问题上，这样就会大大消除你的紧张感。 不要把考官看得过于神秘 并非所有的考官都是经验丰富的专业人才，可能在陌生人面前也会紧张，认识到这一点就用不着对考官过于畏惧，精神也会自然放松下来。面试官来面试你其实他也很紧张，如果招不到合适的人，老板就会扣他工资，所以他的压力也很大。因此，如果面试时你很紧张，那么这场面试一定很快就结束了。 要准备充分 实践证明，面试时准备得越充分，紧张程度就越小。考官提出的问题你都会，还紧张什么？”知识就是力量”，知识也会增加胆量。面试前除了进行道德、知识、技能、心理准备外，还要了解和熟悉求职的常识、技巧、基本礼节，必要时同学之间可模拟考场，事先多次演练，互相指出不足，相互帮助、相互模仿，到面试时紧张程度就会减少。 要增强自信心 面试时应聘者往往要接受多方的提问，迎接多方的目光，这是造成紧张的客观原因之一。这时你不妨将目光盯住主考官的脑门，用余光注视周围，既可增强自信心又能消除紧张感；在面试过程中，考官们可能交头接耳，小声议论，这是很正常的，不要把它当成精神负担，而应作为提高面试能力的动力，你可以想象他们的议论是对你的关注，这样你就可以增加信心，提高面试的成功的率；面试中考官可能提示你回答问题时的不足甚至错误，这也没有必要紧张，因为每个人都难免出点差错，能及时纠正就纠正，是事实就坦率承认，不合事实还可婉言争辩，关键要看你对问题的理解程度和你敢于和主考官争辩真伪的自信的程度。 面试时应注意的礼仪 服饰要得体 就服饰而言，应聘者在去求职面试前，必须精心选择自己的服饰。那就是服饰要与自己的身材、身份相符，表现出朴实、大方、明快、稳健的风格。在面试时，着装应该符合时代、季节、场所、收入的程度，并且要与自己应聘的职业相协调，能体现自己的个性和职业特点。一般说来，服饰要给人以整洁、大方得体的感觉，穿着应以保守、庄重一点为好，不要追求时髦，浓妆艳抹，尤其是女生，如果衣着过于华丽，描眉搽粉，项链、耳环、戒指都戴上，这样会给用人单位一种轻浮的印象，影响面试的成绩女生的装束以朴实、庄重为好，男生则以整洁、干练为好。要注意提前理好自己的发型，如在夏季，男生可穿着整洁的衬衫或T 恤衫。另外，装束打扮一定要与谋求的职业相称，应与自己的兴趣、爱好、个性、习惯相符合，一个平时着装随便的人，突然间让他衣冠楚楚，他会感到拘谨、不自在。 遵守时间 守时是现代交际时效观的一种重要原则，是作为一个社会人要遵守的最起码的礼仪。面试中，最忌的首先就是不守时，因为等待会使人产生焦急烦躁的情绪，从而使面谈的气氛不够融洽。有专家统计，求职面试迟到者获得录用的概率只有相当于不迟到者的一半。可见，守时这一礼仪在面试中的重要性。因此，面试时，千万不能迟到，而且最好能够提前十分钟到达面试地点，以有充分的时间调整好自己紧张的情绪，也表示求职的诚意。 表情要自然，动作要得体 进门时，不要紧张，表情越自然越好，在对方没有请你坐下时切勿急于坐下，请你坐下时，应说声”谢谢”，坐下后要保持良好的坐姿，不要又是挠头皮、抠鼻孔，又是挖耳朵，或起二郎腿乱抖。对于女生来讲，动作更应得当，任何轻浮的表情或动作都可能会让招聘人员读你不满。另外各种手势语也要恰当得体、自然。 要讲究文明礼貌 进门时应主动打招呼：“您好，我是某某”，如果是对方主动约自己面谈，一定要感谢对方给自己这样一个机会；如果是自己约对方面谈，一定要表示歉意“对不起，打扰您了”等等。面谈时要真诚地注视对方，表示对他的话感兴趣，决不可东张西望，心不在焉，不要不停地看手表，否则，显得不尊重对方。另外，对对方的谈话的反应要适度，要有呼应。他说幽默话时，你的笑声会增添他的兴致；他说话严肃认真时，你屏住呼吸则强化了气氛，这种反应要自然坦率，不能故意做作或大惊小怪地做出表情。 保持安静 在等候面试时，不要到处走动，更不能擅自到考场外面张望，求职者之间的交谈也应尽可能地降低音量，避免影响他人应试或思考。最好的办法就是抓紧时间熟悉可能被提问的问题，积极做好应试准备。 “听”的学问 首先，要耐心。对对方提起的任何话题，你都应耐心倾听，不能表现出心不在焉或不耐烦的神色，要尽量让对方兴致勃勃地讲完，不要轻易打断或插话；其次，要细心。也就是要具备足够的敏感性，善于理解对方的“弦外之音”，即从对方的言谈话语之间找出他没能表达出来的潜在意思，同时要注意倾听对方说话的语调和说话的每一个细节；再次，要专心。专心的目的是要抓住对方谈话的要点和实质，因此，你应该保持饱满的精神状态，专心致志地注视对方，并有表示听懂或赞同的声音或动作；如果对方提出的问题本身很明确，但你却没有完全理解，那么你可以以婉转诚恳的语言提出不明确的部分，对方会进一步解释的。这样既能弄清问题的要点和实质，又能给对方以专心致志的好印象；最后，要注意强化。要认真琢磨对方讲话的重点或反复强调的问题，必要时，你可以进行复述或提问，如：“我同意您刚才所提的……”、“您是不是说……”重复对方强调的问题，会使对方产生”酒逢知己千杯少”的感觉，往往会促进情感的融风。 交谈的学问 “听”有学问，“说”同样有学问。参加面谈的求职者不可避免地会不同程度地产生紧张情绪或羞怯心理，因此你谈话之前应尽可能地清除紧张、克服羞怯，并坦率、谦虚地告诉对方“对不起，我有点紧张”等，对方会理解你，甚至会安慰你，帮助你放松。承认紧张对推荐自己没有什么消极影响，反而会显示你实在、坦率和求职的诚意，这是良好交谈的第一步。其次，采用呼应式的交谈，并巧妙地引导话题。求职面谈既不同于当众演讲，又不同于自言自语，而在于相互间的呼应。成功的对话是一个相互应答的过程，自己每一句话都应是对方上一句话的继续，并给对方提供发言的余地，还要注意巧妙地引导话题。如当所谈内容与求职无关，而对方却大谈特谈时，你可以说:“这件事很有意思，以后一定向您请教。现在我有个问题不明白……”，从而巧妙地转移了话题；“您认为某项工作应具备哪些素质？”以引起双方感兴趣的话题。再次，谈话要动之以情，处处表现情真意切，实实在在。不要海阔天空，华而不实，更不能虚情假意，说假话、空话。另外，人们在紧张的情况下，往往讲话的节奏加快，这不利于进行情感交流，因此，谈话时应掌握节奏，必要时可用机智、幽默、风趣的语言使双方都放慢谈话的节奏。 尊重对方，善解人意 取得招聘者的好感必须真正尊重对方，善解人意。在求职时往往有这种情况：招聘者的资历或学历、职称、年龄等可能不如求职者，此时千万不能妄自尊大。如果一旦流露出不尊重对方的表情，处处显示出优于对方、待价而沽的情绪，引起了对方的反感，往往会将好事办砸。 跟进面试情况 很多面试者面试后都会告知你回去等通知，很多时候是在考验面试者的积极主动性，所以面试结束后要询问面试官电话和称呼，以便后续跟进面试情况。 面试九忌 忌握手无力，过于靠近面试官 中国人见面问候的方式是握手，面试时与主试者应恰如其分地轻轻一握，不要有气无力地被动握手，给对方一种精力不足，身体虚弱之感。落座后应与对方保持合适的距离，不能过分靠近对方，逼视对方。更不能以姓名称呼主试者，而应时时表现出你对他们的尊敬。 忌坐立不安，举止失当 面试时决不能做小动作，如摇头晃脑、频频改变坐姿，更不能嚼口香糖、抽烟。主试者可能示意你抽烟，但最好谢绝他的好意。主试者的“宽宏大量”是暴露应聘者弱点的最佳武器之一，在整个面试过程中，注意不要让自己的小毛病浮出水面。 忌言语离题 有的求职者讲话不分场合，不看对象，让主试者听得莫名其妙。例如说些俗不可耐的笑话，谈及家庭和经济方面的问题，讲些涉及个人生活的小道消息，或任意对面试室的家具和装修评头论足。主试者可没有时间猜测你想真正表达的是什么。 忌说得太急 言谈中迫不及待想得到这个工作，急着回答自己没听清或没有理解透彻的问题，而不是有礼貌地请对方再说一遍或再说明；不加解释就自称掌握某种技术，何处培训、何时参加、何人教授一律避而不答，令人生疑。所谓“欲速则不达“。 忌提问幼稚 在想考官提问时要考虑自己提的问题是否有价值或者主考官已经回答过或解释过。千万别提一些很幼稚的问题，如：“办公室有空调吗？”“你知道某某主任在哪里吗？” 忌言语粗俗 粗俗的语言，毫不修饰语言习惯并不代表你男子汉的气概或不拘小节，反倒另人难堪、生厌。 忌反应迟钝 聆听主考官讲话并非单纯用耳朵，还包括所有的器官；不仅用头脑，还得用心灵。如果对方说话时你双眼无神、反应迟钝，这组已让考官对你失去信心，不论你将来如何推销自己，一切都基本上是徒劳，败局已定。 忌做鬼脸 顽童做鬼脸，人们往往觉得其天真可爱，而且在平时人们的表达中也经常用到。但是，在面试中，夸张的鬼脸会使主试者认为你过于造作、善于伪装、会演戏，另外，表达恶意的鬼脸更容易另对方觉得你是没有礼貌、无教养的。 忌像个嫌疑犯一般 应但意识到面试是一种机会平等的面谈，不是公安机关审讯嫌疑犯。不要过多理会主试者的态度。一开始就与你谈笑风生的主试者几乎是没有的，多数人的表情是正儿八经的。但应聘者还是应该把自己解放出来，不要担当被审察的角色。这样才利于自己正常的发挥。自信别紧张，保持微笑。 "},"pages/Review.html":{"url":"pages/Review.html","title":"面试真题","keywords":"","body":" 题卷I 题卷II 题卷III 题卷IV 题卷V 题卷VI "},"pages/review/ReviewI.html":{"url":"pages/review/ReviewI.html","title":"题卷I","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 说一下ArrayList和LinkedList区别？ 说一下HashMap的put()方法？ 说一下ThreadLocal？ 说一下JVM中，哪些是共享区？哪些可以作为gc root？ 你们项目如何排查JVM问题？ 如何查看线程死锁？ 线程之间如何进行通讯的？ 介绍一下Spring，读过源码介绍一下大致流程？ 说一下Spring的事务机制？ 什么时候＠Transactional失效？ Dubbo是如何做系统交互的？ Dubbo的负载均衡策略？ 还读过哪些框架源码介绍一下你还熟悉的？ Jdk1.7到Jdk1.8 HashMap发生了什么变化(底层)？ Jdk1.7到Jdk1.8 java虚拟机发生了什么变化？ 如何实现AOP，项目哪些地方用到了AOP？ Spring中后置处理器的作用？ 说说常用的SpringBoot注解，及其实现？ 说说你了解的分布式锁实现？ Redis的数据结构及使用场景？ Redis集群策略？ Mysql数据库中，什么情况下设置了索引但无法使用？ Innodb是如何实现事务的？ 聊聊你最有成就感的项目？ 自己最有挑战的项目、难点？ 遇到过哪些设计模式？ Java死锁如何避免？ 深拷贝和浅拷贝？ 如果你提交任务时，线程池队列已满，这时会发生什么？ 谈谈ConcurrentHashMap的扩容机制？ Spring中Bean是线程安全的吗？ 说说你常用的Linux基本操作命令？ Maven中Package和Install的区别？ SpringCloud各组件功能，与Dubbo的区别？ 项目及主要负责的模块？ 说说类加载器双亲委派模型？ 泛型中extends和super的区别？ 并发编程三要素？ Spring用到了哪些设计模式？ 简述CAP理论？ 图的深度遍历和广度遍历？ 快排算法？ TCP的三次握手和四次挥手？ 消息队列如何保证消息可靠传输？ 画出项目架构图，介绍自己所处的模块？ 二叉搜索树和平衡二叉树有什么关系？ 强平衡二叉树和弱平衡二叉树有什么区别？ B树和B+树的区别，为什么Mysql使用B+树？ epoll和poll的区别？ 简述线程池原理，FixedThreadPool用的阻塞队列是什么？ sychronized和ReentrantLock的区别？ sychronized的自旋锁、偏向锁、轻量级锁、重量级锁，分别介绍和联系？ HTTPS是如何保证安全传输的？ 设计模式有哪些大类，及熟悉其中哪些设计模式？ volatile关键字，他是如何保证可见性，有序性？ Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代？ Mysql的锁你了解哪些？ 题卷I 说一下ArrayList和LinkedList区别？ 首先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的。 由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同。 另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使用。 说一下HashMap的put()方法？ 首先put()方法接收到key和value时，会先利用key进行哈希算法得到这个key对应的哈希值。public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } 再通过这个哈希值与数组长度-1进行与操作得到一个数组下标。 再判断数组下标位置是不是空着。如果空着，则直接把key和value封装为一个Node对象并存入此数组位置。 如果此下标位置上非空，表示此位置上存在Node对象，那么则判断该Node对象是不是一个红黑树节点，如果是则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value。 如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并插入到链表中去。 插入到链表中后，会判断链表的节点个数是不是超过了8个，如果超过则把当前位置的链表转化为红黑树。 插入链表使用的是尾插法，所以需要遍历链表，而在这个过程中也会去判断key是否存在，如果存在则更新value。final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } 说一下ThreadLocal？ ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据。 ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象(注意不是ThreadLocal对象)中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值。 如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key、value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。 ThreadLocal经典的应用场景就是连接管理(一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接)。 说一下JVM中，哪些是共享区？哪些可以作为gc root？ 堆区和方法区是所有线程共享的，虚拟机栈、本地方法栈、程序计数器是每个线程独有的。 什么是gc root，JVM在进行垃圾回收时，需要找到“垃圾”对象，也就是没有被引用的对象，但是直接找“垃圾”对象是比较耗时的，所以反过来，先找“非垃圾”对象，也就是正常对象，那么就需要从某些“根”开始去找，根据这些“根”的引用路径找到正常对象，而这些“根”有一个特征，就是它只会引用其他对象，而不会被其他对象引用，例如：栈中的本地变量、方法区中的静态变量、本地方法栈中的变量、正在运行的线程等可以作为gc root。 你们项目如何排查JVM问题？ 对于还在正常运行的系统: 可以使用jmap来查看JVM中各个区域的使用情况。# 按照占用内存降序排列 jmap -histo PID 可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁。 可以通过jstat命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了。# 每隔1000ms(1s)执行一次，总共执行10次 jstat -gc PID 1000 10 通过各个命令的结果，或者jvisualvm等工具来进行分析。 首先，初步猜测频繁发生full gc的原因，如果频繁发生full gc但是又一直没有出现内存溢出，那么表示full gc实际上是回收了很多对象了，所以这些对象最好能在young gc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，full gc减少，则证明修改有效。 同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存。 对于已经发生了OOM的系统: 一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件(-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/esb/logs)。 我们可以利用jvisualvm等工具来分析dump文件。 根据dump文件找到异常的实例对象和异常的线程(占用CPU高)，定位到具体的代码。 然后再进行详细的分析和调试。 总之，调优不是一蹴而就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题。 如何查看线程死锁？ 可以通过jstack命令来进行查看，jstack命令中会显示发生了死锁的线程。 或者两个线程去操作数据库时，数据库发生了死锁，这是可以查询数据库的死锁情况。# 查询是否锁表 show OPEN TABLES where In_use > 0; # 查询进程 show processlist; # 查看正在锁的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; # 查看等待锁的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 线程之间如何进行通讯的？ 线程之间可以通过共享内存或基于网络来进行通信。 如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒。 像Java中的wait()、notify()就是阻塞和唤醒。 通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，处理方式就是加锁等方式。 介绍一下Spring，读过源码介绍一下大致流程？ Spring是一个快速开发框架，Spring帮助程序员来管理对象。 Spring的源码实现的是非常优秀的，设计模式的应用、并发安全的实现、面向接口的设计等。 在创建Spring容器，也就是启动Spring时： 首先会进行扫描，扫描得到所有的BeanDefinition对象，并存在一个Map中。 然后筛选出非懒加载的单例BeanDefinition进行创建Bean，对于多例Bean不需要在启动过程中去进行创建，对于多例Bean会在每次获取Bean时利用BeanDefinition去创建。 利用BeanDefinition创建Bean就是Bean的创建生命周期，这期间包括了合并BeanDefinition、推断构造方法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中AOP就是发生在初始化后这一步骤中。 单例Bean创建完了之后，Spring会发布一个容器启动事件。 Spring启动结束。 在源码中会更复杂，比如源码中会提供一些模板方法，让子类来实现，比如源码中还涉及到一些BeanFactoryPostProcessor和BeanPostProcessor的注册，Spring的扫描就是通过BenaFactoryPostProcessor来实现的，依赖注入就是通过BeanPostProcessor来实现的。 在Spring启动过程中还会去处理＠import等注解。 说一下Spring的事务机制？ Spring事务底层是基于数据库事务和AOP机制的。 首先对于使用了＠Transactional注解的Bean，Spring会创建一个代理对象作为Bean。 当调用代理对象的方法时，会先判断该方法上是否加了＠Transactional注解。 如果加了，那么则利用事务管理器创建一个数据库连接。 并且修改数据库连接的autocommit属性为false，禁止此连接的自动提交，这是实现Spring事务非常重要的一步。 然后执行当前方法，方法中会执行sql。 执行完当前方法后，如果没有出现异常就直接提交事务。 如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务。 Spring事务的隔离级别对应的就是数据库的隔离级别。 Spring事务的传播机制是Spring事务自己实现的，也是Spring事务中最复杂的。 Spring事务的传播机制是基于数据库连接来做的，一个数据库连接一个事务，如果传播机制配置为需要新开一个事务，那么实际上就是先建立一个数据库连接，在此新数据库连接上执行sql。 什么时候＠Transactional失效？ 因为Spring事务是基于代理来实现的，所以某个加了＠Transactional的方法只有是被代理对象调用时，那么这个注解才会生效，所以如果是被代理对象来调用这个方法，那么＠Transactional是不会生效的。 同时如果某个方法是private的，那么＠Transactional也会失效，因为底层cglib是基于父子类来实现的，子类是不能重载父类的private方法的，所以无法很好的利用代理，也会导致＠Transactional失效。 👉 聊聊Spring事务失效的10种场景，太坑人了 Dubbo是如何做系统交互的？ Dubbo底层是通过RPC来完成服务和服务之间的调用的，Dubbo支持很多协议，比如默认的dubbo协议，比如http协议、比如rest等都是支持的，他们的底层所使用的技术是不太一样的，比如dubbo协议底层使用的是netty，也可以使用mina，http协议底层使用的tomcat或jetty。 服务消费者在调用某个服务时，会将当前所调用的服务接口信息、当前方法信息、执行方法所传入的入参信息等组装为一个Invocation对象，然后不同的协议通过不同的数据组织方式和传输方式将这个对象传送给服务提供者，提供者接收到这个对象后，找到对应的服务实现，利用反射执行对应的方法，得到方法结果后再通过网络响应给服务消费者。 当然，Dubbo在这个调用过程中还做很多其他的设计，比如服务容错、负载均衡、Filter机制、动态路由机制等等，让Dubbo能处理更多企业中的需求。 Dubbo的负载均衡策略？ 平衡加权轮询算法 加权随机算法 一致性哈希算法 最小活跃数算法 还读过哪些框架源码介绍一下你还熟悉的？ 这个问题比较广泛，你即可以说：HashMap、线程池等JDK自带的源码，也可以说Mybatis、Spring Boot、Spring Cloud、消息队列等开发框架或中间件的源码。 Jdk1.7到Jdk1.8 HashMap发生了什么变化(底层)？ 1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率。 1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法。 1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为负载的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源。 Jdk1.7到Jdk1.8 java虚拟机发生了什么变化？ 1.7中存在永久代，1.8中没有永久代，替换它的是元空间，元空间所占的内存不是在虚拟机内部，而是本地内存空间，这么做的原因是，不管是永久代还是元空间，他们都是方法区的具体实现，之所以元空间所占的内存改成本地内存，官方的说法是为了和JRockit统一，不过额外还有一些原因，比如方法区所存储的类信息通常是比较难确定的，所以对于方法区的大小是比较难指定的，太小了容易出现方法区溢出，太大了又会占用了太多虚拟机的内存空间，而转移到本地内存后则不会影响虚拟机所占用的内存。 如何实现AOP，项目哪些地方用到了AOP？ 利用动态代理技术来实现AOP，比如JDK动态代理或cglib动态代理，利用动态代理技术，可以针对某个类生成代理对象，当调用代理对象的某个方法时，可以任意控制该方法的执行，比如可以先打印执行时间，再执行该方法，并且该方法执行完成后，再次打印执行时间。 项目中，比如事务、权限控制、方法执行时长日志都是通过AOP技术来实现的，凡是需要对某些方法做统一处理的都可以用AOP来实现，利用AOP可以做到业务无侵入。 👉 Cglib和jdk动态代理的区别 Spring中后置处理器的作用？ Spring中的后置处理器分为BeanFactory后置处理器和Bean后置处理器，它们是Spring底层源码架构设计中非常重要的一种机制，同时开发者也可以利用这两种后置处理器来进行扩展。BeanFactory后置处理器表示针对BeanFactory的处理器，Spring启动过程中，会先创建出BeanFactory实例，然后利用BeanFactory处理器来加工BeanFactory，比如Spring的扫描就是基于BeanFactory后置处理器来实现的，而Bean后置处理器也类似，Spring在创建一个Bean的过程中，首先会实例化得到一个对象，然后再利用Bean后置处理器来对该实例对象进行加工，比如我们常说的依赖注入就是基于一个Bean后置处理器来实现的，通过该Bean后置处理器来给实例对象中加了＠Autowired注解的属性自动赋值，还比如我们常说的AOP，也是利用一个Bean后置处理器来实现的，基于原实例对象，判断是否需要进行AOP，如果需要，那么就基于原实例对象进行动态代理，生成一个代理对象。 说说常用的SpringBoot注解，及其实现？ ＠SpringBootApplication注解标识了一个SpringBoot工程，它实际上是另外三个注解的组合，这三个注解是: ＠SpringBootConfiguration这个注解实际就是一个＠Configuration，表示启动类也是一个配置类。 ＠EnableAutoConfiguration向Spring容器中导入了一个Selector，用来加载ClassPath下spring.factories中所定义的自动配置类，将这些自动加载为配置Bean。 ＠ComponentScan标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前目录。 ＠Bean注解用来定义Bean，类似于XML中的bean标签，Spring在启动时，会对加了＠Bean注解的方法进行解析，将方法的名字做为beanName，并通过执行方法得到bean对象。 ＠Controller、＠Service、＠ResponseBody、＠Autowired都可以说。 说说你了解的分布式锁实现？ 分布式锁所要解决的问题的本质是能够对分布在多台机器中的线程对共享资源的互斥访问。在这个原理上可以有很多的实现方式: 基于Mysql，分布式环境中的线程连接同一个数据库，利用数据库中的行锁来达到互斥访问，但是Mysql的加锁和释放锁的性能会比较低，不适合真正的实际生产环境。 基于Zookeeper，Zookeeper中的数据是存在内存的，所以相对于Mysql性能上是适合实际环境的，并且基于Zookeeper的顺序节点、临时节点、Watch机制能非常好的来实现的分布式锁。 基于Redis，Redis中的数据也是在内存，基于Redis的消费订阅功能、数据超时时间，lua脚本等功能，也能很好的实现的分布式锁。 Redis的数据结构及使用场景？ Redis的数据结构有: 字符串可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利用了这种数据结构，还包括可以实现计数器、Session共享、分布式ID。 哈希表可以用来存储一些key-value对，更适合用来存储对象。 列表Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似微信公众号、微博等消息流数据。 集合和列表类似，也可以存储多个元素，但是不能重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人、朋友圈点赞等功能。 有序集合集合是无序的，有序集合可以设置顺序，可以用来实现排行榜功能。 Redis集群策略？ Redis提供了三种集群策略: 主从模式这种模式比较简单，主库可以读写，并且会和从库进行数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要手动修改IP，另外，这种模式也比较难进行扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能支持特大数据量。 哨兵模式这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择一个库作为进的主库，另外哨兵也可以做集群， 从而可以保证但某一个哨兵节点宕机后，还有其他哨兵节点可以继续工作，这种模式可以比较好的保证Redis集群的高可用，但是仍然不能很好的解决Redis的容量上限问 题。 Cluster模式是用得比较多的模式，它支持多主多从，这种模式会按照key进行槽位的分配，可以使得不同的key分散到不同的主节点上，利用这种模式可以使得整个集群支持更大的数据容量，同时每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从它的从节点中选举一个新的主节点。 对于这三种模式，如果Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，那么选择Cluster模式。 Mysql数据库中，什么情况下设置了索引但无法使用？ 没有符合最左前缀原则。 字段进行了隐式数据类型转化。 走索引没有全表扫描效率高。 Innodb是如何实现事务的？ Innodb通过Buffer Pool、LogBuffer、Redo Log、Undo Log来实现事务，以一个update语句为例: Innodb在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中。 执行update语句，修改Buffer Pool中的数据，也就是内存中的数据。 针对update语句生成一个redo log对象，并存入LogBuffer中。 针对update语句生成undo log日志，用于事务回滚。 如果事务提交，那么则把redo log对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中。 如果事务回滚，则利用undo log日志进行回滚。 聊聊你最有成就感的项目？ 项目是做什么的？ 用了什么技术？ 你在项目中担任的职位？ 收获了什么？ 自己最有挑战的项目、难点？ 使用什么技术解决了什么项目难点？ 使用什么技术优化了什么项目功能？ 使用什么技术节省了多少成本？ 遇到过哪些设计模式？ 在学习一些框架或中间件的底层源码的时候遇到过一些设计模式: 代理模式Mybatis中用到JDK动态代理来生成Mapper的代理对象，在执行代理对象的方法时会去执行SQL，Spring中AOP、包括＠Configuration注解的底层实现也都用到了代理模式。 责任链模式Tomcat中的Pipeline实现，以及Dubbo中的Filter机制都使用了责任链模式。 工厂模式Spring中的BeanFactory就是一种工厂模式的实现。 适配器模式Spring中的Bean销毁的生命周期中用到了适配器模式，用来适配各种Bean销毁逻辑的执行方式。 外观模式Tomcat中的Request和RequestFacade之间体现的就是外观模式。 模板方法模式Spring中的refresh方法中就提供了给子类继承重写的方法，就用到了模板方法模式。 Java死锁如何避免？ 造成死锁的几个原因: 一个资源每次只能被一个线程使用。 一个线程在阻塞等待某个资源时，不释放已占有资源。 一个线程已经获得的资源，在未使用完之前，不能被强行剥夺。 若干线程形成头尾相接的循环等待资源关系。 这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。 在开发过程中: 要注意加锁顺序，保证每个线程按同样的顺序进行加锁。 要注意加锁时限，可以针对所设置一个超时时间。 要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决。 深拷贝和浅拷贝？ 深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。 浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象。 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的类执行指向的不是同一个对象。 如果你提交任务时，线程池队列已满，这时会发生什么？ 如果使用的无界队列，那么可以继续提交任务时没关系的。 如果使用的有界队列，提交任务时，如果队列满了，如果核心线程数没有达到上限，那么则增加线程，如果线程数已经达到了最大值，则使用拒绝策略进行拒绝。 谈谈ConcurrentHashMap的扩容机制？ 1.7版本: 1.7版本的ConcurrentHashMap是基于Segment分段实现的。 每个segment相对于一个小型的HashMap。 每个Segment内部会进行扩容，和HashMap的扩容逻辑类似。 先生成新的数组，然后转移原数到新数组中。 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值。 1.8版本: 1.8版本的ConcurrentHashMap不再基于Segment实现。 当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容。 如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容。 ConcurrentHashMap是支持多个线程同时扩容的。 扩容之前也先生成一个新的数组。 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作。 Spring中Bean是线程安全的吗？ Spring本身并没有针对Bean做线程安全的处理，所以: 如果Bean是无状态的，那么Bean则是线程安全的。 如果Bean是有状态的，那么Bean则不是线程安全的。 另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。 说说你常用的Linux基本操作命令？ 增删查改。 防火墙相关。 ssh/scp。 软件下载、解压、安装。 修改权限。 Maven中Package和Install的区别？ Package是打包，打成Jar或War。 Install表示将Jar或War安装到本地仓库中。 SpringCloud各组件功能，与Dubbo的区别？ Eureka注册中心，用来进行服务的自动注册和发现。 Ribbon负载均衡组件，用来在消费者调用服务时进行负载均衡。 Feign基于接口的申明式的服务调用客户端，让调用变得更简单。 Hystrix断路器，负责服务容错。 Zuul服务网关，可以进行服务路由、服务降级、负载均衡等。 Nacos分布式配置中心以及注册中心。 Sentinel服务的熔断降级，包括限流。 Seata分布式事务。 Spring Cloud Config分布式配置中心。 Spring Cloud Bus消息总线。 ... Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用间的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有Spring Cloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来一起使用的。 项目及主要负责的模块？ 平时要多了解一下你目前在做的项目中的核心模块，核心功能的业务与使用到的技术。 说说类加载器双亲委派模型？ JVM中存在三个默认的类加载器: BootstrapClassLoader ExtClassLoader AppClassLoader AppClassLoader的父加载器是ExtClassLoader，ExtClassLoader的父加载器是BootstrapClassLoader。 JVM在加载一个类时，会调用AppClassLoader的loadClass方法来加载这个类，不过在这个方法中，会先使用ExtClassLoader的loadClass方法来加载类，同样ExtClassLoader的loadClass方法中会先使用BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果BootstrapClassLoader没有加载到，那么ExtClassLoader就会自己尝试加载该类，如果没有加载到，那么则会由AppClassLoader来加载这个类。 所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进行加载，如果没加载到才由自己进行加载。 泛型中extends和super的区别？ 表示包括T在内的任何T的子类。 表示包括T在内的任何T的父类。 并发编程三要素？ 原子性不可分割的操作，多个步骤要保证同时成功或同时失败。 有序性程序执行的顺序和代码的顺序保持一致。 可见性一个线程对共享变量的修改，另一个线程能立马看到。 Spring用到了哪些设计模式？ 👉 Spring/SpringBoot系列之Spring中涉及的9种设计模式 简述CAP理论？ CAP理论是分布式领域非常重要的一个理论，很多分布式中间件在实现时都需要遵守这个理论，其中: C表示一致性，指的的是分布式系统中的数据的一致性。 A表示可用性，表示分布式系统是否正常可用。 P表示分区容器性，表示分布式系统出现网络问题时的容错性。 CAP理论是指在分布式系统中不能同时保证C和A，也就是说在分布式系统中要么保证CP，要么保证AP，也就是一致性和可用性只能取其一，如果想要数据的一致性，那么就需要损失系统的可用性，如果需要系统高可用，那么就要损失系统的数据一致性，特指强一致性。 CAP理论太过严格，在实际生产环境中更多的是使用BASE理论，BASE理论是指分布式系统不需要保证数据的强一致，只要做到最终一致，也不需要保证一直可用，保证基本可用即可。 图的深度遍历和广度遍历？ 图的深度优先遍历是指，从一个节点出发，一直沿着边向下深入去找节点，如果找不到了则返回上一层找其他节点。 图的广度优先遍历是指，从一个阶段出发，向下先把第一层的节点遍历完，再去遍历第二层的阶段，直到遍历到最后一层。 快排算法？ 快速排序算法底层采用了分治法。 基本思想是: 先取出数列中的第一个数作为基准数。 将数列中比基准数大的数全部放在它的右边，比基准数小的数全部放在它的左边。 然后在对左右两部分重复第二步，直到各区间只有一个数。 TCP的三次握手和四次挥手？ TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。在建立TCP连接时，需要通过三次握手来建立，过程是: 客户端向服务端发送一个SYN。 服务端接收到SYN后，给客户端发送一个SYN_ACK。 客户端接收到SYN_ACK后，再给服务端发送一个ACK。 在断开TCP连接时，需要通过四次挥手来端口，过程是: 客户端向服务端发送FIN。 服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理。 服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接。 客户端收到服务端的FIN，向服务端发送ACK，表示客户端也会断开连接了。 消息队列如何保证消息可靠传输？ 消息可靠传输代表了两层意思，既不能多也不能少。 为了保证消息不多，也就是消息不能重复，也就是生产者不能重复生产消息，或者消费者不能重复消费消息: 首先要确保消息不多发，这个不常出现，也比较难控制，因为如果出现了多发，很大的原因是生产者自己的原因，如果要避免出现问题，就需要在消费端做控制。 要避免不重复消费，最保险的机制就是消费者实现幂等性，保证就算重复消费，也不会有问题，通过幂等性，也能解决生产者重复发送消息的问题。 消息不能少，意思就是消息不能丢失，生产者发送的消息，消费者一定要能消费到，对于这个问题，就要考虑两个方面: 生产者发送消息时，要确认broker确实收到并持久化了这条消息，比如RabbitMQ的confirm机制，Kafka的ack机制都可以保证生产者能正确的将消息发送给broker。 broker要等待消费者真正确认消费到了消息时才删除掉消息，这里通常就是消费端ack机制，消费者接收到一条消息后，如果确认没问题了，就可以给broker发送一个ack，broker接收到ack后才会删除消息。 画出项目架构图，介绍自己所处的模块？ 分布式ESB单域架构图 分布式ESB多域架构图 二叉搜索树和平衡二叉树有什么关系？ 平衡二叉树也叫做平衡二叉搜索树，是二叉搜索树的升级版，二叉搜索树是指节点左边的所有节点都比该节点小，节点右边的节点都比该节点大，而平衡二叉搜索树是在二叉搜索的基础上还规定了节点左右两边的子树高度差的绝对值不能超过1。 强平衡二叉树和弱平衡二叉树有什么区别？ 强平衡二叉树AVL树，弱平衡二叉树就是我们说的红黑树。 AVL树比红黑树对于平衡的程度更加严格，在相同节点的情况下，AVL树的高度低于红黑树。 红黑树中增加了一个节点颜色的概念。 AVL树的旋转操作比红黑树的旋转操作更耗时。 B树和B+树的区别，为什么Mysql使用B+树？ B树的特点: 节点排序。 一个节点了可以存多个元素，多个元素也排序了。 B+树的特点: 拥有B树的特点。 叶子节点之间有指针。 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序。 Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在Mysql中一个Innodb页就是一个B+树节点，一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。 epoll和poll的区别？ select模型使用的是数组来存储Socket连接文件描述符，容量是固定的，需要通过轮询来判断是否发生了IO事件。 poll模型使用的是链表来存储Socket连接文件描述符，容量是不固定的，同样需要通过轮询来判断是否发生了IO事件。 epoll模型epoll和poll是完全不同的，epoll是一种事件通知模型，当发生了IO事件时，应用程序才进行IO操作，不需要像poll模型那样主动去轮询。 简述线程池原理，FixedThreadPool用的阻塞队列是什么？ 线程池内部是通过队列+线程实现的，当我们利用线程池执行任务时: 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。 如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过handler所指定的策略来处理此任务。 当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数FixedThreadPool代表定长线程池，底层用的LinkedBlockingQueue，表示无界的阻塞队列。 sychronized和ReentrantLock的区别？ sychronized是一个关键字，ReentrantLock是一个类。 sychronized会自动的加锁与释放锁，ReentrantLock需要程序员手动加锁与释放锁。 sychronized的底层是JVM层面的锁，ReentrantLock是API层面的锁。 sychronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁。 sychronized锁的是对象，锁信息保存在对象头中，ReentrantLock锁的是线程，通过代码中int类型的state标识来标识锁的状态。 sychronized底层有一个锁升级的过程。 sychronized的自旋锁、偏向锁、轻量级锁、重量级锁，分别介绍和联系？ 偏向锁在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了。 轻量级锁由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程。如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞。 自旋锁自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。 HTTPS是如何保证安全传输的？ https通过使用对称加密、非对称加密、数字证书等方式来保证数据的安全传输。 客户端向服务端发送数据之前，需要先建立TCP连接，所以需要先建立TCP连接，建立完TCP连接后，服务端会先给客户端发送公钥，客户端拿到公钥后就可以用来加密数据了，服务端到时候接收到数据就可以用私钥解密数据，这种就是通过非对称加密来传输数据。 不过非对称加密比对称加密要慢，所以不能直接使用非对称加密来传输请求数据，所以可以通过非对称加密的方式来传输对称加密的秘钥，之后就可以使用对称加密来传输请求数据了。 但是仅仅通过非对称加密＋对称加密还不足以能保证数据传输的绝对安全，因为服务端向客户端发送公钥时，可能会被截取。 所以为了安全的传输公钥，需要用到数字证书，数字证书是具有公信力、大家都认可的，服务端向客户端发送公钥时，可以把公钥和服务端相关信息通过Hash算法生成消息摘要，再通过数字证书提供的私钥对消息摘要进行加密生成数字签名，在把没进行Hash算法之前的信息和数字签名一起形成数字证书，最后把数字证书发送给客户端，客户端收到数字证书后，就会通过数字证书提供的公钥来解密数字证书，从而得到非对称加密要用到的公钥。 在这个过程中，就算有中间人拦截到服务端发出来的数字证书，虽然它可以解密得到非对称加密要使用的公钥，但是中间人是办法伪造数字证书发给客户端的，因为客户端上内嵌的数字证书是全球具有公信力的，某个网站如果要支持https，都是需要申请数字证书的私钥的，中间人如果要生成能被客户端解析的数字证书，也是要申请私钥的，所以是比较安全了。 设计模式有哪些大类，及熟悉其中哪些设计模式？ // todo volatile关键字，他是如何保证可见性，有序性？ 对于加了volatile关键字的成员变量，在对这个变量进行修改时，会直接将CPU高级缓存中的数据写回到主内存，对这个变量的读取也会直接从主内存中读取，从而保证了可见性。 在对volatile修饰的成员变量进行读写时，会插入内存屏障，而内存屏障可以达到禁止重排序的效果，从而可以保证有序性。 Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代？ 年轻代: Eden区(8) From Survivor区(1) To Survivor区(1) 老年代: 默认对象的年龄达到15后，就会进入老年代 Mysql的锁你了解哪些？ 按锁粒度分类 行锁锁某行数据，锁粒度最小，并发度高。 表锁锁整张表，锁粒度最大，并发度低。 间隙锁锁的是一个区间。 还可以分为 共享锁也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写。 排它锁也就是写锁，一个事务给某行数据加了写锁，其他事务不能读，也不能写。 还可以分为 乐观锁并不会真正的去锁某行记录，而是通过一个版本号来实现的。 悲观锁上面所说的行锁、表锁等都是悲观锁。 在事务的隔离级别实现中，就需要利用锁来解决幻读。 "},"pages/review/ReviewII.html":{"url":"pages/review/ReviewII.html","title":"题卷II","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 分布式的有状态和无状态 悲观锁和乐观锁 union和union all SpringBoot连接池 跨域 b+树索引？为什么建议最好不用uuid作为索引？ 可重入锁 Mysql默认的事物隔离级别 什么是分词器 Kafka如何保证顺序性 403是啥意思 1=1前面添加哪种符号实现sql注入 map的get()方法 Spring哪个注解实现动态添加配置信息的是否添加到Spring容器中 Spring哪种注解实现返回json格式的数据 Mybatis如何实现全局的limit offset，Mybatis拦截器 v-has Nginx实现图片的控制 explain truncate和delete的区别 索引失效，联合索引 count(*)和count(某个字段)的区别 哨兵模式可以扩容吗 redis的数据结构 zset是如何排序的 mybatis接口为啥就能执行sql语句 查找所有数量大于1的结果 ArrayList是如何实现remove操作的 如何保证缓存与数据库一致性的 类加载机制 双亲委派机制 哪些对象可以作为gc root G1收集器何时回收垃圾 traceId是如何传递的 Apollo是如何实现监听变化的 Spring创建过程 Redis过期策略 LinkedHashMap、TreeMap core size=0会出现什么情况 边车是如何保证交易发到后面的边车的 MVCC Java如何定位一个系统的卡顿 Kafka是如何保证消息不被重复消费的 Kafka是如何保证数据不被丢失的 Kafka是如何保证消息的顺序性的 工厂模式 HTTP 502是什么意思 (a, b, c)联合索引，只查询b会用到索引吗 什么是最左匹配原则 ThreadLocal为什么使用的弱引用 ThreadLocalMap中的Entry是什么数据结构，数组还是链表 对象什么时候从年轻代进入老年代 线程池有哪些拒绝策略 锁的升级原理，什么是轻量级锁，什么是重量级锁 Redis大key问题 题卷II 分布式的有状态和无状态 悲观锁和乐观锁 union和union all SpringBoot连接池 跨域 b+树索引？为什么建议最好不用uuid作为索引？ 可重入锁 Mysql默认的事物隔离级别 什么是分词器 Kafka如何保证顺序性 403是啥意思 1=1前面添加哪种符号实现sql注入 map的get()方法 Spring哪个注解实现动态添加配置信息的是否添加到Spring容器中 Spring哪种注解实现返回json格式的数据 Mybatis如何实现全局的limit offset，Mybatis拦截器 v-has Nginx实现图片的控制 explain truncate和delete的区别 索引失效，联合索引 count(*)和count(某个字段)的区别 哨兵模式可以扩容吗 redis的数据结构 zset是如何排序的 mybatis接口为啥就能执行sql语句 查找所有数量大于1的结果 ArrayList是如何实现remove操作的 如何保证缓存与数据库一致性的 类加载机制 双亲委派机制 哪些对象可以作为gc root G1收集器何时回收垃圾 traceId是如何传递的 Apollo是如何实现监听变化的 Spring创建过程 Redis过期策略 LinkedHashMap、TreeMap core size=0会出现什么情况 边车是如何保证交易发到后面的边车的 MVCC Java如何定位一个系统的卡顿 Kafka是如何保证消息不被重复消费的 Kafka是如何保证数据不被丢失的 Kafka是如何保证消息的顺序性的 工厂模式 HTTP 502是什么意思 (a, b, c)联合索引，只查询b会用到索引吗 什么是最左匹配原则 ThreadLocal为什么使用的弱引用 ThreadLocalMap中的Entry是什么数据结构，数组还是链表 对象什么时候从年轻代进入老年代 线程池有哪些拒绝策略 锁的升级原理，什么是轻量级锁，什么是重量级锁 Redis大key问题 "},"pages/review/ReviewIII.html":{"url":"pages/review/ReviewIII.html","title":"题卷III","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 自我介绍 面试类型 算法 技术栈 项目 个人&面试官 题卷III 自我介绍 一分钟左右的自我介绍，简要的描述出姓名、毕业时间、工作年限、工作经历、技术影响力(博客、Github、开源贡献、专利)等。 如果有较大型项目或者大家有一致性认知的项目和技术难点攻克，可以简单说出项目名称等。 方法论沉淀相关，架构设计能力、带过小组或者团队、跨部门协调、流程规范制定和执行等。 你要透露出的核心点就是个人的基本信息，以及项目和技术上的沉淀，给面试官留出和你聊下去的话题。 面试官好，我叫谢飞机，16年毕业于天津工业大学，软件工程专业，目前已工作4年。我从毕业后就职于途乐数字科技，负责营销和订单 系统开发。在系统搭建、代码优化、问题处理上有较丰富的经验和处理能力。同时也喜欢写一些技术博客和看一些技术书籍，另外在 Spring、Dubbo等源码学习上有过一些研究以及复用到业务开发中。感谢！ 面试类型 类型 解释 直接提问型 需要你有一定的技术栈广度和深度，问题往往也比较有跳跃性。但大部分题目会是热点问题，但可能不是日常开发中频率最高的技术点。 场景引导型 需要你有一定的开发架构经验和项目落地能力，这部分问题基本都会结合实际的业务场景进行提问，每一个场景就是一个复杂问题问题的解决能力。这里问到的场景会与你简历中的工作经历和项目相关，但复杂程度可能会超过你目前简历中的项目内容。比如你写了一个订单类的，那么会问你秒杀的实际解决方案。这样的问题很难背题应付，需要真的经历过，研究过。 连环追问型 从一个小的技术点开始，一层层往下剥，每一次的回答也几乎都是下一个问题的深入点的来源。这种问题不仅考察面试者，也是对面试官的考验。往往在招聘高级别开发时会进行定向深入挖掘提问，找到匹配的行业专家级技术人员。 压力逼问型 这种面试方式一般不多，但可能有的高级面试官会让你感受到这种气场。一方面是确实人家有这样的技术气势，另外一个是来自自己的紧张。如果会不是问题，还会在面试官那留下很高的打分。如果不会，那么会感觉到你越不会什么，面试官越问你什么。 算法 动态规划 数据结构 算法思维 排序 二分查找 回文链表 反链链表 数据结构设计 技术栈 项目 项目 解释 项目经验 1. 开发了哪些项目2. 重点项目是什么3. 你主要负责哪些4. 有过什么优化 工作业绩 中大型项目架构能力复杂项目落地能力重点项目执行落地交付能力&质量 技术沉淀 方法论流程规范制定交付质量公用组件建设开源项目复杂架构设计经验团队技术分享 工程师品质 认知范围，技术、业务、运营学习能力，接受能力创新技术，迁移能力 疑难问题处理 复杂问题推进解决能力紧急事故解决能力 项目推进 中大型项目推进落地资源协调安排流程规范实施 专业影响力 项目推进过程中方案执行落地带动他人共同完成，并赋予能力提升技术价值创造开源项目和专利 个人&面试官 个人&面试官 解释 个人 可能会有一个人性的问题介绍自己部门是什么的其他你早点入职 面试官 部门主要做什么业务入职后承担哪块有什么技术挑战需要提前学习了解的 "},"pages/review/ReviewIV.html":{"url":"pages/review/ReviewIV.html","title":"题卷IV","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 BIGO 内存泄露怎么分析？怎么知道整条内存泄露的链路？ 用的什么垃圾收集器？GC一次多久？线上多久一次Full GC？ 怎么进行JVM调优？何时需要做JVM调优？JVM调优量化目标？ 项目里有用过ConcurrentHashMap吗？ConcurrentHashMap底层结构有了解吗？ 你知道JDK7和JDK8之间的区别吗？ 用过Stream吗，讲讲？ sql优化的经历？ 讲讲ES，ES文档数据太多了怎么办？ RocketMQ集群的原理，消息堆积怎么办，推拉模式优劣？ 说下Raft协议？ 分布式ID的设计方案？ Redis集群的特性，分布式锁的设计？ 腾讯 HTTP/HTTPS，网络安全问题？ volatile和synchronized的区别？ JAVA内存模型？ Redis实现分布式锁与Zookeeper实现分布式锁的异同点？ Innodb讲讲？ ZAB讲讲？ 怎么分库分表？ 怎么自己实现IOC？ 用过哪些设计模式，讲讲？ 怎么判断一个链表是不是有环？ 自我介绍？ ES讲了个遍，包括基础原理和优化？ 分布式ID的生成方式？ 分布式事务相关知识，保证数据一致性？ 为什么要用分布式架构？又为什么要用微服务？ 快手 数据库连接不上了，怎么排查？ 双亲委派模型，有什么好处？ ThreadLocal讲讲？ 一次接口调用，在日志文件里打印“kuaishou ” + 耗时，比如“kuaishou 20ms”......有10w+条，用Linux的命令怎么查出来耗时最短的十条？耗时最长的呢？ 安装了一个软件，怎么在Linux找到他的路径？ 怎么查看JVM里线程状态？JVM使用情况？ CountDownLatch和CyclicBarrier有什么区别？ jps -m、jps -l用过吗？ 讲一下Spring事务底层是怎么实现的？ 菜鸟&嘀嘀 JVM内存溢出排查？ 网络编程相关的提问 并发包相关问题 线程池原理 Mysql索引、锁机制、隔离级别 Redis连环炮 Tomcat起两个war包，怎么识别哪个请求要给到哪个进程？ linux的命令，比如怎么查看给文件按大小排序，主要是查看日志相关的技巧命令？ volatile内存屏障具体是怎么实现？ JVM启动参数有哪些？怎么调优？ TLAB是什么？ Java内存逃逸 阻塞队列对比和选择？ DDD的理解？ Reactor模型？ 蚂蚁金服 CHM结构，线程安全保证，加锁实现细节？ JVM内存结构，垃圾回收原理，GC配合策略，排查过程细节和调优方案？ 线程安全的本质？ 并发锁，AQS原理 为什么AQS使用双向链表 ThreadLocal源码 Mysql幻读，怎么加锁 秒杀设计 淘宝 网络模型，NIO、Netty JVM，垃圾回收，调优，排查思路 Redis为什么快？使用场景？过期策略？ RocketMQ场景，如何保证不丢消息？ Spring Bean生命周期 线程池参数，执行顺序，场景？ Mysql存储引擎，索引？ 饿了么 CHM和HashTable JVM垃圾回收的原理，GC排查步骤 volatile，synchronized SQL优化，事务隔离级别 MQ的区别以及选型 Redis分布式锁 业务幂等实现 接口幂等实现 分库分表，MyCat底层实现原理 监控指标、业务分析、业务指标 亮点业务，好的项目 题卷IV BIGO 内存泄露怎么分析？怎么知道整条内存泄露的链路？ 内存泄露或内存持续使用较高时，通常通过堆的情况来排查。首先可以通过jmap -histo:live PID|less命令查看堆内对象使用情况。此时如果内存泄露，一般都是会某个基本类型对象过多，然后可以与正常的服务作对比，看哪个对象的数量异常的多，此时如果可以判断出来，也没必要dump了。如果通过jmap无法断定，则可以使用jmap -dump:live,format=b,file=命令生成dump文件。将dump文件通过java原生的软件或者eclipse的mat工具，就可以看到哪些对象占用过多，此时你应该关注的是非基本类型对象的其他对象，因为一般来说都是基本类型的数量和大小最多。 一般来说，你会看到以下现象: 某个map的Node十分多，有几十万个。 某个框架的某个对象十分多。 char数据，也就是C[]，占用十分多，因为有很多大字符串。 用的什么垃圾收集器？GC一次多久？线上多久一次Full GC？ G1 GC类型 执行时间(建议值) 执行频率(建议值) Yong GC >= 10s/次 Full GC >= 10/min // 每秒一次, 连续输出10次 GC信息 jstat -gc PID 1000 10 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 0.0 4096.0 0.0 4096.0 2637824.0 1824768.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1837056.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1853440.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1902592.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1910784.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1957888.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1968128.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 1974272.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 2023424.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 0.0 4096.0 0.0 4096.0 2637824.0 2033664.0 1552384.0 316716.7 216248.0 193369.5 25600.0 22631.0 162 2.778 0 0.000 2.778 参数 解释 S0C 第一个幸存区的大小 S1C 第二个幸存区的大小 S0U 第一个幸存区的使用大小 S1U 第二个幸存区的使用大小 EC 伊甸园区的大小 EU 伊甸园区的使用大小 OC 老年代大小 OU 老年代使用大小 MC 方法区大小 MU 方法区使用大小 CCSC 压缩类空间大小 CCSU 压缩类空间使用大小 YGC 年轻代垃圾回收次数 YGCT 年轻代垃圾回收消耗时间 FGC 老年代垃圾回收次数 FGCT 老年代垃圾回收消耗时间 GCT 垃圾回收消耗总时间 PS: 之前的PC、PU被MC、MU取代了。(永久代) 怎么进行JVM调优？何时需要做JVM调优？JVM调优量化目标？ 怎么进行JVM调优 调优参数 解释 -Xmx4g 堆内存最大值为4GB。 -Xms4g 初始化堆内存大小为4GB。 -Xss512k 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 ... ... 何时需要做JVM调优 heap内存(老年代)持续上涨达到设置的最大内存值； Full GC次数频繁； GC停顿时间过长(超过1秒)； 应用出现OutOfMemory等内存异常； 应用中有使用本地缓存且占用大量内存空间； 系统吞吐量与响应性能不高或下降。 JVM调优量化目标 Heap内存使用率 Old generation内存使用率 avg pause Full gc次数0 或 avg pause interval >= 24小时。 项目里有用过ConcurrentHashMap吗？ConcurrentHashMap底层结构有了解吗？ JDK1.7 底层数据结构: Segments数组 + HashEntry数组 + 链表，采用分段锁保证安全性。 容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。这就是ConcurrentHashMap所采用的”分段锁”思想。 一个ConcurrentHashMap中有一个Segments数组，一个Segments中存储一个HashEntry数组，每个HashEntry是一个链表结构的元素。 segment继承自ReentrantLock锁。首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。 可以通过构造函数指定，数组扩容不会影响其他的segment，get无需加锁，volatile保证内存可见性。 操作 解释 get() HashEntry中的value属性和next指针是用volatile修饰的，保证了可见性，所以每次获取的都是最新值，get过程不需要加锁。1. 将key传入get方法中，先根据key的hashcode的值找到对应的segment段。2. 再根据segment中的get方法再次hash，找到HashEntry数组中的位置。3. 最后在链表中根据hash值和equals方法进行查找。ConcurrentHashMap的get操作跟HashMap类似，只是ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。 put() 1. 将key传入put方法中，先根据key的hashcode的值找到对应的segment段。2. 再根据segment中的put方法，加锁lock()。3. 再次hash确定存放的hashEntry数组中的位置。4. 在链表中根据hash值和equals方法进行比较，如果相同就直接覆盖，如果不同就插入在链表中。 JDK1.8 底层数据结构: Synchronized + CAS + Node + 红黑树。Node的val和next都用volatile保证，保证可见性，查找、替换、赋值操作都使用CAS。 为什么在有Synchronized的情况下还要使用CAS？ 因为CAS是乐观锁，在一些场景中(并发不激烈的情况下)它比Synchronized和ReentrentLock的效率要高， 当CAS保障不了线程安全的情况下(扩容或者hash冲突的情况下)转成Synchronized来保证线程安全，大大 提高了低并发下的性能。 锁是锁的链表的head的节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作(因为扩容的时候使用的是Synchronized锁，锁全表)，并发扩容。 读操作无锁，Node的val和next使用volatile修饰，读写线程对该变量互相可见；数组用volatile修饰，保证扩容时被读线程感知。 操作 解释 get() get操作全程无锁。get操作可以无锁是由于Node元素的val和指针next是用volatile修饰的。 在多线程环境下线程A修改节点的val或者新增节点的时候是对线程B可见的。1. 计算hash值，定位到Node数组中的位置。2. 如果该位置为null，则直接返回null。3. 如果该位置不为null，再判断该节点是红黑树节点还是链表节点；如果是红黑树节点，使用红黑树的查找方式来进行查找；如果是链表节点，遍历链表进行查找。 put() 1. 先判断Node数组有没有初始化，如果没有初始化先初始化initTable()。 2. 根据key的进行hash操作，找到Node数组中的位置，如果不存在hash冲突，即该位置是null，直接用CAS插入。3. 如果存在hash冲突，就先对链表的头节点或者红黑树的头节点加synchronized锁。4. 如果是链表，就遍历链表，如果key相同就执行覆盖操作，如果不同就将元素插入到链表的尾部， 并且在链表长度大于8， Node数组的长度超过64时，会将链表的转化为红黑树。5. 如果是红黑树，就按照红黑树的结构进行插入。 👉 ConcurrentHashMap底层结构和原理详解 你知道JDK7和JDK8之间的区别吗？ 区别 解释 接口中的default方法 一般来说接口中的方法都是不实现的，基本通过实现类来实现方法。但是jdk8中提供了一种被default修饰的方法，可以直接在接口中进行实现。 lambda表达式 jdk8引入了lambda表达式，也可称为closure(闭包)，通常是在需要一个函数，但又不想费神去命名一个函数的场合下使用，也就是指匿名函数。lambda允许把函数作为一个方法的参数(函数作为参数传递进方法中)。由于其几乎被所有主流开发语言支持。是java8新引入的一种语法，是一种紧凑的传递代码的方式。使用lambda表达式可以使代码变的更加简洁紧凑。 函数式接口 函数式接口的引入是为了函数式编程的，函数式编程往往依赖于lambda表达式。定义函数式接口有两个步骤:1. 确保接口中有且仅有一个抽象方法；2. 使用注解@FunctionalInterface修饰接口。 StreamAPI JDK8中引入了StreamAPI，对于学过Flink或Spark的学者应该对此比较熟悉，其实就是类似于一种流式的数据处理，从dataSource到中间的operator操作，再到最后的dataSink。Stream的中间操作有map、filter等操作。而流式的数据处理往往就是通过函数式编程实现的。 移出永久代，元空间替换 JDK7使用永久代存储类的元数据，JDK8使用元空间存储类的元数据。元空间和永久代都是用来存储class相关信息，包括class对象的Method，Field等，元空间和永久代其实都是方法区的实现，只是实现有所不同，所以说方法区其实只是一种JVM的规范。两者最大的区别是元空间使用本地内存，而永久代使用的是JVM的内存。元空间优势就是元数据分配只受本地内存大小的限制。本地内存剩余多少理论上metaspace就可以有多大，这解决了空间不足的问题，不过也不可能任其无限壮大，JVM默认在运行时会根据需要动态的设置其大小。 HashMap中的优化 1. 增加红黑树。2. 解决jdk1.7多线程下的死循环。扩容使用尾插法，抛弃头插法。3. rehash的优化。jdk7扩容的rehash是重新计算桶的位置，而jdk8则进行了优化，不需要进行重新计算。 CurrentHashMap的优化 jdk7是使用分段锁实现线程安全，jdk8则使用synchronized关键字和大量的CAS操作实现。 用过Stream吗，讲讲？ 就根据平时使用说就好了，比较简单。 sql优化的经历？ 正确创建索引 建表时合理选择数据类型 不滥用事务 使用定时作业去优化结构 避免不必要的数据库连接 学会使用sql分析工具(profiler) 👉 sql数据库的优化 讲讲ES，ES文档数据太多了怎么办？ filesystem cache 数据预热 冷热分离 document模型设计 分页性能优化 不允许深度分页/默认深度分页性能很惨； 类似于app里的推荐商品不断下拉出来一页一页的。 👉 ES在数据量很大的情况下如何提高查询效率？ RocketMQ集群的原理，消息堆积怎么办，推拉模式优劣？ 模式 优点 缺点 推模式 1. 实时性强，有消息立马推送给客户端。2. 客户端实现简单，只需要监听服务端的推送即可。 1. 容易导致客户端发生消息堆积的情况，因为每个客户端的消费能力是不同的，如果简单粗暴的有消息就推送，就会会出现堆积情况。2. 服务端逻辑复杂，因为简单的推送会导致客户端出现堆积问题，所以服务端需要进行优化。记录给每个客户端的推送数据，然后根据每个客户端的消费能力去平衡数据推送的速度。 拉模式 1. 不会造成客户端消息积压，消费完了再去拉取，主动权在自己手中。2. 长轮询实现的拉模式实时性也能够保证。 1. 客户端的逻辑实现相对复杂点，简化了服务端的逻辑。 👉 消息队列，推拉模式的区别在哪？ 说下Raft协议？ Raft是一种实现分布式共识(一致性)的协议，也就是多个节点达成一致的协议。Raft算法想解决的核心问题是分布式共识问题。 分布式存储系统的核心问题之一: 维护多个副本的数据一致性。 Raft将一致性算法分为了几个部分，包括：领导选取(leader selection)、日志复制(log replication)、安全性(safety)、成员变更。 👉 Raft协议简介 分布式ID的设计方案？ 使用UUID生成ID 使用数据库单机自增生成 使用数据库集群模式自增生成 使用数据库号段模式自增生成 使用Redis单节点实现分布式ID 使用Redis集群实现分布式 利用Snowflake算法实现ID 使用Zookeeper生成ID 使用MongoDB创建ObjectID 👉 Java中分布式ID的设计方案 Redis集群的特性，分布式锁的设计？ Redis主从同步 哨兵模式 cluster集群模式 👉 redis集群、分布式锁 腾讯 HTTP/HTTPS，网络安全问题？ 👉 HTTPS如何解决HTTP存在的安全性问题 volatile和synchronized的区别？ 一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义: 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 参数 区别 volatile 1. 本质是在告诉jvm当前变量在寄存器(工作内存)中的值是不确定的，需要从主存中读取。2. 仅能使用在变量级别。3. 仅能实现变量的修改可见性，并不能保证原子性。4. 不会造成线程的阻塞。5. 标记的变量不会被编译器优化。 synchronized 1. 锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。2. 可以使用在变量、方法、类级别的。3. 可以保证变量的修改可见性和原子性。4. 可能会造成线程的阻塞。5. 标记的变量可以被编译器优化。 👉 synchronized和volatile的区别 JAVA内存模型？ JVM中试图定义一种JMM来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 JMM定义了8个操作来完成主内存和工作内存之间的交互操作。JVM实现时必须保证下面介绍的每种操作都是原子的(对于double和long型的变量来说，load、store、read和write操作在某些平台上允许有例外)。 操作 解释 lock(锁定) 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock(解锁) 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read(读取) 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 write(写入) 作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 load(载入) 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use(使用) 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。 assign(赋值) 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store(存储) 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write操作使用。 如果要把一个变量从主内存中复制到工作内存，就需要按序执行read和load操作；如果把变量从工作内存中同步回主内存中，就需要按序执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。 JMM还规定了上述8种基本操作，需要满足以下规则: read和load必须成对出现；store和write必须成对出现。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须把变化同步到主内存中。 不允许一个线程无原因的(没有发生过任何assign操作)把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量。换句话说，就是对一个变量实施use和store操作之前，必须先执行过了load或assign操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。所以lock和unlock必须成对出现。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中(执行store和write操作)。 👉 Java内存模型 👉 Java的内存模型是什么 Redis实现分布式锁与Zookeeper实现分布式锁的异同点？ Redis Zookeeper 1. 多个客户端(JVM)，会在Redis使用setnx命令创建相同的一个key，因为Redis的key保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。2. 在释放锁的时候，为了确保是锁的一致性问题，在删除的redis的key时候，需要判断同一个锁的id，才可以删除。3. 对key设置有效期解决死锁现象。 1. 多个客户端(JVM)，会在Zookeeper上创建同一个临时节点，因为Zookeeper节点命名路径保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。2. 使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入盗获取锁的步骤。3. 使用会话有效期方式解决死锁现象。 Innodb讲讲？ 把知道的都说出来就好了。行锁、MVCC、外键、一致性读...... ZAB讲讲？ ZAB协议全称: Zookeeper Atomic Broadcast(Zookeeper原子广播协议)。 Zookeeper是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper并没有使用Paxos，而是采用了ZAB协议。 ZAB协议定义: ZAB协议是为分布式协调服务。Zookeeper专门设计的一种支持崩溃恢复和原子广播协议。 基于该协议，Zookeeper实现了一种主备模式的系统架构来保持集群中各个副本之间数据一致性。 ZAB协议和我们之前看的Raft协议实际上是有相似之处的，比如都有一个Leader，用来保证一致性(Paxos并没有使用Leader机制保证一致性)。再有采取过半即成功的机制保证服务可用(实际上Paxos和Raft都是这么做的)。ZAB让整个Zookeeper集群在两个模式之间转换，消息广播和崩溃恢复，消息广播可以说是一个简化版本的2PC，通过崩溃恢复解决了2PC的单点问题，通过队列解决了2PC的同步阻塞问题。而支持崩溃恢复后数据准确性的就是数据同步了，数据同步基于事务的ZXID的唯一性来保证。通过+1操作可以辨别事务的先后顺序。 👉 ZAB算法详解 怎么分库分表？ 如果一个网站业务快速发展，那这个网站流量也会增加，数据的压力也会随之而来，比如电商系统来说双十一大促对订单数据压力很大，TPS十几万并发量，如果传统的架构(一主多从)，主库容量肯定无法满足这么高的TPS，业务越来越大，单表数据超出了数据库支持的容量，持久化磁盘IO，传统的数据库性能瓶颈，产品经理业务必须做，改变程序，数据库刀子切分优化。数据库连接数不够需要分库，表的数据量大，优化后查询性能还是很低，需要分。 👉 MySQL数据库之分库分表方案 怎么自己实现IOC？ 设计组件 设计接口 如何实现 👉 自己动手实现一个简单的IOC 用过哪些设计模式，讲讲？ 单例(双重校验锁)模式 动态代理模式 简单工厂模式 模板方法模式 建造者模式 怎么判断一个链表是不是有环？ 方法 解释 暴力双重循环 直接使用双重循环，没什么好讲的。 使用HashSet 在方法一的基础上进行优化降低复杂度，使用hashSet作为额外缓存，可以减少一层循环，具体思路如下:首先创建一个以节点ID为Key的HashSet集合，用来存储曾经遍历过的节点。然后同样从头节点开始，依次遍历单链表中的每一个节点。每遍历一个新节点，都用新节点和HashSet集合中存储的节点进行比较，如果发现HashSet中存在与之相同的节点ID，则说明链表有环，如果HashSet中不存在与新节点相同的节点ID，就把这个新节点ID存入HashSet中，之后进入下一节点，继续重复刚才的操作。使用HashSet将算法的时间复杂度降为了O(n)。 利用两个指针 首先创建两个指针p1和p2(在Java里就是两个对象引用)，让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。这种方法的时间复杂度同样是o(n)，但是双指针之外，没有额外使用存储空间，降低了空间复杂度。 public static boolean isLinkCycle(Node head) { Node p1 = head; Node p2 = head; while(p2 != null && p2.next != null) { p1 = p1.next; p2 = p2.next.next; if(p1 == p2) { return true; } return false; } 自我介绍？ 自我介绍要准备好，不要太长也不要太短，几句话说明自己的职业生涯的情况，重点的项目，用到的技能点概括进去就行。 ES讲了个遍，包括基础原理和优化？ // todo 分布式ID的生成方式？ // todo 分布式事务相关知识，保证数据一致性？ 两阶段提交 三阶段提交 👉 分布式环境下保证数据一致性的几种实现方式 为什么要用分布式架构？又为什么要用微服务？ 架构 优点 缺点 单体架构 1. 易于开发，开发的方式简单，方便运行也容易调试。2. 易于测试。3. 易于部署。 1. 项目过于臃肿，维护成本大，出现bug难定位。2. 资源无法隔离，共享一个数据库，或者一块内存。如果一个功能模块突然访问量过大，可能影响整个系统的性能。3. 无法灵活扩展，单体系统也可以集群部署，但是不够灵活，我明明只是订单系统遇到了瓶颈，只需要将订单模块水平扩展就行，但现在要将整个系统水平扩展。不灵活！4. 交付周期长，所有功能得一起上线、一起构建、一起部署。任何一个环节出错，都可能影响交付。 分布式架构 ...... 1. 分布式系统是跨进程，跨网络的，性能很收网络延迟和带宽的影响。2. 由于高度依赖网络状况，任何一次远程调用都可以失败。随着服务的增多，还会出现更多的潜在故障点。3. 引入各种中间件，异步通信大大增加了功能实现的复杂度。4. 分布式系统必然会有分布式事务的出现，这时对数据的一致性，需要在CAP中做出选择。5. 一个系统拆成了多个服务，每个服务都得配置、部署、监控、日志处理。 快手 数据库连接不上了，怎么排查？ 网络是否正常。 数据库服务是否正常。 数据库权限。 检查URL。 检查白名单。 检查防火墙。 双亲委派模型，有什么好处？ 是什么 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 简单来说就是首先从底向上检查类是否已经加载过，如果都没有加载过的话，那么就自顶向下的尝试加载该类。 为什么 原因 解释 避免字节码重复加载 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。 程序更加安全，核心API不会被替换 假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。相同的class文件被不同的classloader加载就是不同的两个类。 ThreadLocal讲讲？ ThreadLocal是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry(ThreadLocal，value)，虽然不同的线程之间ThreadLocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal(key)对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。 ThreadLocal如何解决Hash冲突 与HashMap不同，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式。所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经被其他的key值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。 / * Increment i modulo len. */ private static int nextIndex(int i, int len) { return ((i + 1 = 0) ? i - 1 : len - 1); } 为什么ThreadLocalMap的key是弱引用 key使用强引用这样会导致一个问题，引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，则会导致内存泄漏。 key使用弱引用，引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set()、get()、remove()的时候会被清除。 一次接口调用，在日志文件里打印“kuaishou ” + 耗时，比如“kuaishou 20ms”......有10w+条，用Linux的命令怎么查出来耗时最短的十条？耗时最长的呢？ test.log文件内容 kuaishou 50ms kuaishou 25ms kuaishou 100ms kuaishou 200ms kuaishou 13ms log info 1...... log info 2...... kuaishou 499ms log info 3...... kuaishou 1234ms kuaishou 123ms log info 4...... log info 5...... kuaishou 34ms kuaishou 45ms kuaishou 34ms kuaishou 55ms log info 6...... kuaishou 1234ms log info 7...... # 耗时最短的十条 grep kuaishou test.log|sort -g -k2|head -n 10 # 耗时最长的十条 grep kuaishou test.log|sort -r -g -k2|head -n 10 或者 grep kuaishou test.log|sort -g -k2|tail -n 10 安装了一个软件，怎么在Linux找到他的路径？ find 通过find查找某个关键字，可以得到结果，结果是否精准完全取决于你的关键字。 [root@sit1 ~]# find / -name mysql whereis(推荐) whereis除了可以找软件位置，还可以找到命令的二进制文件，源文件和手动页文件。 [root@sit1 ~]# 】whereis mysql which 准确的来说，which并不能找软件安装位置，只能查询软件命令的运行文件所在路径。 [root@sit1 ~]# which mysql locate locate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库(/var/lib/locatedb)，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 怎么查看JVM里线程状态？JVM使用情况？ # 线程使用情况 jstack PID # JVM使用情况 jmap -heap PID CountDownLatch和CyclicBarrier有什么区别？ CountDownLatch CyclicBarrier 1. CountDownLatch是不可重置的，所以无法重用。2. CountDownLatch的基本操作组合是countDown/await。调用await的线程阻塞等待countDown足够的次数，不管你是在一个线程还是多个线程里countDown，只要次数足够即可。所以说CountDownLatch操作的是事件。 1. CyclicBarrier则没有这种限制，可以重用。2. CyclicBarrier的基本操作组合，则就是await。当所有的伙伴(parties)都调用了await，才会继续进行任务，并自动进行重置。注意，正常情况下，CyclicBarrier的重置都是自动发生的，如果我们调用reset方法，但还有线程在等待，就会导致等待线程被打扰，抛出BrokenBarrierException异常。CyclicBarrier侧重点是线程，而不是调用事件，它的典型应用场景是用来等待并发线程结束。 jps -m、jps -l用过吗？ jps [options] [hostid] [options]选项 -q: 仅输出VM标识符，不包括classname、jar name、arguments in main method -m: 输出main method的参数 -l: 输出完全的包名、应用主类名，jar的完全路径名 -v: 输出jvm参数 讲一下Spring事务底层是怎么实现的？ 事务是基于AOP的机制进行实现的！ 👉 Spring事务底层的实现流程 菜鸟&嘀嘀 JVM内存溢出排查？ 内存溢出一般可能存在的情况: 实例化对象太大，超出空闲内存。 读取文件等操作，一次加载全部，全加载到内存，超出内存范围。 静态域做缓存，静态变量不会被GC机制处理，即使内存溢出。 大量无效强引用对象，GC不会处理强引用对象，可达性算法也不会标记活跃对象。 取样查看内存使用情况 jstat -gcutil 28506(PID) 1000 5 间隔一秒，取五次 jmap查看是否有jmap环境，生成jvm快照 jmap -dump:live,format=b,file=xx.hprof 28506(PID) 报以下错误，在语句中加-F Unable to open socket file :target process not responding or hotspot vm not loaded the -F option can be used when the target process is not responding jmap -F -dump:live,format=b,file=xx.hprof 28506(PID) 在内存溢出前生成JVM快照配置，启动脚本中加 export JAVA_OPTIONS=\"-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/app/oom\"; nohup $JAVA_OPTIONS -jar xxxx & java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/app/oom -jar xxx 网络编程相关的提问 // todo 并发包相关问题 JUC下的那些常⻅问题，ConcurrentHashMap、CountDownLatch等等这些都应该要熟悉掌握，面试必考点。 线程池原理 // todo Mysql索引、锁机制、隔离级别 // todo Redis连环炮 Redis连环炮，数据类型、缓存击穿、雪崩、穿透、热key、大key，哨兵、集群、同步机制......都应该了然于心。 Tomcat起两个war包，怎么识别哪个请求要给到哪个进程？ 👉 多war包部署在一个tomcat中 linux的命令，比如怎么查看给文件按大小排序，主要是查看日志相关的技巧命令？ [cloud@sit4 apps]$ du -s *|sort -g -k1 volatile内存屏障具体是怎么实现？ 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。 JVM这么插入是基于volatile关键字的特性: 保证volatile全局可见； 保障volatile的操作不会被重排序。 JVM启动参数有哪些？怎么调优？ // todo TLAB是什么？ TLAB的全称是Thread Local Allocation Buffer，翻译过来就是线程本地分配缓存。 首先从Thread Local这两个单词能够联想到一个本地线程变量类ThreadLocal，该类可以用来维护线程私有变量，而TLAB则是一个线程专用的内存分配区域，也是线程私有的。 在日常的业务过程中，Java对象会不断的被新建和不断的被回收，这就涉及到对象的分配了，而新建的对象一般都是分配在堆上，而堆却是线程共享的。所以如果同一时间，有多个线程要在堆上申请空间，这里可以类比多线程访问共享变量的操作，要保证共享变量的线程安全，就得采取线程安全的手段。所以每一次对象分配都要做同步，而越多的线程要在堆上申请空间，竞争就会越激烈，效率就会降低。因此Java虚拟机采用了TLAB这种线程专属的区域来避免出现多线程冲突，提高对象分配的效率。TLAB是默认启动的，在该情况下，JAVA虚拟机会为每一个线程都分配一个TLAB区域。 TLAB分配在eden区，因为eden区一般是新建对象所在的区域(这里去除大对象，因为大对象会直接进入老年代)。 # 以server模式运行，支持逃逸分析参数DoEscapeAnalysis -server # 关闭逃逸分析，避免出现栈上分配影响效果 -XX:-DoEscapeAnalysis # 禁止后台编译 -XX:-BackgroundCompilation # 禁用TLAB -XX:-UseTLAB 👉 什么是Java中的TLAB Java内存逃逸 👉 对象和数组并不是都在堆上分配内存的 👉 深入理解Java中的逃逸分析 阻塞队列对比和选择？ 如何选择适合自己的阻塞队列？ DDD的理解？ DDD是一种设计思想，通过敏捷演变而来，主要解决使系统减少重构风险，并且清晰规划业务架构、系统架构、技术架构，使系统在快速发展过程避免重构推倒重来。 解决系统架构不清晰、内聚低、耦合高； 减少重构风险； 使各业务边界清晰； 可以随业务发展可很好拓展。 👉 领域驱动设计在互联网业务开发中的实践 Reactor模型？ Reactor模型是应对高并发网络I/O请求的一种技术处理方案，主要用于处理客户端和服务器端的交互过程。 在Web服务中，处理Web请求时一般有两种体系，一种是多线程并发模式，服务器端每接收客户端的一个请求，就开启一个独立的线程来服务；还有一种是基于事件驱动，定义一系列事件与其对应的响应函数，并将服务器端接受连接与对事件的处理分离。而Reactor模型和Proactor模型便是事件驱动模型的两种实现方式，其中Reactor主要应用于同步I/O模式，而Proactor主要用于异步I/O模式。通过使用这样的模型，能够提高服务器处理I/O的性能。 👉 Reactor线程的三种模型 👉 Reactor模型 蚂蚁金服 CHM结构，线程安全保证，加锁实现细节？ // todo JVM内存结构，垃圾回收原理，GC配合策略，排查过程细节和调优方案？ // todo 线程安全的本质？ 原子性 有序性 可见性 并发锁，AQS原理 AQS(AbstractQueuedSynchronizer)在ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、ThreadPoolExecutor的Worker中都有运用(JDK 1.8)，AQS是这些类的底层原理。 为什么AQS使用双向链表 中断 唤醒 在队列同步器中，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态后将会唤醒其他后续节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点，如果是则尝试获取同步状态。所以为了能让后继节点获取到其前驱节点，同步队列便设置为双向链表，而等待队列没有这样的需求，就为单链表。 👉 为什么AQS使用双向链表 ThreadLocal源码 // todo Mysql幻读，怎么加锁 👉 MySQL如何使用锁解决幻读 秒杀设计 秒杀从流量过滤、缓存、异步队列、限流、降级这些方面说说就可以了。 淘宝 网络模型，NIO、Netty // todo JVM，垃圾回收，调优，排查思路 // todo Redis为什么快？使用场景？过期策略？ // todo RocketMQ场景，如何保证不丢消息？ // todo Spring Bean生命周期 实例化Bean Bean属性填充 初始化Bean 销毁Bean 👉 Spring中bean的生命周期 线程池参数，执行顺序，场景？ // todo Mysql存储引擎，索引？ 基本上就说Innodb和Myisam就行了，区别说清楚。 饿了么 CHM和HashTable // todo JVM垃圾回收的原理，GC排查步骤 // todo volatile，synchronized // todo SQL优化，事务隔离级别 // todo MQ的区别以及选型 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，比RocketMQ、Kafka低一个数量级 同ActiveMQ 10万级，支撑高吞吐 10万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景。 topic数量对吞吐量的影响 ---- ---- topic可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic。 topic从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka尽量保证topic数量不要过多，如果要支撑大规模的topic，需要增加更多的机器资源。 时效性 ms级 微秒级，这是RabbitMQ的一大特点，延迟最低 ms级 延迟在ms级以内。 可用性 高，基于主从架构实现高可用 同ActiveMQ 非常高，分布式架构 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用。 消息可靠性 有较低的概率丢失数据 基本不丢 经过参数优化配置，可以做到0丢失 同RocketMQ 功能支持 MQ领域的功能极其完备 基于erlang开发，并发能力很强，性能极好，延时很低 MQ功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用。 综上，各种对比之后，有如下建议: 一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了。后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的Java工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高。不过现在确实越来越多的公司会去用RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险(目前RocketMQ已捐给Apache，但GitHub上的活跃度其实不算高)对自己公司技术实力有绝对自信的，推荐用RocketMQ，否则回去老老实实用RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择。如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 Redis分布式锁 // todo 业务幂等实现 实现方式 解释 利用类似Mysql这种具有唯一性约束的数据库机制。 需要落库，比较重。 消费消息的时候，先根据唯一key值做一次select，有则不用消费，没有则消费。 select不一定是从关系型数据库中获取。 利用集合的contains方法。 分布式环境下可以借助redis来实现，存在网络消耗，且集合的大小需要确定一个固定大小，或者设计成一个队列，分布式网络环境下，如何本地缓存实现去重？ 利用分布式缓存(如redis)。 做已处理标识位，每次处理消息的时候都去check一下。 接口幂等实现 接口未做幂等带来的问题 填写某些form表单时，保存快速点了两次，数据库中新增两条相同的数据； 微服务调用超时重试； mq消费时读取到重复消息。 接口幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用，以上操作未做接口幂等的话都可能产生重复数据。 主要实现方式 过程 解释 悲观锁 select * from oder where order id = #{orderId} for update;对需要修改的数据加锁处理，判断业务是否已执行，已执行的话则返回错误；条件语句中需要时主键或唯一索引。 乐观锁 update stock set num=num-1 ,version=version+1 where id = #{id} and version = #{version}判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作,否则返回错误信息。 加唯一索引 alter table order add UNIQUE KEY un_code (code);通过是否抛出DuplicateKeyException判断请求是否插入成功。 状态机 业务是否具体一定顺序的状态。下单=>待支付=>已支付=>待发货=>完成。做业务操作时，更新条件中加上上一步的状态。 分布式锁 做业务操作时先获取到分布式锁才能继续业务操作，拿到锁后同时也需要判断业务是否已经操作完成。 分库分表，MyCat底层实现原理 // todo 监控指标、业务分析、业务指标 根据自己使用的监控系统来说，哪些监控项，为什么？告警策略是什么，指标，阈值。 亮点业务，好的项目 // todo "},"pages/review/ReviewV.html":{"url":"pages/review/ReviewV.html","title":"题卷V","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 阿里巴巴 对象如何进行深拷贝，除了clone？ happen-before原则？ JVM调优的实践？ 单例对象会被JVM的GC时回收吗？ Redis如果list较大，怎么优化？ Redis优化？ TCP的粘包与半包？ Socket编程相关的一些API和用法？ 建立和处理连接的是同一个Socket吗？Socket中两个队列分别是啥？ 项目中有使用过Netty吗？ TSL1.3新特性？ AES算法原理 Redis集群的使用 mysql与mogo对比 场景题: 设计一个im系统包括群聊单聊 场景题: 设计数据库连接池 场景题: 秒杀场景的设计 美团 项目详细信息，涉及一些AIOT交互处理，怎么实现大量的不同设备的指令编解码和指令转化，服务器的架构，自己责任模块 OOM的故障处理 有没有用过分布式锁，怎么实现的，讲讲原理 Redis的跳表用在哪里，为什么用跳表？ Mysql优化的实践经验 HashMap的1.8与1.7区别？ Netty的原理和使用 TCP的连接过程 Socket有几个队列 一台服务器能支持多少连接，为什么？ TCP各个参数怎么设置 Redis底层基本数据类型，redis集群原理，cluster集群的使用 Mysql存储引擎类型、索引类型，Innodb数据存储方式 线程池的参数说明，rejectHandler说明 volatile的原理 JVM有哪几种垃圾回收器，各自的应用场景 G1回收器的特征 JVM结构 负载均衡器的四层和七层负载均衡原理 场景题: 设计一个高可用高并发的电商系统 腾讯 Kafka生产端怎么实现幂等的 Kafka如何实现分布式消息 Kafka的slave的同步机制 Kafka怎么进行消息写入的ack 为什么实现equals()必须先实现hash() 一个对象new出来后的结构，怎么保存的 一个Java对象被new出来的全过程 讲一讲类加载的过程 Redis的hash数据结构和如何扩容 Mysql快照读怎么实现的 Mysql的事务隔离级别，不可重复读和幻读区别 YY JVM调优思路 Redis cluster集群扩容怎么数据平滑过度(从客户端设计) 两个Redis集群，如何平滑数据迁移 Mysql的sql本身没问题的情况下，没走索引原因？(反复强调sql没问题，不需要从sql⻆度考虑) Kafka如何确保消息不丢失 分库分表如何进行跨库联合查询 限流设计用JAVA实现，不能用工具类库 Dubbo的设计和完整调用过程(要详细) ES的脑裂问题怎么解决 得物 new一个对象的过程发生了什么 Spring循环引用解决的原理是什么？ FactoryBean和BeanFactory区别 Synchronized原理？ CAS volatile原理？ 内存模型？什么是主内存？什么是工作内存？ 数据库索引类型？原理？ Spring Bean生命周期？ Mysql优化经验？ Mysql锁类型？ Redis使用过程中应该注意什么问题？ JVM调优参数？ 线程池原理？属性代表含义？ HashMap、ConcurrentHashMap原理？ 饿了么 项目介绍，怎么不断优化项目、架构升级？如果业务量剧增，怎么保证系统高可用、扩展性？ 订单量、日新增多少？分库分表怎么做？基于什么维度去做？ 检测到JVM内存大于配置JVM的xmx配置的内存， 三台机器中的一台机器有上面这种现象，如何解释？ Redis热key怎么解决？ Kafka为什么性能高？ OOM场景分析？ Mysql集群是怎么部署的，主从同步？ Mysql双主相互备份是如何解决循环复制的？ 怎么设置使用什么GC方式？不同年代GC收集器有哪些？ 线上CPU很高怎么排查 JDK1.8的新特性 BIO、NIO了解 MQ怎么保证消息可靠性？ 系统负载过高怎么办？什么问题导致的？怎么排查？ Linux操作系统简单介绍有哪些东西？ 中通 JVM介绍 JMM模型 GC Root有哪些？ JVM调优经验？ JVM常用命令 线程池注意事项，异常处理 分布式锁使用和原理？ Redis怎么持久化？高可用？ RPC框架实现原理？ 接口调用变慢排查 为什么数据库TCP连接会被断开？ 业务系统架构，业务量 数据库设计，优化方案 鱼泡泡(比心) 比较有成就的项目 清结算怎么实现的？ 统一收银台设计？ RocketMq和Kafka区别，选型？ Kafka消息从生产到消费的流转过程？ HashMap、HashTable区别？ 对线程安全的理解？ CAS实现原理？ 代码加锁有几种实现方式？ 快速排序算法 分布式锁获取锁失败的处理，线程间的同步？ Redis线程模型，过期机制，淘汰策略？ 线程池参数、使用场景、参数设置分析？ Mysql存储引擎、索引结构、分库分表 场景题: 设计一个抢红包系统 题卷V 阿里巴巴 对象如何进行深拷贝，除了clone？ 构造函数 Apache Commons Lang序列化 Gson序列化 happen-before原则？ 原则 解释 单线程 在同一个线程中，书写在前面的操作happen-before后面的操作。 锁 同一个锁的unlock操作happen-before此锁的lock操作。 volatile 对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。 传递性 如果A操作happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。 线程启动 同一个线程的start方法happen-before此线程的其它方法。 线程中断 对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。 线程终结 线程中的所有操作都happen-before线程的终止检测。 对象创建 一个对象的初始化完成先于他的finalize方法调用。 JVM调优的实践？ 通过设置JVM启动参数 增大堆内存大小； 增大新生代大小(减少minor GC的同时，也会增加GC时长)； 提高年轻代晋升老年代的阈值。 针对每次业务处理使用的内存数量 代码上减少大对象的使用，或者是拆分大对象； 代码上减少对象的创建。 单例对象会被JVM的GC时回收吗？ 不会 判断是否可回收 以主流的JVM HotSpot来说，使用的是可达性分析，通过从GC Roots的引用作为起点，来判断对象可达性，从而决定是否回收该对象。那什么可以作为GC Roots呢？ 虚拟机栈(栈桢中的本地变量表)中的引用的对象。 方法区中的类静态属性引用的对象。 方法区中的常量引用的对象。 本地方法栈中JNI的引用的对象。 从单例模式创建的对象来看，可以判断其符合方法区中的类静态属性引用的对象这条定义。方法区中的类中的静态属性必然引用堆中的对象。那如此看，如果没办法解决方法区中的类的话，可以认为单例对象不会被回收。类会放在方法区，对象会放在堆中。 判断方法区中的类 再想深一层，什么情况下有可能触发方法区(JDK8-)或元数据区(JDK8+)中单例类消亡？这样的话，堆中的对象就不可达，从而会被回收。如果这个假想不现实，则可认为单例模式实现的对象不可回收。符合下列三点则可认为类卸载: 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的Class Loader已经被回收。 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。 要求相当苛刻，所以一般情况下可以认定不可回收了。 Redis如果list较大，怎么优化？ redis list分片，当redis的list数据量比较大时采用分片处理。 Redis优化？ Redis都是基于内存的操作，CPU不是Redis的性能瓶颈，服务器的内存利用率和网络IO才是Redis的性能瓶颈，Redis优化主要是从这2个维度做优化。 数据存储优化: 控制key的长度:在保证key在简单、清晰的前提下，尽可能把key定义得短一些来控制key的长度，如uerOrder:0001缩写为uo:0001。做好key规范管理的文档，定义好每个key缩写的含义。如按以上规范来做当Redis中有大量的key时也会节约Redis大量的内存空间，使其性能更高。 控制元素的大小:在决定使用Redis建议强制规定元素的大小，推荐如下规范: String类型数据的值控制在10K以下；List/Hash/Set/ZSet数据类型的元素要控制在1W以内。以上的是杜绝big key有效措施，在big key对Redis的性能影响是最为致命的。 存储合适数据类型:除非业务的强要求，建议选择合适的数据类型来优化内存。String/Set尽可能存储int类型数据；Hash/ZSet存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存。 设置过期key:强制要求所有的key必须设置过期时间，以优化Redis内存。 冷热分离:热key需要单独存放并分配合理的资源，防止大流量下直接冲垮整个缓存系统。 数据压缩:可以采用snappy/gzip等压缩算法来先将数据压缩后再存入缓存中来节约Redis的内存空间，但这种方法会使客户端在读取时还需要解压缩，在这期间会消耗更多CPU资源，你需要根据实际情况进行权衡。建议只是在Redis匮乏时的一种方案。 内存淘汰优化:杜绝使用默认的内存淘汰策略，避免在业务扩展下Redis的内存持续膨胀，需要根据你的业务设置对应内存淘汰策略。 过期策略优化:由于Redis采用的是定期删除+懒加载删除策略，且这个过程在Redis 6.0之前是在主线程上执行的，建议所有key的过期时间用随机数打散，杜绝大批量的数据同时过期，拉垮Redis的性能和造成缓存雪崩。 持久化优化:除非业务的强要求，否则不要开启AOF，避免写磁盘拖垮Redis的性能。如果有业务要求开启AOF，建议配置为appendfsync everysec把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低Redis写磁盘对性能的影响。 部署优化: 物理机部署:Redis在做数据持久化时，采用创建子进程的方式进行(会调用操作系统的fork系统)，而虚拟机环境执行fork的耗时要比物理机慢得多。 内网部署:Redis集群有做副本数据同步，为了解决网络问题建议整个集群都部署在同一个局域网中。 集群优化: 只使用db0:在一个连接上操作多个db数据时，每次都会先执行查询有额外开销；建议不同业务数据尽量存储到不同的实例中而不是存放在不同db中；Redis cluster只支持db0。 架构优化:读写分离能最大限度提高Redis的性能，其中主库负责数据写入，从库负责数据读取；分片集群是解决超大量数据导致性能瓶颈方案，如redis cluster。以上是在大流量下提高Redis性能在架构上的优化。 实例内存优化:Redis集群有做副本数据同步，如果Redis的内存过大，那么在做持久化或数据同步时，磁盘IO和网络IO会拉垮Redis性能导致卡顿。建议Redis每一个实例都不要超过8G，要从业务上解耦，不同的业务用不同的Redis实例，杜绝所有业务都使用同一个Redis实例。 其他优化: lazy-free机制:在Redis4.0+中支持，开启lazy-free机制后，由主线程删除big key，而较耗时的内存释放会在后台线程中执行，不会影响到主线程。 批量命令:尽量减少客户端和服务端之间来回的IO次数，建议string/hash类型使用mget/mset代替get/set，hmget/hmset代替hget/hset；其他数据类型使用pipeline。 避免复杂度过高命令:Redis是单线程模型处理请求，在执行复杂度过高的命令(消耗更多CPU资源)时后面的请求会排队导致延迟，如SORT/SINTER/SINTERSTORE/ZUNIONSTORE/ZINTERSTORE等聚合类命令。 注意容器类型数据:容器类型数据查询list、hash、set、zset类型数据在查询时要先确认元素的数量，元素非常多时需要分批查询(LRANGE/HASCAN/SSCAN/ZSCAN)，否则大量数据会导致延迟(如网络传输问题等)。容器类型数据删除建议分批删除，如list执行多次lpop/rpop；hash/set/zset先执行hscan/sscan/scan查询元素，再执行hdel/srem/zrem,不关注元素的数量直接del会有大量内存释放，拖垮主线程性能。 👉 Redis优化篇 TCP的粘包与半包？ TCP是面向连接的传输协议，TCP传输的数据是以流的形式 ，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。 发送方和接收方规定固定大小的缓冲区，也就是发送和接收都使用固定大小的byte[]数组长度，当字符长度不够时使用空字符弥补； 在TCP协议的基础上封装一层数据请求协议，既将数据包封装成数据头(存储数据正文大小)+数据正文的形式，这样在服务端就可以知道每个数据包的具体长度了，知道了发送数据的具体边界之后，就可以解决半包和粘包的问题了； 以特殊的字符结尾，比如以“\\n”结尾，这样我们就知道结束字符，从而避免了半包和粘包问题(推荐解决方案)。 👉 TCP粘包和半包问题及解决 Socket编程相关的一些API和用法？ API 解释 socket() 创建socket bind() 绑定socket到本地地址和端⼝，通常由服务端调⽤ listen() TCP专⽤，开启监听模式 accept() TCP专⽤，服务器等待客户端连接，⼀般是阻塞态 connect() TCP专⽤，客户端主动连接服务器 send() TCP专⽤，发送数据 recv() TCP专⽤，接收数据 sendto() UDP专⽤，发送数据到指定的IP地址和端⼝ recvfrom() UDP专⽤，接收数据，返回数据远端的IP地址和端⼝ closesocket() 关闭socket 建立和处理连接的是同一个Socket吗？Socket中两个队列分别是啥？ TCP三次握手建立连接的过程中，内核通常会为每一个LISTEN状态的Socket维护两个队列: SYN队列(半连接队列): 这些连接已经接到客户端SYN； ACCEPT队列(全连接队列): 这些连接已经接到客户端的ACK，完成了三次握手，等待被accept系统调用取走。 👉 计算机网络 项目中有使用过Netty吗？ Netty是一个基于JAVA NIO类库的异步通信框架，它的架构特点是异步非阻塞、基于事件驱动、高性能、高可靠性和高可定制性。Netty是基于Java NIO client-server的网络应用框架，使用Netty可以快速开发网络应用，例如服务器和客户端协议。Netty提供了一种新的方式来开发网络应用程序，这种新的方式使它很容易使用和具有很强的扩展性。Netty的内部实现是很复杂的，但是Netty提供了简单易用的API从网络处理代码中解耦业务逻辑。Netty是完全基于NIO实现的，所以整个Netty都是异步的。 分布式开源框架中Dubbo、Zookeeper，RocketMQ底层RPC通讯使用就是Netty。 TSL1.3新特性？ 👉 TLS 1.3科普 AES算法原理 Redis集群的使用 集群模式 特点 工作机制 主从 master进行读写操作，当读写操作导致数据变化时会自动将数据同步给slave。slave一般都是只读的，并且接收master同步过来的数据。一个master可以拥有多个slave，但是一个slave只能对应一个master。slave挂了不影响其他从数据库的读和master的读和写，重新启动后会将数据从master同步过来。master挂了以后，不会在slave节点中重新选一个master。 当slave启动之后，开始向master发送SYNC命令。master接收到SYNC命令后在后台保存快照(RDB持久化)和缓存保存快照这段的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。 Sentinel 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master。当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据。sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群。多个sentinel配置的时候，sentinel之间也会自动监控。Sentinel不能和Redis部署在同一台机器，否则Redis的服务器一挂，sentinel也挂了。 sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个PING命令 。如果一个实例距离最后一次有效回复PING命令的时间超过down-after-milliseconds选项所指定的值，则这个实例会被sentinel标记为主观下线。如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态。在一般情况下，每个sentinel会以每10秒一次的频率向它已知的所有master，slave发送INFO命令。当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送INFO命令的频率会从10秒一次改为1秒一次。 Cluster 多个redis节点网络互联，数据共享所有的节点都是一主一从(也可以是一主多从)，其中从不提供服务，仅作为备用。不支持同时处理多个key(如MSET/MGET)，因为redis需要把key均匀分布在各个节点上、并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为。支持在线增加、删除节点客户端可以连接任何一个主节点进行读写。 ---- mysql与mogo对比 // todo 场景题: 设计一个im系统包括群聊单聊 // todo 场景题: 设计数据库连接池 👉 如何设计数据库连接池 场景题: 秒杀场景的设计 // todo 美团 项目详细信息，涉及一些AIOT交互处理，怎么实现大量的不同设备的指令编解码和指令转化，服务器的架构，自己责任模块 // todo OOM的故障处理 故障类型 出现场景 原因分析 解决方案 Java heap space 当堆内存(Heap Space)没有足够空间存放新创建的对象时，就会抛出java.lang.OutOfMemoryError:Java heap space错误(根据实际生产经验，可以对程序日志中的OutOfMemoryError配置关键字告警，一经发现，立即处理)。 1. 请求创建一个超大对象，通常是一个大数组。2. 超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。3. 过度使用终结器(Finalizer)，该对象没有立即被GC。4. 内存泄漏(Memory Leak)，大量对象引用没有释放，JVM无法对其自动回收，常见于使用了File等资源没有回收。 1. 通过-Xmx参数调高JVM堆内存空间。2. 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果而没有做结果数限制。3. 如果是业务峰值压力，可以考虑添加机器资源或者做限流降级。4. 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。 GC overhead limit exceeded 当Java进程花费98%以上的时间执行GC，但只恢复了不到2%的内存，且该动作连续重复了5次，就会抛出java.lang.OutOfMemoryError:GC overhead limit exceeded错误。简单地说就是应用程序已经基本耗尽了所有可用内存，GC也无法回收。 同Java heap space 同Java heap space Permgen space 该错误表示永久代(Permanent Generation)已用满，通常是因为加载的class数目太多或体积太大。 永久代存储对象主要包括以下几类: 1. 加载/缓存到内存中的Class定义，包括类的名称、字段、方法和字节码；2. 常量池；3. 对象数组/类型数组所关联的class；4. JIT编译器优化后的class信息。PermGen的使用量与加载到内存的Class的数量/大小正相关。 1. 程序启动报错，修改-XX:MaxPermSize启动参数，调大永久代空间。2. 应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份class信息，只需重启JVM即可解决。3. 运行时报错，应用程序可能会动态创建大量class，而这些class的生命周期很短暂，但是JVM默认不会卸载class，可以设置-XX:+CMSClassUnloadingEnabled和-XX:+UseConcMarkSweepGC这两个参数允许JVM卸载class。 Metaspace JDK1.8使用Metaspace替换了永久代(Permanent Generation)，该错误表示Metaspace已被用满，通常是因为加载的class数目太多或体积太大。 同Permgen space 同Permgen space。注意的是调整Metaspace空间大小的启动参数为-XX:MaxMetaspaceSize。 Unable to create new native thread 每个Java线程都需要占用一定的内存空间，当JVM向底层操作系统请求创建一个新的native线程时，如果没有足够的资源分配就会报此类错误。 JVM向OS请求创建native线程失败，就会抛出Unable to create new native thread，常见的原因包括以下几类:1. 线程数超过操作系统最大线程数ulimit限制；2. 线程数超过kernel.pid_max(只能重启)；3. native内存不足。 1. JVM内部的应用程序请求创建⼀个新的Java线程；2. JVM native方法代理了该次请求，并向操作系统请求创建一个native线程；3. 操作系统尝试创建一个新的native线程，并为其分配内存；4. 如果操作系统的虚拟内存已耗尽或是受到32位进程的地址空间限制，操作系统就会拒绝本次native内存分配；5. JVM将抛出java.lang.OutOfMemoryError: Unable to create new native thread错误。 Out of swap space 该错误表示所有可用的虚拟内存已被耗尽。虚拟内存(Virtual Memory)由物理内存(Physical Memory)和交换空间(Swap Space)两部分组成。当运⾏时程序请求的虚拟内存溢出时就会报Out of swap space错误。 1. 地址空间不⾜；2. 物理内存已耗光；3. 应用程序的本地内存泄漏(native leak)，例如不断申请本地内存，却不释放。4. 执行jmap-histo:live命令，强制执行Full GC；如果几次执行后内存明显下降，则基本确认为Direct ByteBuffer问题。 1. 升级地址空间为64bit。2. 使用Arthas检查是否为Inflater/Deflater解压缩问题，如果是则显式调用end方法。3. Direct ByteBuffer问题可以通过启动参数-XX:MaxDirectMemorySize调低阈值。4. 升级服务器配置/隔离部署，避免争用。 Kill process or sacrifice child 有一种内核作业(Kernel Job)名为Out of Memory Killer，它会在可用内存极低的情况下杀死(kill)某些进程。OOM Killer会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考Surviving the Linux OOM Killer。不同于其他的OOM错误，Kill processor sacrifice child错误不是由JVM层面触发的，而是由操作系统层面触发的。 默认情况下，Linux内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。然而这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时系统将自动激活OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。 1. 升级服务器配置/隔离部署，避免争用。2. OOM Killer调优。 Requested array size exceeds VM limit JVM限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。JVM在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为Integer.MAX_VALUE-2。此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。 ---- ---- Direct buffer memory Java允许应用程序通过Direct ByteBuffer直接访问堆外内存，许多高性能程序通过Direct ByteBuffer结合内存映射文件(MemoryMapped File)实现高速IO。 Direct ByteBuffer的默认大小为64MB，一旦使用超出限制就会抛出Direct buffer memory错误。 1. Java只能通过ByteBuffer.allocateDirect方法使用Direct ByteBuffer，因此可以通过Arthas等在线诊断工具拦截该方法进行排查。2. 检查是否直接或间接使用了NIO，如netty、jetty等。3. 通过启动参数-XX:MaxDirectMemorySize调整Direct ByteBuffer的上限值。4. 检查JVM参数是否有-XX:+DisableExplicitGC选项，如果有就去掉，因为该参数会使System.gc()失效。5. 检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用sun.misc.Cleaner的clean()方法来主动释放被Direct ByteBuffer持有的内存空间。6. 内存容量确实不足，升级配置。 有没有用过分布式锁，怎么实现的，讲讲原理 数据库 zookeeper redis 👉 分布式锁原理及实现 Redis的跳表用在哪里，为什么用跳表？ 跳跃表以有序的方式在层次化的链表中保存元素，在大多数情况下，跳跃表的效率可以和平衡树媲美，查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。所以在Redis中没有使用平衡树，而是使用了跳跃表。 跳跃表的结构是多层的，通过从最高维度的表进行检索再逐渐降低维度从而达到对任何元素的检索接近线性时间的目的O(logn)。理想的跳表是每一层是下一层元素的1/2，即每个元素跳过2个元素，这样共有log2N层。但是这样插入删除元素就会很复杂，ex插入一个元素需要更新所有层相关的节点。所以通常的做法：没次向跳表加入一个元素时，用扔硬币的方式决定要不要向上增长一层。 👉 5分钟了解Redis的内部实现跳跃表 Mysql优化的实践经验 优化目标 减少IO次数，IO永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操作中超过90%的时间都是IO操作所占用的，减少IO次数是SQL优化中需要第一优先考虑，当然也是收效最明显的优化手段。 降低CPU计算，除了IO瓶颈之外，SQL优化中需要考虑的就是CPU运算量的优化了。order by、group by、distinct等等都是消耗CPU的大户(这些操作基本上都是CPU处理内存中的数据比较运算)。当我们的IO优化做到一定阶段之后，降低CPU计算也就成为了我们SQL优化的重要目标。 少join 少排序 避免select * 用join代替子查询 少or 用union all代替union 早过滤 避免类型转换 👉 MySQL性能调优最佳实践经验 HashMap的1.8与1.7区别？ 版本号 结构 1.7 数组+链表 1.8 数组+链表+红黑树(当链表长度>8且数组长度>=64时链表会转成红黑树，当长度 Netty的原理和使用 TCP的连接过程 过程 解释 LISTEN 侦听来自远方的TCP端口的连接请求。 SYN-SENT 再发送连接请求后等待匹配的连接请求。 SYN-RECEIVED 再收到和发送。 第一次握手。建立连接后，客户端向服务器发送syn包(syn=j)，进入SYN_SEND状态，等待服务器确认。 第二次握手。当服务器收到syn包时，必须确认客户端的syn(ack=j+1)并发送一个syn包(syn=k)，即syn+ack包。此时服务器进入SYN_RECV状态。 第三次握手。SYN+ACK包，客户端收到服务器端发来的确认包ACK(ACK=k+1)，来发送这个包来发送，客户端和服务器端进入建立状态，完成三次握手。 Socket有几个队列 LISTEN状态的Socket维护的两个队列。 SYN队列(半连接队列)，这些连接已经接到客户端SYN。 ACCEPT队列(全连接队列)，这些连接已经接到客户端的ACK，完成了三次握手，等待被accept系统调用取走。 一台服务器能支持多少连接，为什么？ 实际情况下，每创建一个链接需要消耗一定的内存，大概是4-10kb，所以链接数也受限于机器的总内存。(链接发起端，活力全开才64000左右链接，内存最多才占用640M，一般客户端都能满足；内存限制主要还是考虑服务器端。) 👉 单台服务器最大支持多少连接数 👉 一台服务器能支撑多少个TCP连接 TCP各个参数怎么设置 👉 TCP参数设置 Redis底层基本数据类型，redis集群原理，cluster集群的使用 // todo Mysql存储引擎类型、索引类型，Innodb数据存储方式 // todo 线程池的参数说明，rejectHandler说明 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 👉 线程池参数及使用说明 volatile的原理 可见性 有序性 👉 深入理解volatile底层原理 JVM有哪几种垃圾回收器，各自的应用场景 JVM垃圾回收器是GC算法的具体实现。常用的垃圾回收器有以下几种，并且分别针对的是堆内存中的新生代、老年代。值得一提的是方法区(有的文章也将之称为永久代，主要存放类信息、常量池、静态类变量等)也会触发GC，主要是回收不可存活的常量对象以及无用类(当该类在程序中不再存在任何实例、对应的classloader被卸载、该类的类对象class不被任何地方引用，此时可以被回收)。 JVM垃圾回收器 特性 Serial垃圾回收器 简要概括下该回收器的特点: 单线程，基于复制算法，JVM运行在Client时默认的新生代垃圾收集器。可以说Serial是最基本的垃圾回收器，使用的是复制算法，回收效率高，不容易产生不连续的内存碎片。并且也是单线程的垃圾回收器，只使用一个线程完成垃圾回收工作，并且此时会暂停其他工作线程。 ParNew垃圾回收器(Serial+多线程版本) 简要概括下该回收器的特点: Serial的多线程实现，基于复制算法，JVM运行在Server时默认的新生代垃圾收集器。该垃圾回收器是Serial的多线程版本，采用的也是复制算法(毕竟都是作用于新生代嘛)，也是在执行垃圾回收收集时需要暂停其他工作线程。默认开启与CPU相同数目的线程数，可以通过参数-XX：ParallerGCThreads来修改默认开启的线程数量。 Parallel Scavenge垃圾回收器(多线程复制算法) 简要概括下该回收器的特点: 多线程，基于复制算法，以吞吐量最大化为目标，允许较长时间的STW换取吞吐量。该回收器也是新生代的GC回收器，同样采用复制算法，多线程的策略。主要关注的吞吐量(即CPU运行用户代码的时间/CPU总消耗的时间，吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))。 Serial Old 垃圾回收器(单线程标记整理算法) 简单概括下该回收器的特点: 单线程，基于标记整理算法，是JVM运行在Client模式下默认的老年代垃圾回收器，可和Serial搭配使用。Serial Old回收器时Serial回收器的老年代版本，也是单线程，但采用的标记整理的算法。这里注意最重要的特点就是这两种回收器都会使得工作线程被停止，并且均是单线程模式。与两个Serial不同的是，Scavenge/ParNew采用的是多线程版本，但是此时也会暂停其他工作线程。 Parallel Old垃圾回收器(多线程标记整理算法) 简单概括下该垃圾回收器的特点: 多线程，基于标记整理算法，优先考虑系统的吞吐量。该垃圾回收器是Paraller Scavenge的老年代版本，多线程、标记整理。在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。 CMS垃圾回收器(多线程标记清楚算法) 简单概括下该垃圾回收器的特点：多线程，基于标记清除算法，为老年代设计，追求最短停顿时间。主要有四个步骤：初始标记、并发标记、重新标记、并发清除。不会暂停用户工作线程。全称为Concurrent mark sweep，该回收器是专门为老年代设计的，主要追求的是最短的停顿时间，采用的标记清楚算法。四个主要工作阶段的内容为: 1. 初始标记，标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。(这里简要回顾下哪些对象可以作为GC Roots: java虚拟机栈中的引用对象；方法区中的常量引用对象；方法区中的静态变量引用的对象；本地方法栈中一般Native方法引用的对象。)2. 并发标记，进行GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。3. 重新标记，为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。4. 并发清除，清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 G1垃圾回收器 ---- G1回收器的特征 简要概括下该垃圾回收器的主要特点: 将堆内存分为几个大小固定的独立区域，在后台维护了一个优先列表，根据允许的收集时间回收垃圾收集价值最大的区域。相比CMS不会产生内存碎片，并且可精确控制停顿时间。分为四个阶段: 初始标记、并发标记、最终标记、筛选回收。 该垃圾回收器看似和CMS工作流程差不多。采用的却是标记清楚算法，但是本质上还是存在差别，尤其是讲堆内存分为大小固定的几个区域，并且维持了一个优先列表，选取其中最有价值的回收垃圾。 Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收集器两个最突出的改进是: 基于标记-整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾 最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。 JVM结构 👉 JVM内存结构 负载均衡器的四层和七层负载均衡原理 负载均衡 解释 四层负载均衡 四层的负载均衡就是基于IP+端口的负载均衡。在三层负载均衡的基础上，通过发布三层的IP地址(VIP)，然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行NAT处理，转发至后台服务器，并记录下这个TCP或者UDP的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。对应的负载均衡器称为四层交换机(L4 switch)，主要分析IP层及TCP/UDP层，实现四层负载均衡。此种负载均衡器不理解应用协议(如HTTP/FTP/MySQL等等)，常见例子有LVS、F5。 七层负载均衡 七层的负载均衡就是基于虚拟的URL或主机IP的负载均衡。在四层负载均衡的基础上(没有四层是绝对不可能有七层的)，再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据VIP加80端口辨别是否需要处理的流量，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的Web服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。 👉 负载均衡之四层与七层 场景题: 设计一个高可用高并发的电商系统 // todo 腾讯 Kafka生产端怎么实现幂等的 # 配置幂等性 props.put(\"enable.idempotence\", true); 为了实现生产者的幂等性，Kafka引入了Producer ID(PID)和Sequence Number的概念。 每个Producer在初始化时，都会分配一个唯一的PID，这个PID对用户来说是透明的。 针对每个生产者(对应PID)发送到指定主题分区的消息都对应一个从0开始递增的Sequence Number。 👉 Kafka如何保证幂等性 Kafka如何实现分布式消息 Kafka的slave的同步机制 producer先从zookeeper的\"/brokers/.../state\"节点找到该partition的leader； producer将消息发送给该leader； leader将消息写入本地log； followers从leader pull消息，写入本地log后leader发送ACK； leader收到所有ISR中的replica的ACK后，增加HW(high watermark，最后commit的offset)并向producer发送ACK。 👉 kafka同步机制 👉 kafka消息与同步机制 Kafka怎么进行消息写入的ack Kafka的ack机制，指的是producer的消息发送确认机制，这直接影响到Kafka集群的吞吐量和消息可靠性。而吞吐量和可靠性就像硬币的两面，两者不可兼得，只能平衡。 ack值 解释 ack=1 简单来说就是，producer只要收到一个分区副本成功写入的通知就认为推送消息成功了。这里有一个地方需要注意，这个副本必须是leader副本。只有leader副本成功写入了，producer才会认为消息发送成功。 ack=0 简单来说就是，producer发送一次就不再发送了，不管是否发送成功。 ack=-1 简单来说就是，producer只有收到分区内所有副本的成功写入的通知才认为推送消息成功了。 为什么实现equals()必须先实现hash() 对于对象集合的判重，如果一个集合含有100个对象实例，仅仅使用equals()方法的话，那么对于一个对象判重就需要比较4950次，随着集合规模的增大，时间开销是很大的。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在定位到大概存储位置后，后续比较过程中，如果两个对象的hashCode不相同，也不再需要调用equals()方法，从而大大减少了equals()比较次数。所以从程序实现原理上来讲的话，既需要equals()方法，也需要hashCode()方法。那么既然重写了equals()，那么也要重写hashCode()方法，以保证两者之间的配合关系。 一个对象new出来后的结构，怎么保存的 堆内存是用来存放由new创建的对象和数组，即动态申请的内存都存放在堆内存； 栈内存是用来存放在函数中定义的一些基本类型的变量和对象的引用变量。 例子: 局部变量存放在栈；new函数和malloc函数申请的内存在堆；函数调用参数，函数返回值，函数返回地址存放在栈。 内存类型 解释 栈区(stack) 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区(heap) 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 一个Java对象被new出来的全过程 检查常量池中有没有一个符号代表这个类。 检查这个类有没有被加载。 在堆上或者TLAB上为对象分配内存空间。 为对象的实例属性赋领值。 设置对象头(Object_header)信息。比如对象是那个类的实例、对象的Hash码、GC分代年龄、锁状态标志、是否启用偏向锁等等。 对象引用入栈。 讲一讲类加载的过程 👉 简述类加载过程详解 Redis的hash数据结构和如何扩容 渐进式rehash 在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到ht[1]的话，可能会导致服务器在一段时间内停止服务。所以，采用渐进式rehash的方式，详细步骤如下: 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。将rehashindex的值设置为0，表示rehash工作正式开始。在rehash期间，每次对字典执行增删改查操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1。随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将rehashindex的值设置为-1，表示rehash操作结束。渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。需要注意的是在渐进式rehash的过程，如果有增删改查操作时，如果index大于rehashindex，访问ht[0]，否则访问ht[1]。 👉 redis中hash扩容过程 Mysql快照读怎么实现的 Innodb存储引擎的快照读是基于多版本并发控制MVCC和undo log实现，通过MVCC机制提高系统读写并发性能，快照读只发生于select操作，但不包括select ... lock in share mode，select ... for update。 Mysql的事务隔离级别，不可重复读和幻读区别 事务隔离级别 解释 脏读 一个事务读取到另一个事务还没有提交的数据。 不可重复读(修改) 在一个事务中多次读取同一个数据时，结果出现不一致。 幻读(插入/删除) 在一个事务中，使用相同的SQL两次读取，第二次读取到其他事务新插入的行。 👉 一篇文章读懂 MySQL 事务中的四种隔离级别 YY JVM调优思路 // todo Redis cluster集群扩容怎么数据平滑过度(从客户端设计) 👉 Redis cluster集群扩容缩容原理 两个Redis集群，如何平滑数据迁移 基于Redis自身的RDB/AOF备份机制。 基于redis-dump导入导出json备份。 基于redis-shake实现redis-cluster迁移。 👉 面试官: 两个Redis集群，如何平滑数据迁移？ Mysql的sql本身没问题的情况下，没走索引原因？(反复强调sql没问题，不需要从sql⻆度考虑) 当表的索引被查询，会使用最好的索引，除非优化器使用全表扫描更有效。优化器优化成全表扫描取决与使用最好索引查出来的数据是否超过表的30%的数据。 👉 为什么mysql没走索引？ Kafka如何确保消息不丢失 // todo 分库分表如何进行跨库联合查询 可以使用第三方中间件来实现，比如mycat、shading-jdbc。 当客户端发送一条sql查询select * from user;此时中间件会根据有几个子表，拆分成多个语句select * from user1; select * from user2; select * from user3;等多条语句查询，然后将查询的结果返回给中间件，然后汇总给客户端。这些语句是并发执行的，所以效率会很高。 限流设计用JAVA实现，不能用工具类库 限流顾名思义，就是对请求或并发数进行限制；通过对一个时间窗口内的请求量进行限制来保障系统的正常运行。如果我们的服务资源有限、处理能力有限，就需要对调用我们服务的上游请求进行限制，以防止自身服务由于资源耗尽而停止服务。 阈值: 在一个单位时间内允许的请求量。如QPS限制为10，说明1秒内最多接受10次请求。 拒绝策略: 超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等。 👉 java如何进行限流？ Dubbo的设计和完整调用过程(要详细) // todo ES的脑裂问题怎么解决 什么是脑裂现象 在ElasticSearch集群初始化或者主节点宕机的情况下，由候选主节点中选举其中⼀个作为主节点。指定候选主节点的配置为node.master: true。当主节点负载压力过大，或者集群环境中的网络问题，导致其他节点与主节点通讯的时候，主节点没来及响应，这样的话，某些节点就认为主节点宕机，重新选择新的主节点，这样的话整个集群的工作就有问题了，比如我们集群中有10个节点，其中7个候选主节点，1个候选主节点成为了主节点，这种情况是正常的情况。但是如果现在出现了我们上面所说的主节点响应不及时，导致其他某些节点认为主节点宕机而重选主节点，那就有问题了，这剩下的6个候选主节点可能有3个候选主节点去重选主节点，最后集群中就出现了两个主节点的情况，这种情况官方成为“脑裂现象”。集群中不同的节点对于master的选择出现了分歧，出现了多个master竞争，导致主分片和副本的识别也发生了分歧，把一些分歧中的分片标识为了坏片。 脑裂问题成因 解释 网络问题 集群间的网络延迟导致一些节点访问不到master，认为master挂掉了从而选举出新的master，并对master上的分片和副本标红，分配新的主分片。 节点负载 主节点的角色既为master又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。 内存回收 data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。 解决方案 解释 角色分离 即master节点与data节点分离，限制角色；数据节点时需要承担存储和搜索的工作的，压力会很大。所以如果该节点同时作为候选主节点和数据节点，那么一旦选上它作为主节点了，这时主节点的工作压力将会非常大，出现脑裂现象的概率就增加了。 减少误判 配置主节点的响应时间，在默认情况下，主节点3秒没有响应，其他节点就认为主节点宕机了，那我们可以把该时间设置得长一点，该配置是discovery.zen.ping_timeout:5。 选举触发 discovery.zen.minimum_master_nodes:1(默认是1)，该属性定义的是为了形成一个集群，有主节点资格并互相连接的节点的最小数目。一个有10节点的集群，且每个节点都有成为主节点的资格，discovery.zen.minimum_master_nodes参数设置为6。正常情况下，10个节点，互相连接，大于6，就可以形成一个集群。若某个时刻，其中有3个节点断开连接。剩下7个节点，大于6，继续运行之前的集群。而断开的3个节点，小于6，不能形成一个集群。该参数就是为了防止脑裂的产生，建议设置为(候选主节点数/2)+1。 👉 ES脑裂问题分析及优化 得物 new一个对象的过程发生了什么 当虚拟机遇到一条new指令时，会去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查代表的类是否已经被类加载器加载。如果没有被加载那么必须先执行这个类的加载。 类加载检查通过后，虚拟机将为新对象分配内存，对象所需内存的大小在类加载后便可以确定。 内存分配完成后，虚拟机需要将对象初始化为零值，保证对象的实例变量在代码中不赋初始值就能直接使用。类变量在类加载的准备阶段初始化为零值。 对对象头进行必要信息的设置，比如如何找到类的元数据信息、对象的HashCode、GC分代年龄等。 经过上述操作，一个新的对象已经产生，但是方法还没有执行，所有的字段都是零值。这时候需要执行方法(构造方法)把对象按照程序员的意愿进行初始化。类变量的初始化操作在类加载的初始化阶段方法完成。 👉 new一个对象的时候发生了什么？ Spring循环引用解决的原理是什么？ 👉 Spring循环依赖原理，如何解决？ FactoryBean和BeanFactory区别 public interface FactoryBean { String OBJECT_TYPE_ATTRIBUTE = \"factoryBeanObjectType\"; // 从factory中获取bean @Nullable T getObject() throws Exception; // 从beanFactory中获取类型 @Nullable Class getObjectType(); // 是单例？ default boolean isSingleton() { return true; } } package com.example.demo.domian; import org.springframework.beans.factory.FactoryBean; import org.springframework.stereotype.Component; @Component public class MyFactoryBean implements FactoryBean { // 保存一句话，用来区分不同的对象。 private String message; // 无参构造器。 public MyFactoryBean() { // 意思是：当前对象是 MyFactoryBean 的对象。 this.message = \"object of myFactoryBeanSelf\"; } // 有参构造器。 public MyFactoryBean(String message) { this.message = message; } // 获取 message。 public String getMessage() { return this.message; } @Override /** * 这个方法在执行时创建了新的 MyFactoryBean 类型的对象。 * 这里继续沿用了 MyFactoryBean 类型，但是可以是别的类型 * 比如：Person、Car、等等。 */ public Object getObject() throws Exception { // 意思是：当前对象是 MyFactoryBean 的 getObject() 创建的。 return new MyFactoryBean(\"object from getObject() of MyFactoryBean\"); } @Override public Class getObjectType() { return MyFactoryBean.class } } package com.example.demo.domian; import org.junit.jupiter.api.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.context.ApplicationContext; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest(classes = com.example.demo.domian.MyFactoryBean.class) class MyFactoryBeanTest { @Autowired private ApplicationContext context; @Test public void test() { // 第一次用 myFactoryBean 去拿。 MyFactoryBean myBean1 = (MyFactoryBean) context.getBean(\"myFactoryBean\"); System.out.println(\"myBean1 = \" + myBean1.getMessage()); // 第二次用 &myFactoryBean 去拿。 MyFactoryBean myBean2 = (MyFactoryBean) context.getBean(\"&myFactoryBean\"); System.out.println(\"myBean2 = \" + myBean2.getMessage());、 // 判断两次拿到的对象是不是一样的？ System.out.println(\"myBean1.equals(myBean2) = \" + myBean1.equals(myBean2)); } } myBean1 = object from getObject() of MyFactoryBean myBean2 = object of myFactoryBeanSelf myBean1.equals(myBean2) = false 第一次使用myFactoryBean去容器中拿，实际上是容器中MyFactoryBean的bean调用了getObject()方法，并将结果返回。第二次使用&myFactoryBean去容器中拿，才是真正拿到了MyFactoryBean的bean。 👉 BeanFactory和FactoryBean的区别 Synchronized原理？ class Test1{ public synchronized void test() { } } //等价于 class Test1{ public void test() { // 锁的是当前对象 synchronized(this) { } } } class Test2{ public synchronized static void test() { } } //等价于 class Test2{ public static void test() { // 锁的是类对象，类对象只有一个 synchronized(Test2.class) { } } } 每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁(重量级)之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。不加synchronized的对象不会关联监视器。 刚开始Monitor中Owner为null。 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner。 在Thread-2上锁的过程中，如果Thread-3、Thread-4、Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED。 Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争的时是非公平的。 图中WaitSet中的Thread-0、Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程。 👉 synchronized原理 CAS volatile原理？ 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。 内存模型？什么是主内存？什么是工作内存？ 内存 解释 主内存 是所有的线程所共享的，主要包括本地方法区和堆。 工作内存 每个线程都有一个工作内存不是共享的，工作内存中主要包括两个部分: 1. 一个是属于该线程私有的栈；2. 对主内存部分变量拷贝的寄存器(包括程序计数器PC和CPU工作的高速缓存区)。 所有的变量都存储在主内存中(虚拟机内存的一部分)，对于所有线程都是共享的。 每条线程都有自己的工作内存，工作内存中保存的是主存中某些变量的拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。 线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成,即：线程、主内存、工作内存。 数据库索引类型？原理？ Spring Bean生命周期？ 通过XML、Java Annotation(注解)以及Java Configuration(配置类)等方式加载Spring Bean。 BeanDefinitionReader解析Bean的定义。在Spring容器启动过程中，会将Bean解析成Spring内部的BeanDefinition结构；理解为将spring.xml中的标签转换成BeanDefinition结构，有点类似于XML解析。 BeanDefinition包含了很多属性和方法。例如id、class(类名)、scope、ref(依赖的bean)等等。其实就是将bean(例如)的定义信息存储到这个对应BeanDefinition相应的属性中。例如 BeanFactoryPostProcessor是Spring容器功能的扩展接口。 BeanFactoryPostProcessor在spring容器加载完BeanDefinition之后，在bean实例化之前执行的。 对bean元数据(BeanDefinition)进行加工处理，也就是BeanDefinition属性填充、修改等操作。 BeanFactory，bean工厂。它按照我们的要求生产我们需要的各种各样的bean。 Aware感知接口，在实际开发中，经常需要用到Spring容器本身的功能资源例如BeanNameAware、ApplicationContextAware等等，BeanDefinition实现了BeanNameAware、ApplicationContextAware。 BeanPostProcessor后置处理器。在Bean对象实例化和引入注入完毕后，在显示调用初始化方法的前后添加自定义的逻辑(类似于AOP的绕环通知)。前提条件如果检测到Bean对象实现了BeanPostProcessor后置处理器才会执行Before和After方法。 Before 调用初始化Bean，InitializingBean和init-method，Bean的初始化才算完成。 After destroy销毁。 Mysql优化经验？ 引擎选择(InnoDB、MyISAM、Memory) 读写分离&一主多备 分库分表 优化连接池 优化请求堆栈 修改连接超时时间 优化内存缓冲池 优化并发线程数 优化线程池 优化日志 错误日志: 启动、关闭、运行时产生的异常记录，建议开启，设置log_error。 查询日志: 客户端连接和执行的脚本，建议关闭，设置general_log。 慢查询日志: 记录超时的查询，记录不适用索引的查询等，建议关闭，设置slow_query_log。 二进制日志: 用于数据同步复制，需发送的数据日志，多用于集群，如需开启，设置log_bin。 中继日志: 用于数据同步复制时，接收到的数据日志，多用于集群，如需开启，设置relay_log。 锁优化 👉 MySQL性能优化经验总结 Mysql锁类型？ MySQL数据库的锁都是悲观锁。 读锁(共享锁) lock in share mode 写锁(排他锁) MDL语句，例如update、delete、insert select ... for update 👉 MySQL悲观锁 Redis使用过程中应该注意什么问题？ key的长度不要太长，也不要太短，要符合设计规约，value的大小要防止big key的发生。 hash更适合存储对象。 sort的集合如果非常大的话，排序就会消耗很长时间，由于redis是单线程的，所以长时间的排序操作会阻塞其他client的请求，解决办法是通过主从复制将数据复制到多个slave上，然后只在slave上做排序操作。 如果你的redis集群需要做主从复制，最好事先配置好所有的从库，避免中途再去添加从库(一方面slave恢复的时间非常慢，另一方面也会给主库带来压力)。 尽量避免在压力较大的主库上增加从库。 如果服务数据压力过大，可以增加多台服务器节点。 master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。 为了主从复制的速度和连接多稳定性，slave和master最好在同一个局域网内。 JVM调优参数？ 参数 解释 -Xms 设置堆的最小空间大小。 -Xmx 设置堆的最大空间大小。 -Xmn 设置新生代大小。 -XX:NewSize 设置新生代最小空间大小。 -XX:MaxNewSize 设置新生代最大空间大小。 -XX:PermSize 设置永久代最小空间大小。 -XX:MaxPermSize 设置永久代最大空间大小。 -Xss 设置每个线程的堆栈大小。 -XX:+UseParallelGC 选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下年轻代使用并发收集，而年老代仍旧使用串行收集。 -XX:ParallelGCThreads=20 配置并行收集器的线程数，即同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 参数 解释 -Xms3550m 设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g 设置年轻代大小为2G。堆=年轻代+年老代+持久代。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，官方推荐配置为整个堆的3/8。 -Xss128k 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 线程池原理？属性代表含义？ // todo HashMap、ConcurrentHashMap原理？ // todo 饿了么 项目介绍，怎么不断优化项目、架构升级？如果业务量剧增，怎么保证系统高可用、扩展性？ // todo 订单量、日新增多少？分库分表怎么做？基于什么维度去做？ // todo 检测到JVM内存大于配置JVM的xmx配置的内存， 三台机器中的一台机器有上面这种现象，如何解释？ Java进程最大占用的物理内存为: Max Memory = eden + survivor + old + String Constant Pool + Code cache + compressed class space + Metaspace + Thread stack(*thread num) + Direct + Mapped + JVM + Native Memory Java进程的内存组成heap+stack+metaspaceSize+directMemory。除了通过-Xmx4g、-Xms4g参数控制程序启动的堆内存外，不要忽视-Xss1024K控制每个stack的大小。元空间限制-XX:MetaspaceSize=64m、-XX:MaxMetaspaceSize=128m。直接内存使用限制-XX:MaxDirectMemorySize=128m。 👉 JVM实际内存占用超过Xmx的原因,设置Xmx的技巧 Redis热key怎么解决？ 所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。 凭借业务经验，进行预估哪些是热key。其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。 在客户端进行收集。这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。 在Proxy层做收集。有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。 用redis自带命令。 monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。 hotkeys参数，redis4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。 自己抓包评估。Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。 利用二级缓存。比如利用ehcache或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从JVM中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来，如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设你的应用层有50台机器，那么你也有JVM缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。 备份热key。不要让key走到同一台redis上不就行了。我们把这个key在多个redis上都存一份。接下来有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值返回数据。 Kafka为什么性能高？ 基于磁盘的顺序读写。顺序写利用磁盘的顺序访问速度可以接近内存，kafka的消息都是append操作，partition是有序的，节省了磁盘的寻道时间，同时通过批量操作、节省写入次数，partition物理上分为多个segment存储，方便删除。 页缓存(Page Cache)。对于一个进程来说，他会在进程内部缓存所需要的数据，然而这些数据很有可能也缓存在操作系统的页缓存中，也就是这一部分数据被缓存了两次。就算kafka服务重启，页缓存内的数据也还是存在，但进程内的数据则需要重新加载。这也在一定程度上能简化代码，而且维护页缓存和文件的一致性问题交给操作系统完成会比进程内维护要更加的安全高效。 零拷贝。直接将内核缓冲区的数据发送到网卡传输。 👉 Kafka为什么能那么快的6个原因 OOM场景分析？ StackOverflowError Java heap space 内存溢出，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个Integer，但给它存了Long才能存下的数，那就是内存溢出。 内存泄露，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。 GC overhead limit exceeded Direct buffer memory Unable to create new native thread Metaspace Requested array size exceeds VM limit Out of swap space Kill process or sacrifice child 👉 java 9种常见的OOM场景——原因分析及解决方案 Mysql集群是怎么部署的，主从同步？ 从mysql和主mysql的配置基本相同,除了以下几个配置: 从机server-id要和主机不同 server-id=2 log_slave_updates=1 开启同步函数 log_bin_trust_function_creators=1 Mysql双主相互备份是如何解决循环复制的？ 假设A、B相互备份，A产生的binlog中携带serverId=1发送到B，B解析后执行，执行完毕也会产生binlog。此时B的binlog serverId仍然等于1，发送给A后，A看到serverId=1为自己发送的binlog，直接丢弃；同理B方向类似。 怎么设置使用什么GC方式？不同年代GC收集器有哪些？ // todo 线上CPU很高怎么排查 jstack参数 解释 tid java内的线程id nid 操作系统级别线程的线程id prio java内定义的线程的优先级 os_prio 操作系统级别的优先级 # 查看CPU个数 cat /proc/cpuinfo| grep \"physical id\"|sort|uniq|wc -l # 获取最大CPU的PID top -c (键盘输入大P) # 获取最高CPU的服务 ps -ef|grep PID # 获取最大PID中的最大NID top -Hp PID (键盘输入大P) # NID转换成16进制 printf \"%x\\n\" NID # 打印堆栈信息，并从jstack.txt寻找16进制NID jstack -l PID > jstack.txt 或者 jstack -l PID | grep ${16进制NID} -A 100 👉 记录一次线上CPU负载过高的排查过程 👉 线上占用CPU过高问题排查 JDK1.8的新特性 // todo BIO、NIO了解 // todo MQ怎么保证消息可靠性？ // todo 系统负载过高怎么办？什么问题导致的？怎么排查？ top -c。输入P获取PID。 top -Hp PID。输入P获取NID。 printf \"%x\\n\" NID。输入NID获取16进制NID。 jstack -l PID | grep 16进制NID -A 100。定位异常代码。 Linux操作系统简单介绍有哪些东西？ // todo 中通 JVM介绍 👉 最全的JVM介绍 JMM模型 此内存模型中规定了，所有的共享变量都是存储于主内存中，每个线程都是将主内存中的共享变量拷贝一份副本到本线程的本地内存中，然后操作此共享变量副本，修改后再同步更新到主内存中，因此高并发下就会出现变量修改的问题了。 操作 解释 lock (锁定) 将主内存变量加锁，表示为线程独占状态，可以被线程进行read。 read(读取) 线程从主内存读取数据。 load(载入) 将上一步线程从主内存中读取的数据，加载到工作内存中。 use(使用) 从工作内存中读取数据来进行我们所需要的逻辑计算。 assign(复制) 将计算后的数据赋值到工作内存中。 store(存储) 将工作内存的数据准备写入主内存。 write(写入) 将store过去的变量正式写入主内存。 unlock(解锁) 将主内存的变量解锁，解锁后其他线程可以锁定该变量。 GC Root有哪些？ 虚拟机内部的引用，比如类加载器等； native，本地方法栈引用的对象(在本地方法栈)； final，常量引用的对象(比如字符串常量池的引用，在方法区)； static，静态变量引用的对象(比如Java类的引用类型静态变量，在方法区)； synchronized引用的对象(所有被同步锁持有的对象，在堆里)； JVM虚拟机栈引用的对象(比如各个线程被调用的方法堆栈中用到的参数、局部变量和临时变量，在jvm虚拟机栈中)； Thread，活动的线程； Class对象，由BootstrapClassLoader加载的对象是不能被回收的。 栈是由栈帧组成，每当线程调用一个Java方法时，JVM就会在该线程对应的栈中压入一个帧，而帧是由局部变量区、操作数栈和帧数据区组成。 为什么要有GC root 为了回收无用的对象，释放内存，需要把无用对象找到；找无用的不好找，反过来找有用的对象就比较好找； gc root就是用来标记有引用关系的对象，这些在gc root引用关系链上的强引用对象都是不能回收； 一般对象都放在堆里的，所以垃圾回收的重点是放在了堆里。所以堆之外的栈，方法区就是gc root对象所在的地方。 JVM调优经验？ 调优是一个循序渐进的过程，必然需要经历多次迭代，最终才能换取一个较好的折中方案。在JVM调优这个领域，没有任何一种调优方案是适用于所有应用场景的，同时切勿极端才能够达到JVM性能调优的真正目的和意义。 GC的时间足够的小。 GC的次数足够的少。 发生Full GC的周期足够的长。 前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。 更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC。 更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率。 如何选择应该依赖应用程序对象生命周期的分布情况: 如果应用存在大量的临时对象，应该选择更大的年轻代。 如果存在相对较多的持久对象，年老代应该适当增大。 但很多应用都没有这样明显的特性，在抉择时应该根据以下两点: 本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例3:8也是这个道理。 通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响FullGC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1:1，但应该给年老代至少预留1/3的增长空间。 调优策略 解释 将新对象预留在年轻代 众所周知，由于Full GC的成本远远高于Minor GC，因此某些情况下需要尽可能将对象分配在年轻代，这在很多情况下是一个明智的选择。虽然在大部分情况下，JVM会尝试在Eden区分配对象，但是由于空间紧张等问题，很可能不得不将部分年轻对象提前向年老代压缩。因此，在JVM参数调优时可以为应用程序分配一个合理的年轻代空间，以最大限度避免新对象直接进入年老代的情况发生。通过设置一个较大的年轻代预留新对象，设置合理的Survivor区并且提供Survivor区的使用率，可以将年轻对象保存在年轻代。一般来说，Survivor区的空间不够，或者占用量达到50%时，就会使对象进入年老代(不管它的年龄有多大)我们可以尝试加上-XX:TargetSurvivorRatio=90参数，这样可以提高from区的利用率，使from区使用到90%时，再将对象送入年老代。 让大对象进入年老代 我们在大部分情况下都会选择将对象分配在年轻代。但是，对于占用内存较多的大对象而言，它的选择可能就不是这样的。因为大对象出现在年轻代很可能扰乱年轻代GC，并破坏年轻代原有的对象结构。因为尝试在年轻代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，JVM不得不将年轻代中的年轻对象挪到年老代。因为大对象占用空间多，所以可能需要移动大量小的年轻对象进入年老代，这对GC相当不利。基于以上原因，可以将大对象直接分配到年老代，保持年轻代对象结构的完整性，这样可以提高GC的效率。如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于GC来说会是一场灾难。原本应该用于存放永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路。因此，在软件开发过程中，应该尽可能避免使用短命的大对象。可以使用参数-XX:PetenureSizeThreshold设置大对象直接进入年老代的阈值。当对象的大小超过这个值时，将直接在年老代分配。参数-XX:PetenureSizeThreshold只对串行收集器和年轻代并行收集器有效，并行回收收集器不识别这个参数。 设置对象进入年老代的年龄 如何设置对象进入年老代的年龄堆中的每一个对象都有自己的年龄。一般情况下，年轻对象存放在年轻代，年老对象存放在年老代。为了做到这点，虚拟机为每个对象都维护一个年龄。如果对象在Eden区，经过一次GC后依然存活，则被移动到Survivor区中，对象年龄+1。以后如果对象每经过一次GC依然存活，则年龄再+1。当对象年龄达到阈值时，就移入年老代，成为老年对象。这个阈值的最大值可以通过参数-XX:MaxTenuringThreshold来设置，默认值是15。虽然-XX:MaxTenuringThreshold的值可能是15或者更大，但这不意味着新对象非要达到这个年龄才能进入年老代。事实上，对象实际进入年老代的年龄是虚拟机在运行时根据内存使用情况动态计算的，这个参数指定的是阈值年龄的最大值。即实际晋升年老代年龄等于动态计算所得的年龄与-XX:MaxTenuringThreshold中较小的那个。 稳定的Java堆VS动荡的Java堆 一般来说，稳定的堆大小对垃圾回收是有利的。获得一个稳定的堆大小的方法是使-Xms和-Xmx的大小一致，即最大堆和最小堆 (初始堆)一样。如果这样设置，系统在运行时堆大小理论上是恒定的，稳定的堆空间可以减少GC的次数。因此，很多服务端应用都会将最大堆和最小堆设置为相同的数值。但是，一个不稳定的堆并非毫无用处。稳定的堆大小虽然可以减少GC次数，但同时也增加了每次GC的时间。让堆大小在一个区间中震荡，在系统不需要使用大内存时，压缩堆空间，使GC应对一个较小的堆，可以加快单次GC的速度。基于这样的考虑，JVM还提供了两个参数用于压缩和扩展堆空间。-XX:MinHeapFreeRatio参数用来设置堆空间最小空闲比例，默认值是40。当堆空间的空闲内存小于这个数值时，JVM便会扩展堆空间。-XX:MaxHeapFreeRatio参数用来设置堆空间最大空闲比例，默认值是70。当堆空间的空闲内存大于这个数值时，便会压缩堆空间，得到一个较小的堆。当-Xmx和-Xms相等时，-XX:MinHeapFreeRatio和-XX:MaxHeapFreeRatio两个参数无效。 增大吞吐量提升系统性能 吞吐量优先的方案将会尽可能减少系统执行垃圾回收的总时间，故可以考虑关注系统吞吐量的并行回收收集器。在拥有高性能的计算机上，进行吞吐量优先优化。可以使用参数: java –Xmx3800m –Xms3800m –Xmn2G –Xss128k –XX:+UseParallelGC –XX:ParallelGC-Threads=20 –XX:+UseParallelOldGC。 尝试使用大的内存分页 CPU是通过寻址来访问内存的。32位CPU的寻址宽度是0~0xFFFFFFFF，计算后得到的大小是4G，也就是说可支持的物理内存最大是4G。但在实践过程中碰到了这样的问题，程序需要使用4G内存，而可用物理内存小于4G，导致程序不得不降低内存占用。为了解决此类问题，现代CPU引入了MMU(Memory Management Unit内存管理单元)。MMU的核心思想是利用虚拟地址替代物理地址，即CPU寻址时使用虚址，由MMU负责将虚址映射为物理地址。MMU的引入解决了对物理内存的限制，对程序来说就像自己在使用4G内存一样。内存分页(Paging)是在使用MMU的基础上，提出的一种内存管理机制。它将虚拟地址和物理地址按固定大小(4K)分割成页(page)和页帧(page frame)，并保证页与页帧的大小相同。这种机制从数据结构上保证了访问内存的高效，并使OS能支持非连续性的内存分配。在程序内存不够用时，还可以将不常用的物理内存页转移到其他存储设备上，比如磁盘，这就是大家耳熟能详的虚拟内存。在Solaris系统中，JVM可以支持Large Page Size的使用。使用大的内存分页可以增强CPU的内存寻址能力，从而提升系统的性能。java –Xmx2506m –Xms2506m –Xmn1536m –Xss128k –XX:++UseParallelGC –XX:ParallelGCThreads=20 –XX:+UseParallelOldGC –XX:+LargePageSizeInBytes=256m。过大的内存分页会导致JVM在计算Heap内部分区(perm、new、old)内存占用比例时，会出现超出正常值的划分，最坏情况下某个区会多占用一个页的大小。 使用非占有的垃圾回收器 为降低应用软件的垃圾回收时的停顿，首先考虑的是使用关注系统停顿的CMS回收器，其次为了减少Full GC次数，应尽可能将对象预留在年轻代，因为年轻代Minor GC的成本远远小于年老代的Full GC。 👉 JVM性能调优经验总结 JVM常用命令 jps [-q] [-mlvV] ${PID} jinfo -flags ${PID} jstat -gc ${PID} ${多少毫秒打印一次} ${打印多少次} jstack -l ${PID} jmap -heap ${PID}、jmap -histo ${PID}、jmap -dump:format=b,file=xxx.dump ${PID} 线程池注意事项，异常处理 Runnable执行异常(业务异常) public class ThreadPoolExceptionTest { public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(2, new ThreadFactory() { AtomicInteger integer = new AtomicInteger(1); @Override public Thread newThread(Runnable r) { return new Thread(r, \"mxsm-\"+integer.getAndIncrement()); } }); executorService.execute(() -> { System.out.println(1); int i = 1/0; System.out.println(i); }); executorService.execute(() -> { for (;;){ try { TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName()+\" 当前时间：\"+System.currentTimeMillis()); } catch (InterruptedException e) { e.printStackTrace(); } } }); System.out.println(\"主线程执行完成\"); } } 1 主线程执行完成 Exception in thread \"mxsm-1\" java.lang.ArithmeticException: / by zero mxsm-2 当前时间：1656145034793 mxsm-2 当前时间：1656145035800 ...... 线程池正常运行，Runnable的异常不会导致线程池停止运行，其他的线程正常运行。执行Runnable发生错误的线程将会被销毁会重新建一个线程，以保证固定线程池2的数量。 提交任务到任务队列已满异常 public class ThreadPoolExceptionTest { public static void main(String[] args) { ExecutorService executorService = new ThreadPoolExecutor(1, 1, 100, TimeUnit.SECONDS,new ArrayBlockingQueue<>(1),new ThreadFactory(){ AtomicInteger integer = new AtomicInteger(1); @Override public Thread newThread(Runnable r) { return new Thread(r, \"mxsm-\"+integer.getAndIncrement()); } }); for(int i = 0; i { for (;;){ try { TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName()+ b +\" 当前时间：\"+System.currentTimeMillis()); } catch (InterruptedException e) { e.printStackTrace(); } } }); } System.out.println(\"主线程结束\"); } } Exception in thread \"main\" java.util.concurrent.RejectedExecutionException:...... mxsm-10 当前时间：1656145315473 mxsm-10 当前时间：1656145316474 ...... 线程池使用默认的拒绝策略的时候，当线程池提交任务到任务队列已满线程池会直接抛出错误，进而影响到主线程的后续的运行如果没有在主线程中进行错误处理(没有打印主线程结束)。提交任务到任务队列已满异常影响的范围和方式由拒绝策略决定。 线程池本身异常 这里说的线程池本身异常包括但不仅限于在设置线程池大小的时候，可能不停的新建线程导致线程消耗完成了服务器的所有资源。 /** * * 设置内存大小 * -Xmx2m * -Xms2m * */ public class ThreadPoolExceptionTest { public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); final AtomicInteger integer = new AtomicInteger(); for(int i = 0;i ...... 83681 83682 83683 [thread 405424 also had an error] 83684 83689 83688 ...... 线程池导致某些异常会导致线程池直接退出可能同时导致住线程或者主应用发生问题或者退出。 👉 线程池异常如何处理你都了解吗？ 分布式锁使用和原理？ 数据库 redis zookeeper Redis怎么持久化？高可用？ 在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务(99.9%、99.99%、99.999%等等)。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。 RDB AOF 👉 Redis高可用之持久化 RPC框架实现原理？ Dubbo、Spring cloud那一套，GRPC、Thrift等等都是RPC全程远程方法调用，RPC本质上其实就是一次网络调用，那么它的实现原理主要有以下几个步骤。 步骤 解释 建立通信 首先要解决通讯的问题。即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有相关的数据都在这个连接里面进行传输交换。 服务寻址 通常情况下我们需要提供B机器(主机名或IP地址)以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。比如基于Web服务协议栈的RPC，就需要提供一个endpoint URI，或者是从UDDI服务上进行查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。 网络传输 1. 序列化: 当A机器上的应用发起一个RPC调用时，调用方法和其参入等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化(Serialize)或者编组(marshal)成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。2. 反序列化: 当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作(序列化的逆操作)，即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法(寻址的一部分)进行本地调用(一般是通过生成代理Proxy去调用，通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等)，之后得到调用的返回值。 服务调用 B机器进行本地调用(通过代理Proxy)之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理(一般是业务逻辑处理操作)。 接口调用变慢排查 是不是资源层面的瓶颈，硬件、配置环境之类的问题； 针对查询类接口，是不是没有添加缓存，如果加了，是不是热点数据导致负载不均衡； 是不是有依赖于第三方接口，导致因第三方请求拖慢了本地请求； 是不是接口涉及业务太多，导致程序执行跑很久； 是不是sql层面的问题导致的数据等待加长，进而拖慢接口； 网络层面的原因，带宽不足、DNS解析慢； 确实是代码质量差导致的，如出现内存泄漏，重复循环读取之类。 为什么数据库TCP连接会被断开？ 一开始百思不得其解，想着是因为Oracle数据库主动断开了连接吗？因为某些原因，比如服务器到数据库的连接太多？明显不是，这个项目还在试运行阶段，用的人不多，且观察Druid的连接监控，一般建立的连接也就几个。 后来和同时讨论的过程中得知别的项目组也发生过类似的情况，而他们和这个项目的共同之处就在于服务都是在DMZ区，外网可以访问，而数据库在内网，需要通过防火墙才能访问到数据库。于是去找负责维护网络、防火墙的同事了解，原来防火墙有一个TCP超时时间，目前设置为30min，其意义是，对于通过防火墙的所有TCP连接，如果半小时内没有任何活动，就会被防火墙拆除，这样就会导致连接中断。在连接拆除时，也不会向连接的两端发送任何数据来通知连接已经拆除。 这下数据库连接断开的原因找到了，那么这就是一个应用与数据库在不同的网络中，连接需要经过防护墙的场景中遇到的一个典型的问题。 cat /proc/sys/net/ipv4/tcp_retries2 防火墙切断数据库连接会造成的影响 数据库会话正在执行耗时长的SQL。切断连接之前，连接对应的Oracle会话正在执行一个耗时特别长的sql，比如存储过程而此过程中没有任何数据输出到客户端，这样当sql执行完成之后，向客户端返回结果时，如果TCP连接已经被防火墙中断，这时候显然会出现错误，连接中断，那么会话也就会中断。但是客户端还不知道，会一直处于等待服务器返回结果的状态。如果客户端没有针对这种执行耗时长的sql的连接回收机制，那么客户端这个连接将一直处于等待状态，如果客户端不断执行这种耗时长的sql，那么客户端堆积的等待连接将越来越多。Druid连接池的removeAbandoned相关配置以及逻辑，就是为了解决这种连接回收设置的。 数据库会话空闲。切断连接之前，Oracle会话一直处于空闲状态，在防火墙中断之后，客户端向Oracle服务器提交sql时，由于TCP连接中断，这时客户端侦测到连接中断，那么客户端就会报ORA-03113/ORA-03114这类错误，然后会话中断。但是在Oracle服务器端，会话一直处于等待客户端消息的状态。而对于Druid这种有testOnBorrow、testWhileIdle的检测机制，且检测失败可以重新连接的连接池，空闲的被防火墙切断的连接在后续会不断被重连，而在数据库服务器端则连接越来越多，即会话数越来越多，甚至最终超过了数据库最大连接数。 解决方案 解释 调大防火墙的连接切断时长 --- TCP keepalive功能 --- 程序不定时执行查询 --- 业务系统架构，业务量 // todo 数据库设计，优化方案 sql以及索引的优化。 合理的数据库设计。 系统配置的优化。 硬件优化。 👉 数据库优化方案整理 鱼泡泡(比心) 比较有成就的项目 // todo 清结算怎么实现的？ // todo 统一收银台设计？ // todo RocketMq和Kafka区别，选型？ // todo Kafka消息从生产到消费的流转过程？ 写流程 通过ZooKeeper找partition对应的leader，leader是负责写的； producer开始写入数据； ISR里面的follower开始同步数据，并返回给leader ACK； 返回给producer ACK。 读流程 通过ZooKeeper找partition对应的leader，leader是负责读的； 通过ZooKeeper找到消费者对应的offset； 然后开始从offset往后顺序拉取数据； 提交offset(自动提交——每隔多少秒提交一次offset，手动提交、放入到事务中提交)。 👉 Kafka生产、消费数据工作流程 HashMap、HashTable区别？ HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构(增加或者移除元素)，将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。 对线程安全的理解？ 当多个线程访问一个对象(对象在堆中)时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。 CAS实现原理？ 代码加锁有几种实现方式？ synchronized ReentrantLock 快速排序算法 // todo 分布式锁获取锁失败的处理，线程间的同步？ 👉 Redis分布式锁加锁失败，休眠机制 Redis线程模型，过期机制，淘汰策略？ 过期策略 解释 优点 缺点 定时删除 当对一个key设置了过期时间，当该时间到，立即执行对该key的删除。 定时删除对内存最友好，保证key一旦过期就能立即从内存中删除。 对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分CPU时间，对服务器的响应时间和吞吐量造成影响。 惰性删除 当一个key被设置过期时间后，当key的过期时间到了，并不会立即从内存中删除；在我们使用该key时，先检查其是否过期，过期则将其从内存中删除。 对CPU友好，只在使用的时候才会进行过期检查，对于没用到的key不会浪费时间进行过期检查。 对内存不好用，key过期了却一直没被使用，就会一直占这内存。如果数据库中存在很多过期键不被使用，便永远不会被被删除，内存不会被释放，从而造成内存泄漏。 定期删除 每隔一段时间(该时间段可设置)，随机抽取一些设置了过期时间的key进行检查，删除里面过期的键。在Redis的配置文件redis.conf中有一个属性\"hz\"，默认为10，表示1s执行10次定期删除，即每隔100ms执行一次，可以修改这个配置值。随机抽取，抽取多少？同样是由redis.conf文件中的maxmemory-samples属性决定的，默认为5。 可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。 难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的频率小，就和惰性删除一样了，过期键占用的内存不会及时得到释放。另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。 内存淘汰策略 解释 no-eviction 当内存不足以容纳新写入数据时，新写入操作会报错，无法写入新数据，一般不采用。 allkeys-lru 当内存不足以容纳新写入数据时，移除最近最少使用的key，这个是最常用的。 allkeys-random 当内存不足以容纳新写入的数据时，随机移除key。 allkeys-lfu 当内存不足以容纳新写入数据时，移除最不经常(最少)使用的key。 volatile-lru 当内存不足以容纳新写入数据时，在设置了过期时间的key中，移除最近最少使用的key。 volatile-random 内存不足以容纳新写入数据时，在设置了过期时间的key中，随机移除某个key 。 volatile-lfu 当内存不足以容纳新写入数据时，在设置了过期时间的key中，移除最不经常(最少)使用的key 。 volatile-ttl 当内存不足以容纳新写入数据时，在设置了过期时间的key中，优先移除过期时间最早(剩余存活时间最短)的key。 线程池参数、使用场景、参数设置分析？ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { ... } 线程池参数 解释 coreSize核心线程数 1. 核心线程会一直存活，即使没有任务需要执行。当线程数设置allowCoreThreadTimeout=true(默认false)时，核心线程会超时关闭。 maximumPoolSize最大线程数 1. 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务。2. 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常。 keepAliveTime线程空闲时间 1. 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize。2. 如果allowCoreThreadTimeout=true，则会直到线程数量=0。 queueCapacity任务队列容量(阻塞队列) 当核心线程数达到最大时，新任务会放在队列中排队等待执行。 allowCoreThreadTimeout允许核心线程超时 ---- rejectedExecutionHandler任务拒绝处理器 1. 当线程数已经达到maxPoolSize且队列已满，会拒绝新任务。2. 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务。线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常。ThreadPoolExecutor采用了策略的设计模式来处理拒绝任务的几种场景。这几种策略模式都实现了RejectedExecutionHandler接口。 拒绝策略 解释 AbortPolicy 丢弃任务，抛运行时异常。 CallerRunsPolicy 执行任务。 DiscardPolicy 忽视，什么都不会发生。 DiscardOldestPolicy 从队列中踢出最先进入队列(最后一个执行)的任务。 Mysql存储引擎、索引结构、分库分表 存储引擎 使用场景 InnoDB 适合要提供提交、回滚和崩溃后的安全恢复的事务安全能力，并要求实现并发控制。 MyISAM 适合于只读的数据，或者表比较小、可以忍受修复操作数据库。 Memory 适用于快速查找数据，用于数据分析中产生的中间数据。 👉 MySQL数据存储/索引/事务隔离级别/主从复制/分库分表 场景题: 设计一个抢红包系统 // todo "},"pages/review/ReviewVI.html":{"url":"pages/review/ReviewVI.html","title":"题卷VI","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Java基础 JDK和JRE有什么区别？ ==和equals的区别是什么？ 两个对象的hashCode()相同，则equals()也一定为true？ final在Java中有什么作用？ Math.round(-1.5)等于多少？ String属于基础的数据类型吗？ Java中操作字符串都有哪些类？它们之间有什么区别？ String str=\"i\"与String str=new String(\"i\")一样吗？ 如何将字符串反转？ String类的常用方法都有那些？ 抽象类必须要有抽象方法吗？ 普通类和抽象类有哪些区别？ 抽象类能使用final修饰吗？ 接口和抽象类有什么区别？ Java中IO流分为几种？ BIO、NIO、AIO有什么区别？ Files的常用方法都有哪些？ 容器 Java容器都有哪些？ Collection和Collections有什么区别？ List、Set、Map之间的区别是什么？ HashMap和Hashtable有什么区别？ 如何决定使用HashMap还是TreeMap？ 说一下HashMap的实现原理？ 说一下HashSet的实现原理？ ArrayList和LinkedList的区别是什么？ 如何实现数组和List之间的转换？ ArrayList和Vector的区别是什么？ Array和ArrayList有何区别？ 在Queue中poll()和remove()有什么区别？ 哪些集合类是线程安全的？ 迭代器Iterator是什么？ Iterator怎么使用？有什么特点？ Iterator和ListIterator有什么区别？ 怎么确保一个集合不能被修改？ 多线程 并行和并发有什么区别？ 线程和进程的区别？ 守护线程是什么？ 创建线程有哪几种方式？ 说一下runnable和callable有什么区别？ 线程有哪些状态？ sleep()和wait()有什么区别？ notify()和notifyAll()有什么区别？ 线程的run()和start()有什么区别？ 创建线程池有哪几种方式？ 线程池都有哪些状态？ 线程池中submit()和execute()方法有什么区别？ 在Java程序中怎么保证多线程的运行安全？ 多线程中synchronized锁升级的原理是什么？ 什么是死锁？ 怎么防止死锁？ ThreadLocal是什么？有哪些使用场景？ 说一下synchronized底层实现原理？ synchronized和volatile的区别是什么？ synchronized和Lock有什么区别？ synchronized和ReentrantLock区别是什么？ 说一下atomic的原理？ 反射 什么是反射？ 什么是Java序列化？什么情况下需要序列化？ 动态代理是什么？有哪些应用？ 怎么实现动态代理？ 对象拷贝 为什么要使用克隆？ 如何实现对象克隆？ 深拷贝和浅拷贝区别是什么？ Java Web模块 JSP和servlet有什么区别？ JSP有哪些内置对象？作用分别是什么？ 说一下JSP的4种作用域？ session和cookie有什么区别？ 说一下session的工作原理？ 如果客户端禁止cookie能实现session还能用吗？ springMVC和struts的区别是什么？ 如何避免sql注入？ 什么是XSS攻击？如何避免？ 什么是CSRF攻击？如何避免？ 异常模块 throw和throws的区别？ final、finally、finalize有什么区别？ try-catch-finally中哪个部分可以省略？ try-catch-finally中，如果catch中return了，finally还会执行吗？ 常见的异常类有哪些？ 网络模块 http响应码301和302代表的是什么？有什么区别？ forward和redirect的区别？ 简述TCP和UDP的区别？ TCP为什么要三次握手，两次不行吗？为什么？ 说一下TCP粘包是怎么产生的？ OSI的七层模型都有哪些？ get和post请求有哪些区别？ 如何实现跨域？ 说一下JSONP实现原理？ 设计模式 说一下你熟悉的设计模式？ 简单工厂和抽象工厂有什么区别？ Spring MVC 为什么要使用Spring？ 解释一下什么是AOP？ 解释一下什么是IOC？ Spring有哪些主要模块？ Spring常用的注入方式有哪些？ Spring中的bean是线程安全的吗？ Spring支持几种bean的作用域？ Spring自动装配bean有哪些方式？ Spring事务实现方式有哪些？ 说一下Spring的事务隔离？ 说一下SpringMVC运行流程？ SpringMVC有哪些组件？ @RequestMapping的作用是什么？ @Autowired的作用是什么？ Spring Boot/Spring Cloud 什么是Spring Boot？ 为什么要用Spring Boot？ Spring Boot核心配置文件是什么？ Spring Boot配置文件有哪几种类型？它们有什么区别？ Spring Boot有哪些方式可以实现热部署？ JPA和Hibernate有什么区别？ 什么是Spring Cloud？ Spring Cloud断路器的作用是什么？ Spring Cloud的核心组件有哪些？ Hibernate 为什么要使用Hibernate？ 什么是ORM框架？ Hibernate中如何在控制台查看打印的sql语句？ Hibernate有几种查询方式？ Hibernate实体类可以被定义为final吗？ 在Hibernate中使用Integer和int做映射有什么区别？ Hibernate是如何工作的？ get()和load()的区别？ 说一下Hibernate的缓存机制？ Hibernate对象有哪些状态？ 在Hibernate中getCurrentSession和openSession的区别是什么？ Hibernate实体类必须要有无参构造函数吗？为什么？ Mybatis Mybatis中#{}和${}的区别是什么？ Mybatis有几种分页方式？ RowBounds是一次性查询全部结果吗？为什么？ Mybatis逻辑分页和物理分页的区别是什么？ Mybatis是否支持延迟加载？延迟加载的原理是什么？ 说一下Mybatis的一级缓存和二级缓存？ Mybatis和Hibernate的区别有哪些？ Mybatis有哪些执行器(Executor)？ Mybatis分页插件的实现原理是什么？ Mybatis如何编写一个自定义插件？ RabbitMQ RabbitMQ的使用场景有哪些？ RabbitMQ有哪些重要的角色？ RabbitMQ有哪些重要的组件？ RabbitMQ中vhost的作用是什么？ RabbitMQ的消息是怎么发送的？ RabbitMQ怎么保证消息的稳定性？ RabbitMQ怎么避免消息丢失？ 要保证消息持久化成功的条件有哪些？ RabbitMQ持久化有什么缺点？ RabbitMQ有几种广播类型？ RabbitMQ怎么实现延迟消息队列？ RabbitMQ集群有什么用？ RabbitMQ节点的类型有哪些？ RabbitMQ集群搭建需要注意哪些问题？ RabbitMQ每个节点是其他节点的完整拷贝吗？为什么？ RabbitMQ集群中唯一一个磁盘节点崩溃了会发生什么情况？ RabbitMQ对集群节点停止顺序有要求吗？ Kafka Kafka可以脱离zookeeper单独使用吗？为什么？ Kafka有几种数据保留的策略？ Kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候Kafka将如何处理？ 什么情况会导致Kafka运行变慢？ 使用Kafka集群需要注意什么？ Zookeeper Zookeeper是什么？ Zookeeper都有哪些功能？ Zookeeper有几种部署模式？ Zookeeper怎么保证主从节点的状态同步？ 集群中为什么要有主节点？ 集群中有3台服务器，其中一个节点宕机，这个时候Zookeeper还可以使用吗？ 说一下Zookeeper的通知机制？ Mysql 数据库的三范式是什么？ 一张自增表里面总共有7条数据，删除了最后2条数据，重启Mysql数据库，又插入了一条数据，此时ID是多少？ 如何获取当前数据库版本？ 说一下ACID是什么？ char和varchar的区别是什么？ float和double的区别是什么？ Mysql的内连接、左连接、右连接有什么区别？ Mysql索引是怎么实现的？ 怎么验证Mysql的索引是否满足需求？ 说一下数据库的事务隔离？ 说一下Mysql常用的引擎？ 说一下Mysql的行锁和表锁？ 说一下乐观锁和悲观锁？ Mysql问题排查都有哪些手段？ 如何做Mysql的性能优化？ Redis Redis是什么？都有哪些使用场景？ Redis有哪些功能？ Redis和Memcache有什么区别？ Redis为什么是单线程的？ 什么是缓存穿透？怎么解决？ 184.Redis支持的数据类型有哪些？ Redis支持的Java客户端都有哪些？ jedis和redisson有哪些区别？ 怎么保证缓存和数据库数据的一致性？ Redis持久化有几种方式？ Redis怎么实现分布式锁？ Redis分布式锁有什么缺陷？ Redis如何做内存优化？ Redis淘汰策略有哪些？ Redis常见的性能问题有哪些？该如何解决？ JVM 说一下JVM的主要组成部分？及其作用？ 说一下JVM运行时数据区？ 说一下堆栈的区别？ 队列和栈是什么？有什么区别？ 什么是双亲委派模型？ 说一下类装载的执行过程？ 怎么判断对象是否可以被回收？ Java中都有哪些引用类型？ 说一下JVM有哪些垃圾回收算法？ 说一下JVM有哪些垃圾回收器？ 详细介绍一下CMS垃圾回收器？ 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 简述分代垃圾回收器是怎么工作的？ 说一下JVM调优的工具？ 常用的JVM调优的参数都有哪些？ 题卷VI Java基础 JDK和JRE有什么区别？ 名称 解释 JDK Java Development Kit的简称，java开发工具包，提供了java的开发环境和运行环境。 JRE Java Runtime Environment的简称，java运行环境，为java的运行提供了所需环境。 具体来说JDK其实包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具。简单来说如果你需要运行java程序，只需安装JRE就可以了，如果你需要编写java程序，需要安装JDK。 ==和equals的区别是什么？ == 基本类型: 比较的是值是否相同； 引用类型: 比较的是引用是否相同。 String x = \"string\"; String y = \"string\"; String z = new String(\"string\"); System.out.println(x==y); // true System.out.println(x==z); // false System.out.println(x.equals(y)); // true System.out.println(x.equals(z)); // true 因为x和y指向的是同一个引用，所以==也是true，而new String()方法则重写开辟了内存空间，所以==结果为 false，而equals比较的一直是值，所以结果都为true。 equals equals本质上就是==，只不过String和Integer等重写了equals方法，把它变成了值比较。 class Cat { private String name; public Cat(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Cat c1 = new Cat(\"王磊\"); Cat c2 = new Cat(\"王磊\"); System.out.println(c1.equals(c2)); // false // equals本质上就是== public boolean equals(Object obj) { return (this == obj); } 两个相同值的String对象，为什么返回的是true？ String s1 = new String(\"老王\"); String s2 = new String(\"老王\"); System.out.println(s1.equals(s2)); // true public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } String重写了Object的equals方法，把引用比较改成了值比较。 总结 ==对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而equals默认情况下是引用比较，只是很多类重写了equals方法，比如String、Integer等把它变成了值比较，所以一般情况下equals比较的是值是否相等。 两个对象的hashCode()相同，则equals()也一定为true？ 两个对象的hashCode()相同，equals()不一定true。 String str1 = \"通话\"; String str2 = \"重地\"; System.out.println(String.format(\"str1: %d | str2: %d\", str1.hashCode(), str2.hashCode())); System.out.println(str1.equals(str2)); str1: 1179395 | str2: 1179395 false 很显然“通话”和“重地”的hashCode()相同，然而equals()则为false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等并不一定能得出键值对相等。 final在Java中有什么作用？ 使用范围 解释 修饰类 被final修饰的类不允许被继承，表示此类设计的很完美，不需要被修改和扩展。 修饰方法 被final修饰的方法表示此方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写此方法。 修饰变量 当final修饰变量时，表示该属性一旦被初始化便不可以被修改。 修饰参数 当final修饰参数时，表示此参数在整个方法内不允许被修改。 使用final修饰类可以防止被其他类继承，如JD代码中String类就是被final修饰的，从而防止被其他类继承，导致内部逻辑被破坏。 final是Java中常见的一个关键字，被它修饰的对象不允许修改、替换其原始值或定义。final有4种用法，可以用来修饰类、方法、变量或参数。 Math.round(-1.5)等于多少？ -1 Math.round()表示“四舍六入”，将原来的数字加上0.5后再向下取整。 Math.round(x) => Math.floor(x + 0.5) String属于基础的数据类型吗？ 不属于，String属于对象。 基础数据类型 字节长度(byte) byte 1 short 2 int 4 long 8 boolean 1 char 2 float 4 double 8 Java中操作字符串都有哪些类？它们之间有什么区别？ ———— 可变性 线程安全性 性能 String 用字符数组保存字符串，private final char value[]，所以String对象是不可变的。 对象是不可变的，也就可以理解为常量，线程安全。 每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。 StringBuffer 继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，是可变的。 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 本身进行操作，而不是生成新的对象并改变对象引用。 StringBuilder 同StringBuffer。 并没有对方法进行加同步锁，所以是非线程安全的。 StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升。 String str=\"i\"与String str=new String(\"i\")一样吗？ 不一样，因为内存的分配方式不一样。String str=\"i\"的方式，Java虚拟机会将其分配到常量池中；而String str=new String(\"i\")则会被分到堆内存中。 如何将字符串反转？ 使用StringBuilder或者StringBuffer的reverse()方法。 // StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(\"abcdefg\"); System.out.println(stringBuffer.reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"abcdefg\"); System.out.println(stringBuilder.reverse()); // gfedcba String类的常用方法都有那些？ 方法名称 解释 indexOf() 返回指定字符的索引。 charAt() 返回指定索引处的字符。 replace() 字符串替换。 trim() 去除字符串两端空白。 split() 分割字符串，返回一个分割后的字符串数组。 getBytes() 返回字符串的byte类型数组。 length() 返回字符串长度。 toLowerCase() 将字符串转成小写字母。 toUpperCase() 将字符串转成大写字符。 substring() 截取字符串。 equals() 字符串比较。 抽象类必须要有抽象方法吗？ 不需要，抽象类不一定非要有抽象方法。 abstract class Cat { public static void sayHi() { System.out.println(\"hi~\"); } } 上面代码，抽象类并没有抽象方法但完全可以正常运行。 普通类和抽象类有哪些区别？ 普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 抽象类能使用final修饰吗？ 不能，定义抽象类就是让其他类继承的，如果定义为final该类就不能被继承，这样彼此就会产生矛盾，所以final不能修饰抽象类。 接口和抽象类有什么区别？ 区别 接口 抽象类 实现 使用implements来实现接口。 子类使用extends来继承。 构造函数 不能有。 可以有构造函数。 实现数量 类可以实现很多个接口。 只能继承一个抽象类。 访问修饰符 方法默认使用public修饰。 可以是任意访问修饰符。 Java中IO流分为几种？ 按功能来分: 输入流(input)、输出流(output)。 按类型来分: 字节流和字符流。 字节流和字符流的区别是，字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符为单位输入输出数据。 BIO、NIO、AIO有什么区别？ 类型 解释 BIO Block IO同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。 NIO New IO(或Non Blocking IO)同步非阻塞IO，是传统IO的升级，客户端和服务器端通过Channel(通道)通讯，实现了多路复用。 AIO Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非堵塞IO，异步IO的操作基于事件和回调机制。 Files的常用方法都有哪些？ 方法 解释 Files.exists() 检测文件路径是否存在。 Files.createFile() 创建文件。 Files.createDirectory() 创建文件夹。 Files.delete() 删除一个文件或目录。 Files.copy() 复制文件。 Files.move() 移动文件。 Files.size() 查看文件个数。 Files.read() 读取文件。 Files.write() 写入文件。 容器 Java容器都有哪些？ Collection和Collections有什么区别？ 类 解释 Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如List、Set等。 Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法Collections.sort(list)。 List、Set、Map之间的区别是什么？ HashMap和Hashtable有什么区别？ // todo 如何决定使用HashMap还是TreeMap？ // todo 说一下HashMap的实现原理？ // todo 说一下HashSet的实现原理？ // todo ArrayList和LinkedList的区别是什么？ // todo 如何实现数组和List之间的转换？ // todo ArrayList和Vector的区别是什么？ // todo Array和ArrayList有何区别？ // todo 在Queue中poll()和remove()有什么区别？ // todo 哪些集合类是线程安全的？ // todo 迭代器Iterator是什么？ // todo Iterator怎么使用？有什么特点？ // todo Iterator和ListIterator有什么区别？ // todo 怎么确保一个集合不能被修改？ // todo 多线程 并行和并发有什么区别？ // todo 线程和进程的区别？ // todo 守护线程是什么？ // todo 创建线程有哪几种方式？ // todo 说一下runnable和callable有什么区别？ // todo 线程有哪些状态？ // todo sleep()和wait()有什么区别？ // todo notify()和notifyAll()有什么区别？ // todo 线程的run()和start()有什么区别？ // todo 创建线程池有哪几种方式？ // todo 线程池都有哪些状态？ // todo 线程池中submit()和execute()方法有什么区别？ // todo 在Java程序中怎么保证多线程的运行安全？ // todo 多线程中synchronized锁升级的原理是什么？ 在锁对象的对象头里面有一个threadid字段，在第一次访问的时候threadid为空，jvm让其持有偏向锁，并将threadid设置为其线程id，再次进入的时候会先判断threadid是否与其线程id一致，如果一致则可以直接使用此对象；如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了synchronized锁的升级。 锁升级是为了减低了锁带来的性能消耗。在Java 6之后优化synchronized的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。 什么是死锁？ // todo 怎么防止死锁？ // todo ThreadLocal是什么？有哪些使用场景？ // todo 说一下synchronized底层实现原理？ // todo synchronized和volatile的区别是什么？ // todo synchronized和Lock有什么区别？ // todo synchronized和ReentrantLock区别是什么？ // todo 说一下atomic的原理？ 通过CAS乐观锁保证原子性，通过自旋保证当次修改的最终修改成功，通过降低锁粒度(多段锁)增加并发性能。 反射 什么是反射？ 反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。 什么是Java序列化？什么情况下需要序列化？ Java序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。 想把的内存中的对象状态保存到一个文件中或者数据库中时候； 想用套接字在网络上传送对象的时候； 想通过RMI(远程方法调用)传输对象的时候。 动态代理是什么？有哪些应用？ // todo 怎么实现动态代理？ // todo 对象拷贝 为什么要使用克隆？ // todo 如何实现对象克隆？ // todo 深拷贝和浅拷贝区别是什么？ // todo Java Web模块 JSP和servlet有什么区别？ // todo JSP有哪些内置对象？作用分别是什么？ // todo 说一下JSP的4种作用域？ // todo session和cookie有什么区别？ 区别 解释 存储位置不同 session存储在服务器端；cookie存储在浏览器端。 安全性不同 cookie安全性一般，在浏览器存储，可以被伪造和修改。 容量和个数限制 cookie有容量限制，每个站点下的cookie也有个数限制。 存储的多样性 session可以存储在redis中、数据库中、应用程序中；而cookie只能存储在浏览器中。 说一下session的工作原理？ 客户端登录完成之后，服务器会创建对应的session，session创建完之后，会把session的id发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着sessionid，服务器拿到sessionid之后，在内存找到与之对应的session这样就可以正常工作了。 如果客户端禁止cookie能实现session还能用吗？ 可以用，session只是依赖cookie存储sessionid，如果cookie被禁用了，可以使用url中添加sessionid的方式保证session能正常使用。 springMVC和struts的区别是什么？ // todo 如何避免sql注入？ 使用预处理PreparedStatement。 使用正则表达式过滤掉字符中的特殊字符。 什么是XSS攻击？如何避免？ 跨站脚本攻击，它是web程序中常见的漏洞。原理是攻击者往web页面里插入恶意的脚本代码(css 代码、javascript代码等)，当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户cookie、破坏页面结构、重定向到其他网站等。预防XSS的核心是必须对输入的数据做过滤处理。 什么是CSRF攻击？如何避免？ Cross-Site Request Forgery(跨站请求伪造)，可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如以你名义发送邮件、发消息、购买商品，虚拟货币转账等。 验证请求来源地址； 关键操作添加验证码； 在请求地址添加token并验证。 异常模块 throw和throws的区别？ // todo final、finally、finalize有什么区别？ // todo try-catch-finally中哪个部分可以省略？ // todo try-catch-finally中，如果catch中return了，finally还会执行吗？ // todo 常见的异常类有哪些？ // todo 网络模块 http响应码301和302代表的是什么？有什么区别？ // todo forward和redirect的区别？ // todo 简述TCP和UDP的区别？ // todo TCP为什么要三次握手，两次不行吗？为什么？ // todo 说一下TCP粘包是怎么产生的？ // todo OSI的七层模型都有哪些？ // todo get和post请求有哪些区别？ // todo 如何实现跨域？ // todo 说一下JSONP实现原理？ // todo 设计模式 说一下你熟悉的设计模式？ 设计模式 解释 单例模式 保证被创建一次，节省系统开销。 工厂模式 解耦代码。 观察者模式 定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。 外观模式 提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。 模版方法模式 定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。 状态模式 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 简单工厂和抽象工厂有什么区别？ // todo Spring MVC 为什么要使用Spring？ // todo 解释一下什么是AOP？ // todo 解释一下什么是IOC？ // todo Spring有哪些主要模块？ // todo Spring常用的注入方式有哪些？ // todo Spring中的bean是线程安全的吗？ // todo Spring支持几种bean的作用域？ // todo Spring自动装配bean有哪些方式？ // todo Spring事务实现方式有哪些？ // todo 说一下Spring的事务隔离？ // todo 说一下SpringMVC运行流程？ // todo SpringMVC有哪些组件？ // todo @RequestMapping的作用是什么？ // todo @Autowired的作用是什么？ // todo Spring Boot/Spring Cloud 什么是Spring Boot？ // todo 为什么要用Spring Boot？ // todo Spring Boot核心配置文件是什么？ // todo Spring Boot配置文件有哪几种类型？它们有什么区别？ // todo Spring Boot有哪些方式可以实现热部署？ // todo JPA和Hibernate有什么区别？ // todo 什么是Spring Cloud？ // todo Spring Cloud断路器的作用是什么？ // todo Spring Cloud的核心组件有哪些？ // todo Hibernate 为什么要使用Hibernate？ // todo 什么是ORM框架？ // todo Hibernate中如何在控制台查看打印的sql语句？ // todo Hibernate有几种查询方式？ // todo Hibernate实体类可以被定义为final吗？ // todo 在Hibernate中使用Integer和int做映射有什么区别？ // todo Hibernate是如何工作的？ // todo get()和load()的区别？ // todo 说一下Hibernate的缓存机制？ // todo Hibernate对象有哪些状态？ // todo 在Hibernate中getCurrentSession和openSession的区别是什么？ // todo Hibernate实体类必须要有无参构造函数吗？为什么？ // todo Mybatis Mybatis中#{}和${}的区别是什么？ #{}是预编译处理，${}是字符替换。 在使用#{}时，Mybatis会将sql中的#{}替换成“?”，配合PreparedStatement的set方法赋值，这样可以有效的防止sql注入，保证程序的运行安全。 Mybatis有几种分页方式？ 分页方式 解释 逻辑分页 使用Mybatis自带的RowBounds进行分页，它是一次性查询很多数据，然后在数据中再进行检索。 物理分页 自己手写sql分页或使用分页插件PageHelper，去数据库查询指定条数的分页数据的形式。 RowBounds是一次性查询全部结果吗？为什么？ RowBounds表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为Mybatis是对jdbc的封装，在jdbc驱动中有一个Fetch Size的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行next()的时候，去查询更多的数据。就好比你去自动取款机取10000元，但取款机每次最多能取2500元，所以你要取4次才能把钱取完。只是对于jdbc来说，当你调用next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。 Mybatis逻辑分页和物理分页的区别是什么？ 分页 区别 逻辑分页 一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。 物理分页 从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。 Mybatis是否支持延迟加载？延迟加载的原理是什么？ lazyLoadingEnabled=true 延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用a.getB().getName()，这个时候发现a.getB()的值为null，此时会单独触发事先保存好的关联B对象的sql，先查询出来B，然后再调用a.setB(b)，而这时候再调用a.getB().getName()就有值了，这就是延迟加载的基本原理。 说一下Mybatis的一级缓存和二级缓存？ 缓存 解释 一级缓存 基于PerpetualCache的HashMap本地缓存，它的声明周期是和sqlSession一致的，有多个sqlSession或者分布式的环境中数据库操作，可能会出现脏数据。当Session flush或close之后，该Session中的所有Cache就将清空，默认一级缓存是开启的。 二级缓存 也是基于PerpetualCache的HashMap本地缓存，不同在于其存储作用域为Mapper级别的，如果多个sqlSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)。 开启二级缓存数据查询流程: 二级缓存 -> 一级缓存 -> 数据库。 缓存更新机制: 当某一个作用域(一级缓存Session/二级缓存Mapper)进行了C/U/D操作后，默认该作用域下所有select中的缓存将被clear。 Mybatis和Hibernate的区别有哪些？ // todo Mybatis有哪些执行器(Executor)？ 执行器 解释 SimpleExecutor 每执行一次update或select就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor 执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后不关闭Statement对象，而是放置于Map内供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor 执行update(没有select，jdbc批处理不支持select)，将所有sql都添加到批处理中(addBatch())，等待统一执行(executeBatch())，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理，与jdbc批处理相同。 Mybatis分页插件的实现原理是什么？ 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 Mybatis如何编写一个自定义插件？ 自定义插件实现原理 Mybatis自定义插件针对Mybatis四大对象(Executor、StatementHandler、ParameterHandler、ResultSetHandler)进行拦截: Mybatis对象 解释 Executor 拦截内部执行器，它负责调用StatementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射，另外它还处理了二级缓存的操作。 StatementHandler 拦截sql语法构建的处理，它是Mybatis直接和数据库执行sql脚本的对象，另外它也实现了Mybatis的一级缓存。 ParameterHandler 拦截参数的处理。 ResultSetHandler 拦截结果集的处理。 自定义插件实现关键 Mybatis插件要实现Interceptor接口，接口包含的方法，如下: public interface Interceptor { Object intercept(Invocation invocation) throws Throwable; Object plugin(Object target); void setProperties(Properties properties); } 接口方法 解释 setProperties() 在Mybatis进行配置插件的时候可以配置自定义相关属性，即接口实现对象的参数配置。 plugin() 插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例return Plugin.wrap(target, this)。 intercept() 要进行拦截的时候要执行的方法。 自定义插件实现示例 @Intercepts({@Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})}) public class TestInterceptor implements Interceptor { public Object intercept(Invocation invocation) throws Throwable { Object target = invocation.getTarget(); //被代理对象 Method method = invocation.getMethod(); //代理方法 Object[] args = invocation.getArgs(); //方法参数 // do something ...... 方法拦截前执行代码块 Object result = invocation.proceed(); // do something .......方法拦截后执行代码块 return result; } public Object plugin(Object target) { return Plugin.wrap(target, this); } } RabbitMQ RabbitMQ的使用场景有哪些？ // todo RabbitMQ有哪些重要的角色？ // todo RabbitMQ有哪些重要的组件？ // todo RabbitMQ中vhost的作用是什么？ // todo RabbitMQ的消息是怎么发送的？ // todo RabbitMQ怎么保证消息的稳定性？ // todo RabbitMQ怎么避免消息丢失？ // todo 要保证消息持久化成功的条件有哪些？ // todo RabbitMQ持久化有什么缺点？ // todo RabbitMQ有几种广播类型？ // todo RabbitMQ怎么实现延迟消息队列？ // todo RabbitMQ集群有什么用？ // todo RabbitMQ节点的类型有哪些？ // todo RabbitMQ集群搭建需要注意哪些问题？ // todo RabbitMQ每个节点是其他节点的完整拷贝吗？为什么？ // todo RabbitMQ集群中唯一一个磁盘节点崩溃了会发生什么情况？ // todo RabbitMQ对集群节点停止顺序有要求吗？ // todo Kafka Kafka可以脱离zookeeper单独使用吗？为什么？ kafka不能脱离zookeeper单独使用，因为kafka使用zookeeper管理和协调kafka的节点服务器。 Kafka有几种数据保留的策略？ 过期时间保留 按照存储的消息大小 Kafka同时设置了7天和10G清除数据，到第五天的时候消息达到了10G，这个时候Kafka将如何处理？ Kafka会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。 什么情况会导致Kafka运行变慢？ CPU性能瓶颈 磁盘读写瓶颈 网络瓶颈 使用Kafka集群需要注意什么？ 集群的数量不是越多越好，最好不要超过7个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。 集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。 Zookeeper Zookeeper是什么？ Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是google chubby的开源实现，是hadoop和hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括配置维护、域名服务、分布式同步、组服务等。 Zookeeper都有哪些功能？ 功能 解释 集群管理 监控节点存活状态、运行请求等。 主节点选举 主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用zookeeper可以协助完成这个过程。 分布式锁 zookeeper提供两种锁独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享、读写互斥，即可以有多线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。 命名服务 在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址、提供者等信息。 Zookeeper有几种部署模式？ 部署模式 解释 单机部署 一台集群上运行。 集群部署 多台集群运行。 伪集群部署 一台集群启动多个zookeeper实例运行。 Zookeeper怎么保证主从节点的状态同步？ zookeeper的核心是原子广播，这个机制保证了各个server之间的同步。实现这个机制的协议叫做zab协议。 zab协议有两种模式，分别是恢复模式(选主)和广播模式(同步)。当服务启动或者在领导者崩溃后，zab就进入了恢复模式，当领导者被选举出来，且大多数server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和server具有相同的系统状态。 集群中为什么要有主节点？ 在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。 集群中有3台服务器，其中一个节点宕机，这个时候Zookeeper还可以使用吗？ 可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。 说一下Zookeeper的通知机制？ 客户端端会对某个znode建立一个watcher事件，当该znode发生变化时，这些客户端会收到zookeeper的通知，然后客户端可以根据znode变化来做出业务上的改变。 Mysql 数据库的三范式是什么？ 范式 解释 第一范式 强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。 第二范式 要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。 第三范式 任何非主属性不依赖于其它非主属性。 一张自增表里面总共有7条数据，删除了最后2条数据，重启Mysql数据库，又插入了一条数据，此时ID是多少？ 表类型如果是MyISAM，那ID就是8。表类型如果是InnoDB，那ID就是6。InnoDB表只会把自增主键的最大ID记录在内存中，所以重启之后会导致最大ID丢失。 如何获取当前数据库版本？ select version(); 说一下ACID是什么？ ACID 解释 Atomicity(原子性) 一个事务(transaction)中的所有操作，或者全部完成、或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复(Rollback)到事务开始前的状态，就像这个事务从来没有执行过一样。即事务不可分割、不可约简。 Consistency(一致性) 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 Isolation(隔离性) 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交(Read Uncommitted)、读提交(Read Committed)、可重复读(Repeatable Read)和串行化(Serializable)。 Durability(持久性) 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 char和varchar的区别是什么？ 名称 解释 优点 缺点 适用场景 char(n) 固定长度类型，比如订阅char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是10个字节，其他7个是空字节。 效率高。 占用空间。 存储密码的md5值，固定长度的，使用char非常合适。 varchar(n) 可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。 -- -- -- float和double的区别是什么？ 名称 解释 float 最多可以存储8位的十进制数，并在内存中占4字节。 double 最可可以存储16位的十进制数，并在内存中占8字节。 Mysql的内连接、左连接、右连接有什么区别？ 名称 解释 内连接(inner join) 把匹配的关联数据显示出来。 左连接(left join) 左边的表全部显示出来，右边的表显示出符合条件的数据。 右连接(right join) 右边的表全部显示出来，左边的表显示出符合条件的数据。 Mysql索引是怎么实现的？ 索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 具体来说Mysql中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是B+树实现的，B+树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。 怎么验证Mysql的索引是否满足需求？ 使用explain查看sql是如何执行查询语句的，从而分析你的索引是否满足需求。 explain语法: explain select * from ${table_name} where ${column_name} = 'xxx'; 说一下数据库的事务隔离？ Mysql的事务隔离是在mysql.ini配置文件里添加的，在文件的最后添加: transaction-isolation = REPEATABLE-READ 可用的配置值: READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。 事务隔离级别 解释 READ-UNCOMMITTED 未提交读，最低隔离级别、事务未提交前，就可被其他事务读取(会出现幻读、脏读、不可重复读)。 READ-COMMITTED 提交读，一个事务提交后才能被其他事务读取到(会造成幻读、不可重复读)。 REPEATABLE-READ 可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据(会造成幻读)。 SERIALIZABLE 序列化，代价最高、最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 事务隔离异常 解释 脏读 表示一个事务能够读取另一个事务中还未提交的数据。比如某个事务尝试插入记录A，此时该事务还未提交，然后另一个事务尝试读取到了记录A。 不可重复读 是指在一个事务内，多次读同一数据。 幻读 指同一个事务内多次查询返回的结果集不一样。比如同一个事务A第一次查询时候有n条记录，但是第二次同等条件下查询却有n+1条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。 说一下Mysql常用的引擎？ 引擎 解释 InnoDB引擎 Mysql 5.1之后默认引擎，提供了对数据库ACID事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。Mysql运行的时候，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行select count(*) from table指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。 MyISAM引擎 不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和InnoDB不同的是，MyISAM引擎是保存了表的行数，于是当进行select count(*) from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将MyISAM作为数据库引擎的首选。 说一下Mysql的行锁和表锁？ MyISAM只支持表锁，InnoDB支持表锁和行锁，默认为行锁。 锁级别 解释 行锁 开销大、加锁慢、会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 表锁 开销小、加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 说一下乐观锁和悲观锁？ 锁类别 解释 乐观锁 每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁 每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。 数据库的乐观锁需要自己实现，在表里面添加一个version字段，每次修改成功值加1，这样每次修改的时候先对比一下，自己拥有的version和数据库现在的version是否一致，如果不一致就不修改，这样就实现了乐观锁。 Mysql问题排查都有哪些手段？ 使用show processlist命令查看当前所有连接信息。 使用explain命令查询sql语句执行计划。 开启慢查询日志，查看慢查询的sql。 如何做Mysql的性能优化？ 为搜索字段创建索引。 避免使用select *，列出需要查询的字段。 垂直分割分表。 选择正确的存储引擎。 Redis Redis是什么？都有哪些使用场景？ Redis是一个使用C语言开发的高速缓存数据库。 记录帖子点赞数、点击数、评论数； 缓存近期热帖； 缓存文章详情信息； 记录用户会话信息。 Redis有哪些功能？ 数据缓存功能； 分布式锁的功能； 支持数据持久化； 支持事务； 支持消息队列。 Redis和Memcache有什么区别？ 区别 解释 存储方式不同 Memcache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis有部份存在硬盘上，这样能保证数据的持久性。 数据支持类型 Memcache对数据类型支持相对简单；Redis有复杂的数据类型。 使用底层模型不同 它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value值大小不同 Redis最大可以达到512MB；Memcache只有1MB。 Redis为什么是单线程的？ 因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU又不会成为瓶颈，那就顺理成章地采用单线程的方案了。 关于Redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。而且单线程并不代表就慢Nginx和Nodejs也都是高性能单线程的代表。 什么是缓存穿透？怎么解决？ 指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 最简单粗暴的方法如果一个查询返回的数据为空(不管是数据不存在，还是系统故障)，我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 184.Redis支持的数据类型有哪些？ string(字符串)； list(列表)； hash(字典)； set(集合)； zset(有序集合)。 Redis支持的Java客户端都有哪些？ redisson； jedis； lettuce。 jedis和redisson有哪些区别？ 名称 区别 jedis 提供了比较全面的Redis命令的支持。 redisson 实现了分布式和可扩展的Java数据结构，与jedis相比redisson的功能相对简单，不支持排序、事务、管道、分区等Redis特性。 怎么保证缓存和数据库数据的一致性？ 合理设置缓存的过期时间。 新增、更改、删除数据库操作时同步更新Redis，可以使用事物机制来保证数据的一致性。 Redis持久化有几种方式？ 方式 解释 RDB(Redis Database) 指定的时间间隔能对你的数据进行快照存储。 AOF(Append Only File) 每一个收到的写命令都通过write函数追加到文件中。 Redis怎么实现分布式锁？ Redis分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。 占坑一般使用setnx(set if not exists)指令，只允许被一个程序占有，使用完调用del释放锁。 Redis分布式锁有什么缺陷？ Redis分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。 Redis如何做内存优化？ 尽量使用Redis的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将web系统的用户对象，应该放到散列表里面再整体存储到Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置key进行存储。 Redis淘汰策略有哪些？ 淘汰策略 解释 volatile-lru 从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰。 volatile-ttl 从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰。 volatile-random 从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰。 allkeys-lru 从数据集(server.db[i].dict)中挑选最近最少使用的数据淘汰。 allkeys-random 从数据集(server.db[i].dict)中任意选择数据淘汰。 no-enviction 禁止驱逐数据。 Redis常见的性能问题有哪些？该如何解决？ 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。 Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。 JVM 说一下JVM的主要组成部分？及其作用？ 类加载器(ClassLoader) 运行时数据区(Runtime Data Area) 执行引擎(Execution Engine) 本地库接口(Native Interface) 首先通过类加载器(ClassLoader)会把Java代码转换成字节码，运行时数据区(Runtime Data Area)再把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎(Execution Engine)，将字节码翻译成底层系统指令，再交由CPU去执行，而这个过程中需要调用其他语言的本地库接口(Native Interface)来实现整个程序的功能。 说一下JVM运行时数据区？ 运行时数据区 解释 程序计数器(Program Counter Register) 当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。 Java虚拟机栈(Java Virtual Machine Stacks) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 本地方法栈(Native Method Stack) 与虚拟机栈的作用是一样的，只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用Native方法服务的。 Java堆(Java Heap) Java虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。 方法区(Method Area) 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 说一下堆栈的区别？ 区别 解释 功能方面 堆是用来存放对象的，栈是用来执行程序的。 共享性 堆是线程共享的，栈是线程私有的。 空间大小 堆大小远远大于栈。 队列和栈是什么？有什么区别？ 队列和栈都是被用来预存储数据的。 队列允许先进先出检索元素，但也有例外的情况，Deque接口允许从两端检索元素。 栈和队列很相似，但它运行对元素进行后进先出进行检索。 什么是双亲委派模型？ 在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将Class文件加载到JVM内存，然后再转化为Class对象。 类加载器 解释 启动类加载器(Bootstrap ClassLoader) 是虚拟机自身的一部分，用来加载JAVA_HOME/lib/目录中的，或者被-Xbootclasspath参数所指定的路径中并且被虚拟机识别的类库。 扩展类加载器(Extension ClassLoader) 负责加载\\lib\\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。 应用程序类加载器(Application ClassLoader) 负责加载用户类路径(classpath)上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求(它的搜索范围中没找到所需的类)时，子加载器才会尝试去加载类。 说一下类装载的执行过程？ 执行过程 解释 加载 根据查找路径找到相应的class文件然后导入。 检查 检查加载的class文件的正确性。 准备 给类中的静态变量分配内存空间。 解析 虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标识，而在直接引用直接指向内存中的地址。 初始化 对静态变量和静态代码块执行初始化工作。 怎么判断对象是否可以被回收？ 回收方法 解释 引用计数器 为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。它有一个缺点不能解决循环引用的问题。 可达性分析 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。 Java中都有哪些引用类型？ 引用类型 解释 强引用 发生GC的时候不会被回收。 软引用 有用但不是必须的对象，在发生内存溢出之前会被回收。 弱引用 有用但不是必须的对象，在下一次GC时会被回收。 虚引用 无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用的用途是在GC时返回一个通知。 说一下JVM有哪些垃圾回收算法？ 垃圾回收算法 解释 标记-清除算法 标记无用对象，然后进行清除回收。缺点效率不高，无法清除垃圾碎片。 标记-整理算法 标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。 复制算法 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点内存使用率不高，只有原来的一半。 分代算法 根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。 说一下JVM有哪些垃圾回收器？ 垃圾回收器 解释 Serial 最早的单线程串行垃圾回收器。 Serial Old Serial垃圾回收器的老年版本，同样也是单线程的，可以作为CMS垃圾回收器的备选预案。 ParNew 是Serial的多线程版本。 Parallel 和ParNew收集器类似是多线程的，但Parallel是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old 是Parallel老生代版本，Parallel使用的是复制的内存回收算法，Parallel Old使用的是标记-整理的内存回收算法。 CMS 一种以获得最短停顿时间为目标的收集器，非常适用B/S系统。 G1 一种兼顾吞吐量和停顿时间的GC实现，是JDK 9以后的默认GC选项。 详细介绍一下CMS垃圾回收器？ CMS是英文Concurrent Mark-Sweep的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM的参数加上-XX:+UseConcMarkSweepGC来指定使用CMS垃圾回收器。 CMS使用的是标记-清除的算法实现的，所以在GC的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现Concurrent Mode Failure，临时CMS会采用Serial Old回收器进行垃圾清除，此时的性能将会被降低。 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 垃圾回收器 -- 解释 新生代回收器 Serial、ParNew、Parallel Scavenge 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低。 老年代回收器 Serial Old、Parallel Old、CMS 老年代回收器一般采用的是标记-整理的算法进行垃圾回收。 整堆回收器 G1 -- 简述分代垃圾回收器是怎么工作的？ 分代回收器有两个分区老生代和新生代，新生代默认的空间占比总空间的1/3，老生代的默认占比是2/3。 新生代使用的是复制算法，新生代里有3个分区Eden、To Survivor、From Survivor，它们的默认占比是8:1:1，它的执行流程如下: 把Eden + From Survivor存活的对象放入To Survivor区。 清空Eden和From Survivor分区。 From Survivor和To Survivor分区交换，From Survivor变To Survivor，To Survivor变From Survivor。 每次在From Survivor到To Survivor移动时都存活的对象，年龄就+1，当年龄到达15(默认配置是15)时，升级为老生代。大对象也会直接进入老生代。老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。 说一下JVM调优的工具？ JDK自带了很多监控工具，都位于jdk的bin目录下，其中最常用的是jconsole和jvisualvm这两款视图监控工具。 调优工具 解释 jconsole 用于对JVM中的内存、线程和类等进行监控。 jvisualvm JDK自带的全能分析工具，可以分析内存快照、线程快照、程序死锁、监控内存的变化、GC变化等。 常用的JVM调优的参数都有哪些？ 调优参数 解释 Xms2g 初始化推大小为2g。 Xmx2g 堆最大内存为2g。 XX:NewRatio=4 设置年轻的和老年代的内存比例为1:4。 XX:SurvivorRatio=8 设置新生代Eden和Survivor比例为8:2。 XX:+UseParNewGC 指定使用ParNew+Serial Old垃圾回收器组合。 XX:+UseParallelOldGC 指定使用ParNew+ParNew Old垃圾回收器组合。 XX:+UseConcMarkSweepGC 指定使用CMS+Serial Old垃圾回收器组合。 XX:+PrintGC 开启打印GC信息。 XX:+PrintGCDetails 打印GC详细信息。 "},"pages/review/ReviewVII.html":{"url":"pages/review/ReviewVII.html","title":"题卷VII","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 第一季 第二季 第三季 HashMap的底层数据结构 JDK1.8中对hash算法和寻址算法是如何优化的 HashMap是如何解决hash碰撞问题的 HashMap是如何进行扩容的 并发编程 synchronized关键字的底层原理 CAS的底层实现原理 ConcurrentHashMap实现线程安全的底层原理 AQS的实现原理 线程池的底层工作原理 线程池的核心配置参数 如果在线程池中使用无界阻塞队列会发生什么问题 如果线程池的队列满了，会发生什么 如果线上机器突然宕机，线程池中阻塞队列的请求该怎么办 Java内存模型 Java内存模型的原子性、有序性、可见性 volatile关键字的原理 指令重排以及happens-before原则 volatile底层是如何基于内存屏障保证可见性和有序性的 Spring的IOC和AOP机制 JDK和cglib动态代理 Spring中的Bean是线程安全的吗 Spring的事务实现原理？事务传播机制 画一张图说明SpringBoot的核心架构 画一张图说明Spring的核心架构 Spring中使用的设计模式 画一张图说明SpringMVC的核心架构 画一张图说明SpringCloud的核心架构 JVM中有哪几块内存区域？Java8之后对内存分代做了什么改进 JVM是如何运行起来的？对象是如何分配的 JVM在哪些情况下会触发垃圾回收 JVM年轻代的垃圾回收算法？对象什么时候转移到老年代 JVM老年代的垃圾回收算法？常用的垃圾回收器都有什么 生产环境Tomcat是如何设置JVM参数的？如何检查JVM运行情况 实际项目中是否做过JVM优化？怎么做的 发生OOM之后，应该如何排查和处理线上系统的OOM问题 TCP/IP四层模型，OSI七层模型 浏览器请求www.baidu.com的过程 TCP三次握手，为什么不是二次或者四次 HTTP协议工作的原理 HTTPS协议工作的原理 HTTP长连接的工作原理 53、MySQL的MyISAM和InnoDB存储引擎的区别 MySQL的索引实现原理？各种索引平时都怎么用的 事务的特性？有哪几种隔离级别 Socket的工作原理？Socket和TP/IP之间的关系 进程间是如何通信的？线程间又如何切换的 NIO/BIO/AIO 线上服务器CPU100%满了，该怎么排查、定位和解决 线上机器的一个进程kill杀死不掉该怎么办？磁盘空间满了又该怎么办 Java规范规定所有变量写操作都是原子性的 32位Java虚拟机double和long的变量写操作为何不是原子的 volatile可以保证double和long变量写操作的原子性 有哪些操作在Java规范中是不保证原子性的 可见性涉及的底层硬件概念：寄存器、高速缓存、写缓冲器 深入探秘有序性：Java程序运行过程中发生指令重排的几个地方 JIT编译器对创建对象的指令重排以及double_check单例实践 题卷VII(中华石杉) 第一季 第二季 第三季 HashMap的底层数据结构 JDK1.8中对hash算法和寻址算法是如何优化的 HashMap是如何解决hash碰撞问题的 HashMap是如何进行扩容的 并发编程 synchronized关键字的底层原理 CAS的底层实现原理 ConcurrentHashMap实现线程安全的底层原理 AQS的实现原理 线程池的底层工作原理 线程池的核心配置参数 如果在线程池中使用无界阻塞队列会发生什么问题 如果线程池的队列满了，会发生什么 如果线上机器突然宕机，线程池中阻塞队列的请求该怎么办 Java内存模型 Java内存模型的原子性、有序性、可见性 volatile关键字的原理 指令重排以及happens-before原则 volatile底层是如何基于内存屏障保证可见性和有序性的 Spring的IOC和AOP机制 JDK和cglib动态代理 Spring中的Bean是线程安全的吗 Spring的事务实现原理？事务传播机制 画一张图说明SpringBoot的核心架构 画一张图说明Spring的核心架构 Spring中使用的设计模式 画一张图说明SpringMVC的核心架构 画一张图说明SpringCloud的核心架构 JVM中有哪几块内存区域？Java8之后对内存分代做了什么改进 JVM是如何运行起来的？对象是如何分配的 JVM在哪些情况下会触发垃圾回收 JVM年轻代的垃圾回收算法？对象什么时候转移到老年代 JVM老年代的垃圾回收算法？常用的垃圾回收器都有什么 生产环境Tomcat是如何设置JVM参数的？如何检查JVM运行情况 实际项目中是否做过JVM优化？怎么做的 发生OOM之后，应该如何排查和处理线上系统的OOM问题 TCP/IP四层模型，OSI七层模型 浏览器请求www.baidu.com的过程 TCP三次握手，为什么不是二次或者四次 HTTP协议工作的原理 HTTPS协议工作的原理 HTTP长连接的工作原理 53、MySQL的MyISAM和InnoDB存储引擎的区别 MySQL的索引实现原理？各种索引平时都怎么用的 事务的特性？有哪几种隔离级别 Socket的工作原理？Socket和TP/IP之间的关系 进程间是如何通信的？线程间又如何切换的 NIO/BIO/AIO 线上服务器CPU100%满了，该怎么排查、定位和解决 线上机器的一个进程kill杀死不掉该怎么办？磁盘空间满了又该怎么办 Java规范规定所有变量写操作都是原子性的 32位Java虚拟机double和long的变量写操作为何不是原子的 volatile可以保证double和long变量写操作的原子性 有哪些操作在Java规范中是不保证原子性的 可见性涉及的底层硬件概念：寄存器、高速缓存、写缓冲器 深入探秘有序性：Java程序运行过程中发生指令重排的几个地方 JIT编译器对创建对象的指令重排以及double_check单例实践 "},"pages/Question.html":{"url":"pages/Question.html","title":"实战问题","keywords":"","body":" 问题I "},"pages/question/QuestionI.html":{"url":"pages/question/QuestionI.html","title":"问题I","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 线上服务问题定位步骤 现象描述 排查思路 排查过程 排查是否是应用服务器外网网络带宽问题导致接口响应缓慢 排查是否应用服务器出现问题 应用服务代码问题 排查是否是JVM堆栈分配问题 排查是否是数据库问题 排查是否是应用服务器和数据库服务器间网络问题 总结 问题I 线上服务问题定位步骤 现象描述 最近XX项目上出现了服务运行一段时间后不操作系统接口查询缓慢的问题，导致线上服务经常出现登录提示成功，但获取用户权限数据响应超时问题，导致登录不成功的现象，重启服务可暂时解决此问题。 排查思路 排查是否应用服务器外网网络带宽问题； 排查是否应用服务器、数据库服务器出现问题； 排查是否是应用服务代码问题； 排查是否是JVM问题； 排查是否是数据库问题； 排查是否是应用服务器和数据库服务器间网络问题。 排查过程 排查是否是应用服务器外网网络带宽问题导致接口响应缓慢 在浏览器按F12，进入开发模式，查看接口响应时间并记录，登录线上应用服务器，用curl命令直接本地服务，观察接口返回时间。 curl -H 'X-Access-Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NDMxMjQwMjUsInVzZXJuYW1lIjoiYWRtaW4ifQ.40zZZnZu7RlxsQWpi4CfajBOT4iBP66xlePnEiyPSxQ' http://192.168.70.13:7003/skboot/sys/permission/list 如果在本地服务器上请求数据返回正常，基本可以确定为外网网络问题。 排查是否应用服务器出现问题 使用top命令查看服务器资源信息，查看cpu、内存资源使用情况。如果服务器资源情况健康，基本可以排除应用服务器方面问题。 应用服务代码问题 规范化项目编码，避免可能引起莫名其妙的bug配置 清除不用的定时任务； 不要在功能影响不确定的情况下修改java底层代码； 不要在不清楚的情况下随意修改项目配置文件(application-*.yml)。 分析jvm堆栈信息，排除不规范代码引起的死循环或对象创建导致的fullGC问题 生成dump文件。 jmap -dump:live,format=b,file=dump.hprof 28920(java进程号) 可以用jvm分析工具打开dump文件，查看是否存在死锁及大对象情况。 观察jvm垃圾回收情况及新老年代使用占比，一般老年代占满会导致频繁fullGC导致占用服务资源造成服务卡顿 观察jvm堆栈内存使用情况。 jmap -heap 31846 观察jvm垃圾回收情况，查看FGC这一列数据情况。 jstat -gc 31846 1000 20 如果这些数据均正常，基本可以排除不存在死循环、死锁、堆内频繁对象创建及jvm频繁FGC情况。 排查是否是JVM堆栈分配问题 基于上述排查，基本可以看出启动脚本jvm堆栈分配情况，jvm堆栈分配为服务器物理内存的三分之二，后面我们会调整一般服务启动脚本，共享给大家。 排查是否是数据库问题 对于自己安装的mysql数据库，排查mysql异常日志情况，登录数据库服务器，查看mysql异常日志。 通过查看mysql异常日志，可以看到大量ip域名解析记录，配置mysql反向DNS域名解析属性，对于自己安装的mysql数据库，可以安装完成后按照如何配置调优。 # 数据库修改配置 vi /etc/my.cnf # 新增以下配置 binlog_error_action=IGNORE_ERROR innodb_flush_log_at_trx_commit=2 innodb_buffer_pool_size=9024M innodb_log_files_in_group=4 innodb_log_file_size=1024M innodb_page_cleaners=2 expire_logs_days=3 default-time_zone='+8:00' event_scheduler=1 max_connections=3000 排查是否是应用服务器和数据库服务器间网络问题 以上步骤均排查完成后，仍存在此问题，进行网络层面问题排查。 调用不查询数据库的接口查看是否存在慢的问题，如果是基本定位到应用服务层面的问题； 调用查询数据库的接口查看是否存在慢的问题，如果存在基本可以定位为应用与数据库服务器维护的连接池TCP长连接问题，在应用服务器查询数据库连接信息。 数据库层面查询连接信息 show processlist 从数据库层面杀死数据库连接，再次查看接口请求响应情况，发现接口响应数据回归正常。 问题原因 应用服务器和数据库服务器不在用一个网段，且线上网络情况复杂，我们不清楚中间路由、防火墙及各种网络策略，导致应用服务启动后创建数据库连接池，在服务不操作的情况下，默认保持了最小的数据库线程连接，长时间不操作系统，保持的数据库连接由于网络问题出现了“假死”情况，且应用服务无法唤醒激活，只能杀死连接系统重新创建一个才能正常。 解决方案 在数据库连接地址上添加数据库连接失效参数 datasource: master: #赤水测试服务器数据库 url: jdbc:mysql://192.168.88.51:3306/zhsw-ynlj?characterEncoding=UTF-8&useUnicode=true&useSSL=false&connectTimeout=60000&socketTimeout=1800 username: root password: xxxxxx driver-class-name: com.mysql.jdbc.Driver 配置最小数据库连接数为0，此方案长时间不操作自动杀死idle状态线程，用的时候重新创建 dynamic: druid: # 全局druid参数，绝大部分值和默认保持一致。(现已支持的参数如下,不清楚含义不要乱设置) # 连接池的配置信息 # 初始化大小，最小，最大 initial-size: 5 min-idle: 0 maxActive: 10 # 配置获取连接等待超时的时间 maxWait: 60000 总结 服务器环境如果可以应用服务器和数据库服务器在同一网段，且不要添加各种网络策略； 应用服务开发要规范化，删除掉与本项目无关的东西，例如不用的定时任务等，配置方面、java底层方面在不了解具体情况下不少轻易改动； 数据库服务方面，对于自己安装的mysql库，按照上面配置做数据库调优； 应用服务启动脚本，使用项目中启动脚本，根据服务器资源情况，调整堆栈大小。 "},"pages/Resource.html":{"url":"pages/Resource.html","title":"其他资源","keywords":"","body":" 面试锦集 学习网站 学习博客 "},"pages/resource/InterviewLink.html":{"url":"pages/resource/InterviewLink.html","title":"面试锦集","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 网络资源 PDF资源 面试锦集 网络资源 👉 潜林 👉 互联网Java工程师进阶知识完全扫盲 👉 Java面试真题解析 👉 JavaGuide PDF资源 👉 JAVA核心面试知识整理 👉 JavaGuide面试突击版v3 👉 advanced-java 👉 史上最全的Java面试题独家整理 👉 1000道互联网Java工程师面试题 👉 Java并发编程最全面试题123道 👉 Java基础面试题 👉 Java集合面试题52道 👉 Java异常面试题 👉 JVM面试专题及答案 👉 MyBatis面试专题 👉 Mysql面试专题 👉 Redis面试专题 👉 Spring面试专题及答案 👉 操作系统面试题 👉 分布式面试必会 👉 计算机网络面试题 👉 我想进大厂 👉 Socket常用API详解 👉 图解HTTP 👉 图解操作系统 👉 图解计算机基础 👉 图解网络 👉 图解系统 👉 30万字大厂面试真题 "},"pages/resource/WebsiteLink.html":{"url":"pages/resource/WebsiteLink.html","title":"学习网站","keywords":"","body":"学习网站 👉 掘金 👉 bugstack虫洞栈 👉 CodeGuide 👉 labuladong的算法小抄 👉 尚硅谷大数据技术之Kafka 👉 JEECG 👉 leetcode 👉 看云 👉 sleepyocean "},"pages/resource/BlogLink.html":{"url":"pages/resource/BlogLink.html","title":"学习博客","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 前端 后端 WINDOW LINUX NGINX GIT 学习博客 前端 👉 windows安装npm(Node.js)教程 后端 👉 java驼峰转换工具类 👉 spring boot通过Druid的数据源和sqlSessionTemplate方式实现双数据源 👉 Spring事务传播机制详解 👉 聊聊Spring事务失效的10种场景，太坑人了 👉 EMQ X简介与MQTT集成Java开发 👉 常见OOM原因及解决方案 👉 什么是零拷贝 👉 比雪花算法更好用的ID生成算法 WINDOW // todo LINUX // todo NGINX 👉 tcpdump抓包学习Nginx(反向代理)，学完不怵nginx了，还总想跃跃欲试！(Nginx使用、原理完整版手册) 👉 X-Forwarded-For的一些理解 GIT 👉 git同时推送到github和gitee "},"pages/Ending.html":{"url":"pages/Ending.html","title":"后记","keywords":"","body":"哈喽，亲爱的童鞋们，是不是觉得已经看完了？哈哈...告诉你，大错特错，笨猪写的才是一小部分。比如Redis，ElasticSearch这些数据库笨猪觉得已经有社区针对面试完善的非常好了，笨猪只是不想重复劳动(后面会给链接的哈)。还有常用的一些中间件，笨猪也没有写，是不是觉得笨猪很懒，其实并不是啦，理由同上，有人写了啊！笨猪又不傻，当然不会重复劳动。再说，要是写的不好，怕是要挨批了奥。最后，算法！算法！算法！ 重要的事情说三遍，算法不能漏奥，每天一道leetcode，强化自己的算法能力奥！！！ 写到最后，恭祝童鞋们找到自己满意的工作！！！ "}}